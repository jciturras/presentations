// script.aculo.us effects.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
// Contributors:
//  Justin Palmer (http://encytemedia.com/)
//  Mark Pilgrim (http://diveintomark.org/)
//  Martin Bialasinki
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

// converts rgb() and #xxx to #xxxxxx format,
// returns self (or first argument) if not convertable
String.prototype.parseColor = function() {
  var color = '#';
  if (this.slice(0,4) == 'rgb(') {
    var cols = this.slice(4,this.length-1).split(',');
    var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);
  } else {
    if (this.slice(0,1) == '#') {
      if (this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();
      if (this.length==7) color = this.toLowerCase();
    }
  }
  return (color.length==7 ? color : (arguments[0] || this));
};

/*--------------------------------------------------------------------------*/

Element.collectTextNodes = function(element) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      (node.hasChildNodes() ? Element.collectTextNodes(node) : ''));
  }).flatten().join('');
};

Element.collectTextNodesIgnoreClass = function(element, className) {
  return $A($(element).childNodes).collect( function(node) {
    return (node.nodeType==3 ? node.nodeValue :
      ((node.hasChildNodes() && !Element.hasClassName(node,className)) ?
        Element.collectTextNodesIgnoreClass(node, className) : ''));
  }).flatten().join('');
};

Element.setContentZoom = function(element, percent) {
  element = $(element);
  element.setStyle({fontSize: (percent/100) + 'em'});
  if (Prototype.Browser.WebKit) window.scrollBy(0,0);
  return element;
};

Element.getInlineOpacity = function(element){
  return $(element).style.opacity || '';
};

Element.forceRerendering = function(element) {
  try {
    element = $(element);
    var n = document.createTextNode(' ');
    element.appendChild(n);
    element.removeChild(n);
  } catch(e) { }
};

/*--------------------------------------------------------------------------*/

var Effect = {
  _elementDoesNotExistError: {
    name: 'ElementDoesNotExistError',
    message: 'The specified DOM element does not exist, but is required for this effect to operate'
  },
  Transitions: {
    linear: Prototype.K,
    sinoidal: function(pos) {
      return (-Math.cos(pos*Math.PI)/2) + .5;
    },
    reverse: function(pos) {
      return 1-pos;
    },
    flicker: function(pos) {
      var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;
      return pos > 1 ? 1 : pos;
    },
    wobble: function(pos) {
      return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;
    },
    pulse: function(pos, pulses) {
      return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;
    },
    spring: function(pos) {
      return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));
    },
    none: function(pos) {
      return 0;
    },
    full: function(pos) {
      return 1;
    }
  },
  DefaultOptions: {
    duration:   1.0,   // seconds
    fps:        100,   // 100= assume 66fps max.
    sync:       false, // true for combining
    from:       0.0,
    to:         1.0,
    delay:      0.0,
    queue:      'parallel'
  },
  tagifyText: function(element) {
    var tagifyStyle = 'position:relative';
    if (Prototype.Browser.IE) tagifyStyle += ';zoom:1';

    element = $(element);
    $A(element.childNodes).each( function(child) {
      if (child.nodeType==3) {
        child.nodeValue.toArray().each( function(character) {
          element.insertBefore(
            new Element('span', {style: tagifyStyle}).update(
              character == ' ' ? String.fromCharCode(160) : character),
              child);
        });
        Element.remove(child);
      }
    });
  },
  multiple: function(element, effect) {
    var elements;
    if (((typeof element == 'object') ||
        Object.isFunction(element)) &&
       (element.length))
      elements = element;
    else
      elements = $(element).childNodes;

    var options = Object.extend({
      speed: 0.1,
      delay: 0.0
    }, arguments[2] || { });
    var masterDelay = options.delay;

    $A(elements).each( function(element, index) {
      new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));
    });
  },
  PAIRS: {
    'slide':  ['SlideDown','SlideUp'],
    'blind':  ['BlindDown','BlindUp'],
    'appear': ['Appear','Fade']
  },
  toggle: function(element, effect, options) {
    element = $(element);
    effect  = (effect || 'appear').toLowerCase();
    
    return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({
      queue: { position:'end', scope:(element.id || 'global'), limit: 1 }
    }, options || {}));
  }
};

Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;

/* ------------- core effects ------------- */

Effect.ScopedQueue = Class.create(Enumerable, {
  initialize: function() {
    this.effects  = [];
    this.interval = null;
  },
  _each: function(iterator) {
    this.effects._each(iterator);
  },
  add: function(effect) {
    var timestamp = new Date().getTime();

    var position = Object.isString(effect.options.queue) ?
      effect.options.queue : effect.options.queue.position;

    switch(position) {
      case 'front':
        // move unstarted effects after this effect
        this.effects.findAll(function(e){ return e.state=='idle' }).each( function(e) {
            e.startOn  += effect.finishOn;
            e.finishOn += effect.finishOn;
          });
        break;
      case 'with-last':
        timestamp = this.effects.pluck('startOn').max() || timestamp;
        break;
      case 'end':
        // start effect after last queued effect has finished
        timestamp = this.effects.pluck('finishOn').max() || timestamp;
        break;
    }

    effect.startOn  += timestamp;
    effect.finishOn += timestamp;

    if (!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))
      this.effects.push(effect);

    if (!this.interval)
      this.interval = setInterval(this.loop.bind(this), 15);
  },
  remove: function(effect) {
    this.effects = this.effects.reject(function(e) { return e==effect });
    if (this.effects.length == 0) {
      clearInterval(this.interval);
      this.interval = null;
    }
  },
  loop: function() {
    var timePos = new Date().getTime();
    for(var i=0, len=this.effects.length;i<len;i++)
      this.effects[i] && this.effects[i].loop(timePos);
  }
});

Effect.Queues = {
  instances: $H(),
  get: function(queueName) {
    if (!Object.isString(queueName)) return queueName;

    return this.instances.get(queueName) ||
      this.instances.set(queueName, new Effect.ScopedQueue());
  }
};
Effect.Queue = Effect.Queues.get('global');

Effect.Base = Class.create({
  position: null,
  start: function(options) {
    if (options && options.transition === false) options.transition = Effect.Transitions.linear;
    this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });
    this.currentFrame = 0;
    this.state        = 'idle';
    this.startOn      = this.options.delay*1000;
    this.finishOn     = this.startOn+(this.options.duration*1000);
    this.fromToDelta  = this.options.to-this.options.from;
    this.totalTime    = this.finishOn-this.startOn;
    this.totalFrames  = this.options.fps*this.options.duration;

    this.render = (function() {
      function dispatch(effect, eventName) {
        if (effect.options[eventName + 'Internal'])
          effect.options[eventName + 'Internal'](effect);
        if (effect.options[eventName])
          effect.options[eventName](effect);
      }

      return function(pos) {
        if (this.state === "idle") {
          this.state = "running";
          dispatch(this, 'beforeSetup');
          if (this.setup) this.setup();
          dispatch(this, 'afterSetup');
        }
        if (this.state === "running") {
          pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;
          this.position = pos;
          dispatch(this, 'beforeUpdate');
          if (this.update) this.update(pos);
          dispatch(this, 'afterUpdate');
        }
      };
    })();

    this.event('beforeStart');
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).add(this);
  },
  loop: function(timePos) {
    if (timePos >= this.startOn) {
      if (timePos >= this.finishOn) {
        this.render(1.0);
        this.cancel();
        this.event('beforeFinish');
        if (this.finish) this.finish();
        this.event('afterFinish');
        return;
      }
      var pos   = (timePos - this.startOn) / this.totalTime,
          frame = (pos * this.totalFrames).round();
      if (frame > this.currentFrame) {
        this.render(pos);
        this.currentFrame = frame;
      }
    }
  },
  cancel: function() {
    if (!this.options.sync)
      Effect.Queues.get(Object.isString(this.options.queue) ?
        'global' : this.options.queue.scope).remove(this);
    this.state = 'finished';
  },
  event: function(eventName) {
    if (this.options[eventName + 'Internal']) this.options[eventName + 'Internal'](this);
    if (this.options[eventName]) this.options[eventName](this);
  },
  inspect: function() {
    var data = $H();
    for(property in this)
      if (!Object.isFunction(this[property])) data.set(property, this[property]);
    return '#<Effect:' + data.inspect() + ',options:' + $H(this.options).inspect() + '>';
  }
});

Effect.Parallel = Class.create(Effect.Base, {
  initialize: function(effects) {
    this.effects = effects || [];
    this.start(arguments[1]);
  },
  update: function(position) {
    this.effects.invoke('render', position);
  },
  finish: function(position) {
    this.effects.each( function(effect) {
      effect.render(1.0);
      effect.cancel();
      effect.event('beforeFinish');
      if (effect.finish) effect.finish(position);
      effect.event('afterFinish');
    });
  }
});

Effect.Tween = Class.create(Effect.Base, {
  initialize: function(object, from, to) {
    object = Object.isString(object) ? $(object) : object;
    var args = $A(arguments), method = args.last(),
      options = args.length == 5 ? args[3] : null;
    this.method = Object.isFunction(method) ? method.bind(object) :
      Object.isFunction(object[method]) ? object[method].bind(object) :
      function(value) { object[method] = value };
    this.start(Object.extend({ from: from, to: to }, options || { }));
  },
  update: function(position) {
    this.method(position);
  }
});

Effect.Event = Class.create(Effect.Base, {
  initialize: function() {
    this.start(Object.extend({ duration: 0 }, arguments[0] || { }));
  },
  update: Prototype.emptyFunction
});

Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    // make this work on IE on elements without 'layout'
    if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
      this.element.setStyle({zoom: 1});
    var options = Object.extend({
      from: this.element.getOpacity() || 0.0,
      to:   1.0
    }, arguments[1] || { });
    this.start(options);
  },
  update: function(position) {
    this.element.setOpacity(position);
  }
});

Effect.Move = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      x:    0,
      y:    0,
      mode: 'relative'
    }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    this.element.makePositioned();
    this.originalLeft = parseFloat(this.element.getStyle('left') || '0');
    this.originalTop  = parseFloat(this.element.getStyle('top')  || '0');
    if (this.options.mode == 'absolute') {
      this.options.x = this.options.x - this.originalLeft;
      this.options.y = this.options.y - this.originalTop;
    }
  },
  update: function(position) {
    this.element.setStyle({
      left: (this.options.x  * position + this.originalLeft).round() + 'px',
      top:  (this.options.y  * position + this.originalTop).round()  + 'px'
    });
  }
});

// for backwards compatibility
Effect.MoveBy = function(element, toTop, toLeft) {
  return new Effect.Move(element,
    Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));
};

Effect.Scale = Class.create(Effect.Base, {
  initialize: function(element, percent) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      scaleX: true,
      scaleY: true,
      scaleContent: true,
      scaleFromCenter: false,
      scaleMode: 'box',        // 'box' or 'contents' or { } with provided values
      scaleFrom: 100.0,
      scaleTo:   percent
    }, arguments[2] || { });
    this.start(options);
  },
  setup: function() {
    this.restoreAfterFinish = this.options.restoreAfterFinish || false;
    this.elementPositioning = this.element.getStyle('position');

    this.originalStyle = { };
    ['top','left','width','height','fontSize'].each( function(k) {
      this.originalStyle[k] = this.element.style[k];
    }.bind(this));

    this.originalTop  = this.element.offsetTop;
    this.originalLeft = this.element.offsetLeft;

    var fontSize = this.element.getStyle('font-size') || '100%';
    ['em','px','%','pt'].each( function(fontSizeType) {
      if (fontSize.indexOf(fontSizeType)>0) {
        this.fontSize     = parseFloat(fontSize);
        this.fontSizeType = fontSizeType;
      }
    }.bind(this));

    this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;

    this.dims = null;
    if (this.options.scaleMode=='box')
      this.dims = [this.element.offsetHeight, this.element.offsetWidth];
    if (/^content/.test(this.options.scaleMode))
      this.dims = [this.element.scrollHeight, this.element.scrollWidth];
    if (!this.dims)
      this.dims = [this.options.scaleMode.originalHeight,
                   this.options.scaleMode.originalWidth];
  },
  update: function(position) {
    var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);
    if (this.options.scaleContent && this.fontSize)
      this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });
    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);
  },
  finish: function(position) {
    if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);
  },
  setDimensions: function(height, width) {
    var d = { };
    if (this.options.scaleX) d.width = width.round() + 'px';
    if (this.options.scaleY) d.height = height.round() + 'px';
    if (this.options.scaleFromCenter) {
      var topd  = (height - this.dims[0])/2;
      var leftd = (width  - this.dims[1])/2;
      if (this.elementPositioning == 'absolute') {
        if (this.options.scaleY) d.top = this.originalTop-topd + 'px';
        if (this.options.scaleX) d.left = this.originalLeft-leftd + 'px';
      } else {
        if (this.options.scaleY) d.top = -topd + 'px';
        if (this.options.scaleX) d.left = -leftd + 'px';
      }
    }
    this.element.setStyle(d);
  }
});

Effect.Highlight = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({ startcolor: '#ffff99' }, arguments[1] || { });
    this.start(options);
  },
  setup: function() {
    // Prevent executing on elements not in the layout flow
    if (this.element.getStyle('display')=='none') { this.cancel(); return; }
    // Disable background image during the effect
    this.oldStyle = { };
    if (!this.options.keepBackgroundImage) {
      this.oldStyle.backgroundImage = this.element.getStyle('background-image');
      this.element.setStyle({backgroundImage: 'none'});
    }
    if (!this.options.endcolor)
      this.options.endcolor = this.element.getStyle('background-color').parseColor('#ffffff');
    if (!this.options.restorecolor)
      this.options.restorecolor = this.element.getStyle('background-color');
    // init color calculations
    this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));
    this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));
  },
  update: function(position) {
    this.element.setStyle({backgroundColor: $R(0,2).inject('#',function(m,v,i){
      return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });
  },
  finish: function() {
    this.element.setStyle(Object.extend(this.oldStyle, {
      backgroundColor: this.options.restorecolor
    }));
  }
});

Effect.ScrollTo = function(element) {
  var options = arguments[1] || { },
  scrollOffsets = document.viewport.getScrollOffsets(),
  elementOffsets = $(element).cumulativeOffset();

  if (options.offset) elementOffsets[1] += options.offset;

  return new Effect.Tween(null,
    scrollOffsets.top,
    elementOffsets[1],
    options,
    function(p){ scrollTo(scrollOffsets.left, p.round()); }
  );
};

/* ------------- combination effects ------------- */

Effect.Fade = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  var options = Object.extend({
    from: element.getOpacity() || 1.0,
    to:   0.0,
    afterFinishInternal: function(effect) {
      if (effect.options.to!=0) return;
      effect.element.hide().setStyle({opacity: oldOpacity});
    }
  }, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Appear = function(element) {
  element = $(element);
  var options = Object.extend({
  from: (element.getStyle('display') == 'none' ? 0.0 : element.getOpacity() || 0.0),
  to:   1.0,
  // force Safari to render floated elements properly
  afterFinishInternal: function(effect) {
    effect.element.forceRerendering();
  },
  beforeSetup: function(effect) {
    effect.element.setOpacity(effect.options.from).show();
  }}, arguments[1] || { });
  return new Effect.Opacity(element,options);
};

Effect.Puff = function(element) {
  element = $(element);
  var oldStyle = {
    opacity: element.getInlineOpacity(),
    position: element.getStyle('position'),
    top:  element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height
  };
  return new Effect.Parallel(
   [ new Effect.Scale(element, 200,
      { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),
     new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],
     Object.extend({ duration: 1.0,
      beforeSetupInternal: function(effect) {
        Position.absolutize(effect.effects[0].element);
      },
      afterFinishInternal: function(effect) {
         effect.effects[0].element.hide().setStyle(oldStyle); }
     }, arguments[1] || { })
   );
};

Effect.BlindUp = function(element) {
  element = $(element);
  element.makeClipping();
  return new Effect.Scale(element, 0,
    Object.extend({ scaleContent: false,
      scaleX: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping();
      }
    }, arguments[1] || { })
  );
};

Effect.BlindDown = function(element) {
  element = $(element);
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: 0,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makeClipping().setStyle({height: '0px'}).show();
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping();
    }
  }, arguments[1] || { }));
};

Effect.SwitchOff = function(element) {
  element = $(element);
  var oldOpacity = element.getInlineOpacity();
  return new Effect.Appear(element, Object.extend({
    duration: 0.4,
    from: 0,
    transition: Effect.Transitions.flicker,
    afterFinishInternal: function(effect) {
      new Effect.Scale(effect.element, 1, {
        duration: 0.3, scaleFromCenter: true,
        scaleX: false, scaleContent: false, restoreAfterFinish: true,
        beforeSetup: function(effect) {
          effect.element.makePositioned().makeClipping();
        },
        afterFinishInternal: function(effect) {
          effect.element.hide().undoClipping().undoPositioned().setStyle({opacity: oldOpacity});
        }
      });
    }
  }, arguments[1] || { }));
};

Effect.DropOut = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.getStyle('top'),
    left: element.getStyle('left'),
    opacity: element.getInlineOpacity() };
  return new Effect.Parallel(
    [ new Effect.Move(element, {x: 0, y: 100, sync: true }),
      new Effect.Opacity(element, { sync: true, to: 0.0 }) ],
    Object.extend(
      { duration: 0.5,
        beforeSetup: function(effect) {
          effect.effects[0].element.makePositioned();
        },
        afterFinishInternal: function(effect) {
          effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);
        }
      }, arguments[1] || { }));
};

Effect.Shake = function(element) {
  element = $(element);
  var options = Object.extend({
    distance: 20,
    duration: 0.5
  }, arguments[1] || {});
  var distance = parseFloat(options.distance);
  var split = parseFloat(options.duration) / 10.0;
  var oldStyle = {
    top: element.getStyle('top'),
    left: element.getStyle('left') };
    return new Effect.Move(element,
      { x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {
    new Effect.Move(effect.element,
      { x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {
        effect.element.undoPositioned().setStyle(oldStyle);
  }}); }}); }}); }}); }}); }});
};

Effect.SlideDown = function(element) {
  element = $(element).cleanWhitespace();
  // SlideDown need to have the content of the element wrapped in a container element with fixed height!
  var oldInnerBottom = element.down().getStyle('bottom');
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleX: false,
    scaleFrom: window.opera ? 0 : 1,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makePositioned();
      effect.element.down().makePositioned();
      if (window.opera) effect.element.setStyle({top: ''});
      effect.element.makeClipping().setStyle({height: '0px'}).show();
    },
    afterUpdateInternal: function(effect) {
      effect.element.down().setStyle({bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping().undoPositioned();
      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom}); }
    }, arguments[1] || { })
  );
};

Effect.SlideUp = function(element) {
  element = $(element).cleanWhitespace();
  var oldInnerBottom = element.down().getStyle('bottom');
  var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, window.opera ? 0 : 1,
   Object.extend({ scaleContent: false,
    scaleX: false,
    scaleMode: 'box',
    scaleFrom: 100,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makePositioned();
      effect.element.down().makePositioned();
      if (window.opera) effect.element.setStyle({top: ''});
      effect.element.makeClipping().show();
    },
    afterUpdateInternal: function(effect) {
      effect.element.down().setStyle({bottom:
        (effect.dims[0] - effect.element.clientHeight) + 'px' });
    },
    afterFinishInternal: function(effect) {
      effect.element.hide().undoClipping().undoPositioned();
      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom});
    }
   }, arguments[1] || { })
  );
};

// Bug in opera makes the TD containing this element expand for a instance after finish
Effect.Squish = function(element) {
  return new Effect.Scale(element, window.opera ? 1 : 0, {
    restoreAfterFinish: true,
    beforeSetup: function(effect) {
      effect.element.makeClipping();
    },
    afterFinishInternal: function(effect) {
      effect.element.hide().undoClipping();
    }
  });
};

Effect.Grow = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.full
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity() };

  var dims = element.getDimensions();
  var initialMoveX, initialMoveY;
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      initialMoveX = initialMoveY = moveX = moveY = 0;
      break;
    case 'top-right':
      initialMoveX = dims.width;
      initialMoveY = moveY = 0;
      moveX = -dims.width;
      break;
    case 'bottom-left':
      initialMoveX = moveX = 0;
      initialMoveY = dims.height;
      moveY = -dims.height;
      break;
    case 'bottom-right':
      initialMoveX = dims.width;
      initialMoveY = dims.height;
      moveX = -dims.width;
      moveY = -dims.height;
      break;
    case 'center':
      initialMoveX = dims.width / 2;
      initialMoveY = dims.height / 2;
      moveX = -dims.width / 2;
      moveY = -dims.height / 2;
      break;
  }

  return new Effect.Move(element, {
    x: initialMoveX,
    y: initialMoveY,
    duration: 0.01,
    beforeSetup: function(effect) {
      effect.element.hide().makeClipping().makePositioned();
    },
    afterFinishInternal: function(effect) {
      new Effect.Parallel(
        [ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),
          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),
          new Effect.Scale(effect.element, 100, {
            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },
            sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})
        ], Object.extend({
             beforeSetup: function(effect) {
               effect.effects[0].element.setStyle({height: '0px'}).show();
             },
             afterFinishInternal: function(effect) {
               effect.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);
             }
           }, options)
      );
    }
  });
};

Effect.Shrink = function(element) {
  element = $(element);
  var options = Object.extend({
    direction: 'center',
    moveTransition: Effect.Transitions.sinoidal,
    scaleTransition: Effect.Transitions.sinoidal,
    opacityTransition: Effect.Transitions.none
  }, arguments[1] || { });
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    height: element.style.height,
    width: element.style.width,
    opacity: element.getInlineOpacity() };

  var dims = element.getDimensions();
  var moveX, moveY;

  switch (options.direction) {
    case 'top-left':
      moveX = moveY = 0;
      break;
    case 'top-right':
      moveX = dims.width;
      moveY = 0;
      break;
    case 'bottom-left':
      moveX = 0;
      moveY = dims.height;
      break;
    case 'bottom-right':
      moveX = dims.width;
      moveY = dims.height;
      break;
    case 'center':
      moveX = dims.width / 2;
      moveY = dims.height / 2;
      break;
  }

  return new Effect.Parallel(
    [ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),
      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),
      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })
    ], Object.extend({
         beforeStartInternal: function(effect) {
           effect.effects[0].element.makePositioned().makeClipping();
         },
         afterFinishInternal: function(effect) {
           effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle); }
       }, options)
  );
};

Effect.Pulsate = function(element) {
  element = $(element);
  var options    = arguments[1] || { },
    oldOpacity = element.getInlineOpacity(),
    transition = options.transition || Effect.Transitions.linear,
    reverser   = function(pos){
      return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);
    };

  return new Effect.Opacity(element,
    Object.extend(Object.extend({  duration: 2.0, from: 0,
      afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }
    }, options), {transition: reverser}));
};

Effect.Fold = function(element) {
  element = $(element);
  var oldStyle = {
    top: element.style.top,
    left: element.style.left,
    width: element.style.width,
    height: element.style.height };
  element.makeClipping();
  return new Effect.Scale(element, 5, Object.extend({
    scaleContent: false,
    scaleX: false,
    afterFinishInternal: function(effect) {
    new Effect.Scale(element, 1, {
      scaleContent: false,
      scaleY: false,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping().setStyle(oldStyle);
      } });
  }}, arguments[1] || { }));
};

Effect.Morph = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      style: { }
    }, arguments[1] || { });

    if (!Object.isString(options.style)) this.style = $H(options.style);
    else {
      if (options.style.include(':'))
        this.style = options.style.parseStyle();
      else {
        this.element.addClassName(options.style);
        this.style = $H(this.element.getStyles());
        this.element.removeClassName(options.style);
        var css = this.element.getStyles();
        this.style = this.style.reject(function(style) {
          return style.value == css[style.key];
        });
        options.afterFinishInternal = function(effect) {
          effect.element.addClassName(effect.options.style);
          effect.transforms.each(function(transform) {
            effect.element.style[transform.style] = '';
          });
        };
      }
    }
    this.start(options);
  },

  setup: function(){
    function parseColor(color){
      if (!color || ['rgba(0, 0, 0, 0)','transparent'].include(color)) color = '#ffffff';
      color = color.parseColor();
      return $R(0,2).map(function(i){
        return parseInt( color.slice(i*2+1,i*2+3), 16 );
      });
    }
    this.transforms = this.style.map(function(pair){
      var property = pair[0], value = pair[1], unit = null;

      if (value.parseColor('#zzzzzz') != '#zzzzzz') {
        value = value.parseColor();
        unit  = 'color';
      } else if (property == 'opacity') {
        value = parseFloat(value);
        if (Prototype.Browser.IE && (!this.element.currentStyle.hasLayout))
          this.element.setStyle({zoom: 1});
      } else if (Element.CSS_LENGTH.test(value)) {
          var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);
          value = parseFloat(components[1]);
          unit = (components.length == 3) ? components[2] : null;
      }

      var originalValue = this.element.getStyle(property);
      return {
        style: property.camelize(),
        originalValue: unit=='color' ? parseColor(originalValue) : parseFloat(originalValue || 0),
        targetValue: unit=='color' ? parseColor(value) : value,
        unit: unit
      };
    }.bind(this)).reject(function(transform){
      return (
        (transform.originalValue == transform.targetValue) ||
        (
          transform.unit != 'color' &&
          (isNaN(transform.originalValue) || isNaN(transform.targetValue))
        )
      );
    });
  },
  update: function(position) {
    var style = { }, transform, i = this.transforms.length;
    while(i--)
      style[(transform = this.transforms[i]).style] =
        transform.unit=='color' ? '#'+
          (Math.round(transform.originalValue[0]+
            (transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +
          (Math.round(transform.originalValue[1]+
            (transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +
          (Math.round(transform.originalValue[2]+
            (transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :
        (transform.originalValue +
          (transform.targetValue - transform.originalValue) * position).toFixed(3) +
            (transform.unit === null ? '' : transform.unit);
    this.element.setStyle(style, true);
  }
});

Effect.Transform = Class.create({
  initialize: function(tracks){
    this.tracks  = [];
    this.options = arguments[1] || { };
    this.addTracks(tracks);
  },
  addTracks: function(tracks){
    tracks.each(function(track){
      track = $H(track);
      var data = track.values().first();
      this.tracks.push($H({
        ids:     track.keys().first(),
        effect:  Effect.Morph,
        options: { style: data }
      }));
    }.bind(this));
    return this;
  },
  play: function(){
    return new Effect.Parallel(
      this.tracks.map(function(track){
        var ids = track.get('ids'), effect = track.get('effect'), options = track.get('options');
        var elements = [$(ids) || $$(ids)].flatten();
        return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });
      }).flatten(),
      this.options
    );
  }
});

Element.CSS_PROPERTIES = $w(
  'backgroundColor backgroundPosition borderBottomColor borderBottomStyle ' +
  'borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth ' +
  'borderRightColor borderRightStyle borderRightWidth borderSpacing ' +
  'borderTopColor borderTopStyle borderTopWidth bottom clip color ' +
  'fontSize fontWeight height left letterSpacing lineHeight ' +
  'marginBottom marginLeft marginRight marginTop markerOffset maxHeight '+
  'maxWidth minHeight minWidth opacity outlineColor outlineOffset ' +
  'outlineWidth paddingBottom paddingLeft paddingRight paddingTop ' +
  'right textIndent top width wordSpacing zIndex');

Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;

String.__parseStyleElement = document.createElement('div');
String.prototype.parseStyle = function(){
  var style, styleRules = $H();
  if (Prototype.Browser.WebKit)
    style = new Element('div',{style:this}).style;
  else {
    String.__parseStyleElement.innerHTML = '<div style="' + this + '"></div>';
    style = String.__parseStyleElement.childNodes[0].style;
  }

  Element.CSS_PROPERTIES.each(function(property){
    if (style[property]) styleRules.set(property, style[property]);
  });

  if (Prototype.Browser.IE && this.include('opacity'))
    styleRules.set('opacity', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);

  return styleRules;
};

if (document.defaultView && document.defaultView.getComputedStyle) {
  Element.getStyles = function(element) {
    var css = document.defaultView.getComputedStyle($(element), null);
    return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {
      styles[property] = css[property];
      return styles;
    });
  };
} else {
  Element.getStyles = function(element) {
    element = $(element);
    var css = element.currentStyle, styles;
    styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {
      results[property] = css[property];
      return results;
    });
    if (!styles.opacity) styles.opacity = element.getOpacity();
    return styles;
  };
}

Effect.Methods = {
  morph: function(element, style) {
    element = $(element);
    new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));
    return element;
  },
  visualEffect: function(element, effect, options) {
    element = $(element);
    var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);
    new Effect[klass](element, options);
    return element;
  },
  highlight: function(element, options) {
    element = $(element);
    new Effect.Highlight(element, options);
    return element;
  }
};

$w('fade appear grow shrink fold blindUp blindDown slideUp slideDown '+
  'pulsate shake puff squish switchOff dropOut').each(
  function(effect) {
    Effect.Methods[effect] = function(element, options){
      element = $(element);
      Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);
      return element;
    };
  }
);

$w('getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles').each(
  function(f) { Effect.Methods[f] = Element[f]; }
);

Element.addMethods(Effect.Methods);
// script.aculo.us builder.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

var Builder = {
  NODEMAP: {
    AREA: 'map',
    CAPTION: 'table',
    COL: 'table',
    COLGROUP: 'table',
    LEGEND: 'fieldset',
    OPTGROUP: 'select',
    OPTION: 'select',
    PARAM: 'object',
    TBODY: 'table',
    TD: 'table',
    TFOOT: 'table',
    TH: 'table',
    THEAD: 'table',
    TR: 'table'
  },
  // note: For Firefox < 1.5, OPTION and OPTGROUP tags are currently broken,
  //       due to a Firefox bug
  node: function(elementName) {
    elementName = elementName.toUpperCase();

    // try innerHTML approach
    var parentTag = this.NODEMAP[elementName] || 'div';
    var parentElement = document.createElement(parentTag);
    try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
      parentElement.innerHTML = "<" + elementName + "></" + elementName + ">";
    } catch(e) {}
    var element = parentElement.firstChild || null;

    // see if browser added wrapping tags
    if(element && (element.tagName.toUpperCase() != elementName))
      element = element.getElementsByTagName(elementName)[0];

    // fallback to createElement approach
    if(!element) element = document.createElement(elementName);

    // abort if nothing could be created
    if(!element) return;

    // attributes (or text)
    if(arguments[1])
      if(this._isStringOrNumber(arguments[1]) ||
        (arguments[1] instanceof Array) ||
        arguments[1].tagName) {
          this._children(element, arguments[1]);
        } else {
          var attrs = this._attributes(arguments[1]);
          if(attrs.length) {
            try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707
              parentElement.innerHTML = "<" +elementName + " " +
                attrs + "></" + elementName + ">";
            } catch(e) {}
            element = parentElement.firstChild || null;
            // workaround firefox 1.0.X bug
            if(!element) {
              element = document.createElement(elementName);
              for(attr in arguments[1])
                element[attr == 'class' ? 'className' : attr] = arguments[1][attr];
            }
            if(element.tagName.toUpperCase() != elementName)
              element = parentElement.getElementsByTagName(elementName)[0];
          }
        }

    // text, or array of children
    if(arguments[2])
      this._children(element, arguments[2]);

     return $(element);
  },
  _text: function(text) {
     return document.createTextNode(text);
  },

  ATTR_MAP: {
    'className': 'class',
    'htmlFor': 'for'
  },

  _attributes: function(attributes) {
    var attrs = [];
    for(attribute in attributes)
      attrs.push((attribute in this.ATTR_MAP ? this.ATTR_MAP[attribute] : attribute) +
          '="' + attributes[attribute].toString().escapeHTML().gsub(/"/,'&quot;') + '"');
    return attrs.join(" ");
  },
  _children: function(element, children) {
    if(children.tagName) {
      element.appendChild(children);
      return;
    }
    if(typeof children=='object') { // array can hold nodes and text
      children.flatten().each( function(e) {
        if(typeof e=='object')
          element.appendChild(e);
        else
          if(Builder._isStringOrNumber(e))
            element.appendChild(Builder._text(e));
      });
    } else
      if(Builder._isStringOrNumber(children))
        element.appendChild(Builder._text(children));
  },
  _isStringOrNumber: function(param) {
    return(typeof param=='string' || typeof param=='number');
  },
  build: function(html) {
    var element = this.node('div');
    $(element).update(html.strip());
    return element.down();
  },
  dump: function(scope) {
    if(typeof scope != 'object' && typeof scope != 'function') scope = window; //global scope

    var tags = ("A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY " +
      "BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET " +
      "FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX "+
      "KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P "+
      "PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD "+
      "TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR").split(/\s+/);

    tags.each( function(tag){
      scope[tag] = function() {
        return Builder.node.apply(Builder, [tag].concat($A(arguments)));
      };
    });
  }
};
// script.aculo.us dragdrop.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

if(Object.isUndefined(Effect))
  throw("dragdrop.js requires including script.aculo.us' effects.js library");

var Droppables = {
  drops: [],

  remove: function(element) {
    this.drops = this.drops.reject(function(d) { return d.element==$(element) });
  },

  add: function(element) {
    element = $(element);
    var options = Object.extend({
      greedy:     true,
      hoverclass: null,
      tree:       false
    }, arguments[1] || { });

    // cache containers
    if(options.containment) {
      options._containers = [];
      var containment = options.containment;
      if(Object.isArray(containment)) {
        containment.each( function(c) { options._containers.push($(c)) });
      } else {
        options._containers.push($(containment));
      }
    }

    if(options.accept) options.accept = [options.accept].flatten();

    Element.makePositioned(element); // fix IE
    options.element = element;

    this.drops.push(options);
  },

  findDeepestChild: function(drops) {
    deepest = drops[0];

    for (i = 1; i < drops.length; ++i)
      if (Element.isParent(drops[i].element, deepest.element))
        deepest = drops[i];

    return deepest;
  },

  isContained: function(element, drop) {
    var containmentNode;
    if(drop.tree) {
      containmentNode = element.treeNode;
    } else {
      containmentNode = element.parentNode;
    }
    return drop._containers.detect(function(c) { return containmentNode == c });
  },

  isAffected: function(point, element, drop) {
    return (
      (drop.element!=element) &&
      ((!drop._containers) ||
        this.isContained(element, drop)) &&
      ((!drop.accept) ||
        (Element.classNames(element).detect(
          function(v) { return drop.accept.include(v) } ) )) &&
      Position.within(drop.element, point[0], point[1]) );
  },

  deactivate: function(drop) {
    if(drop.hoverclass)
      Element.removeClassName(drop.element, drop.hoverclass);
    this.last_active = null;
  },

  activate: function(drop) {
    if(drop.hoverclass)
      Element.addClassName(drop.element, drop.hoverclass);
    this.last_active = drop;
  },

  show: function(point, element) {
    if(!this.drops.length) return;
    var drop, affected = [];

    this.drops.each( function(drop) {
      if(Droppables.isAffected(point, element, drop))
        affected.push(drop);
    });

    if(affected.length>0)
      drop = Droppables.findDeepestChild(affected);

    if(this.last_active && this.last_active != drop) this.deactivate(this.last_active);
    if (drop) {
      Position.within(drop.element, point[0], point[1]);
      if(drop.onHover)
        drop.onHover(element, drop.element, Position.overlap(drop.overlap, drop.element));

      if (drop != this.last_active) Droppables.activate(drop);
    }
  },

  fire: function(event, element) {
    if(!this.last_active) return;
    Position.prepare();

    if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active))
      if (this.last_active.onDrop) {
        this.last_active.onDrop(element, this.last_active.element, event);
        return true;
      }
  },

  reset: function() {
    if(this.last_active)
      this.deactivate(this.last_active);
  }
};

var Draggables = {
  drags: [],
  observers: [],

  register: function(draggable) {
    if(this.drags.length == 0) {
      this.eventMouseUp   = this.endDrag.bindAsEventListener(this);
      this.eventMouseMove = this.updateDrag.bindAsEventListener(this);
      this.eventKeypress  = this.keyPress.bindAsEventListener(this);

      Event.observe(document, "mouseup", this.eventMouseUp);
      Event.observe(document, "mousemove", this.eventMouseMove);
      Event.observe(document, "keypress", this.eventKeypress);
    }
    this.drags.push(draggable);
  },

  unregister: function(draggable) {
    this.drags = this.drags.reject(function(d) { return d==draggable });
    if(this.drags.length == 0) {
      Event.stopObserving(document, "mouseup", this.eventMouseUp);
      Event.stopObserving(document, "mousemove", this.eventMouseMove);
      Event.stopObserving(document, "keypress", this.eventKeypress);
    }
  },

  activate: function(draggable) {
    if(draggable.options.delay) {
      this._timeout = setTimeout(function() {
        Draggables._timeout = null;
        window.focus();
        Draggables.activeDraggable = draggable;
      }.bind(this), draggable.options.delay);
    } else {
      window.focus(); // allows keypress events if window isn't currently focused, fails for Safari
      this.activeDraggable = draggable;
    }
  },

  deactivate: function() {
    this.activeDraggable = null;
  },

  updateDrag: function(event) {
    if(!this.activeDraggable) return;
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    // Mozilla-based browsers fire successive mousemove events with
    // the same coordinates, prevent needless redrawing (moz bug?)
    if(this._lastPointer && (this._lastPointer.inspect() == pointer.inspect())) return;
    this._lastPointer = pointer;

    this.activeDraggable.updateDrag(event, pointer);
  },

  endDrag: function(event) {
    if(this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    if(!this.activeDraggable) return;
    this._lastPointer = null;
    this.activeDraggable.endDrag(event);
    this.activeDraggable = null;
  },

  keyPress: function(event) {
    if(this.activeDraggable)
      this.activeDraggable.keyPress(event);
  },

  addObserver: function(observer) {
    this.observers.push(observer);
    this._cacheObserverCallbacks();
  },

  removeObserver: function(element) {  // element instead of observer fixes mem leaks
    this.observers = this.observers.reject( function(o) { return o.element==element });
    this._cacheObserverCallbacks();
  },

  notify: function(eventName, draggable, event) {  // 'onStart', 'onEnd', 'onDrag'
    if(this[eventName+'Count'] > 0)
      this.observers.each( function(o) {
        if(o[eventName]) o[eventName](eventName, draggable, event);
      });
    if(draggable.options[eventName]) draggable.options[eventName](draggable, event);
  },

  _cacheObserverCallbacks: function() {
    ['onStart','onEnd','onDrag'].each( function(eventName) {
      Draggables[eventName+'Count'] = Draggables.observers.select(
        function(o) { return o[eventName]; }
      ).length;
    });
  }
};

/*--------------------------------------------------------------------------*/

var Draggable = Class.create({
  initialize: function(element) {
    var defaults = {
      handle: false,
      reverteffect: function(element, top_offset, left_offset) {
        var dur = Math.sqrt(Math.abs(top_offset^2)+Math.abs(left_offset^2))*0.02;
        new Effect.Move(element, { x: -left_offset, y: -top_offset, duration: dur,
          queue: {scope:'_draggable', position:'end'}
        });
      },
      endeffect: function(element) {
        var toOpacity = Object.isNumber(element._opacity) ? element._opacity : 1.0;
        new Effect.Opacity(element, {duration:0.2, from:0.7, to:toOpacity,
          queue: {scope:'_draggable', position:'end'},
          afterFinish: function(){
            Draggable._dragging[element] = false
          }
        });
      },
      zindex: 1000,
      revert: false,
      quiet: false,
      scroll: false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      snap: false,  // false, or xy or [x,y] or function(x,y){ return [x,y] }
      delay: 0
    };

    if(!arguments[1] || Object.isUndefined(arguments[1].endeffect))
      Object.extend(defaults, {
        starteffect: function(element) {
          element._opacity = Element.getOpacity(element);
          Draggable._dragging[element] = true;
          new Effect.Opacity(element, {duration:0.2, from:element._opacity, to:0.7});
        }
      });

    var options = Object.extend(defaults, arguments[1] || { });

    this.element = $(element);

    if(options.handle && Object.isString(options.handle))
      this.handle = this.element.down('.'+options.handle, 0);

    if(!this.handle) this.handle = $(options.handle);
    if(!this.handle) this.handle = this.element;

    if(options.scroll && !options.scroll.scrollTo && !options.scroll.outerHTML) {
      options.scroll = $(options.scroll);
      this._isScrollChild = Element.childOf(this.element, options.scroll);
    }

    Element.makePositioned(this.element); // fix IE

    this.options  = options;
    this.dragging = false;

    this.eventMouseDown = this.initDrag.bindAsEventListener(this);
    Event.observe(this.handle, "mousedown", this.eventMouseDown);

    Draggables.register(this);
  },

  destroy: function() {
    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
    Draggables.unregister(this);
  },

  currentDelta: function() {
    return([
      parseInt(Element.getStyle(this.element,'left') || '0'),
      parseInt(Element.getStyle(this.element,'top') || '0')]);
  },

  initDrag: function(event) {
    if(!Object.isUndefined(Draggable._dragging[this.element]) &&
      Draggable._dragging[this.element]) return;
    if(Event.isLeftClick(event)) {
      // abort on form elements, fixes a Firefox issue
      var src = Event.element(event);
      if((tag_name = src.tagName.toUpperCase()) && (
        tag_name=='INPUT' ||
        tag_name=='SELECT' ||
        tag_name=='OPTION' ||
        tag_name=='BUTTON' ||
        tag_name=='TEXTAREA')) return;

      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      var pos     = this.element.cumulativeOffset();
      this.offset = [0,1].map( function(i) { return (pointer[i] - pos[i]) });

      Draggables.activate(this);
      Event.stop(event);
    }
  },

  startDrag: function(event) {
    this.dragging = true;
    if(!this.delta)
      this.delta = this.currentDelta();

    if(this.options.zindex) {
      this.originalZ = parseInt(Element.getStyle(this.element,'z-index') || 0);
      this.element.style.zIndex = this.options.zindex;
    }

    if(this.options.ghosting) {
      this._clone = this.element.cloneNode(true);
      this._originallyAbsolute = (this.element.getStyle('position') == 'absolute');
      if (!this._originallyAbsolute)
        Position.absolutize(this.element);
      this.element.parentNode.insertBefore(this._clone, this.element);
    }

    if(this.options.scroll) {
      if (this.options.scroll == window) {
        var where = this._getWindowScroll(this.options.scroll);
        this.originalScrollLeft = where.left;
        this.originalScrollTop = where.top;
      } else {
        this.originalScrollLeft = this.options.scroll.scrollLeft;
        this.originalScrollTop = this.options.scroll.scrollTop;
      }
    }

    Draggables.notify('onStart', this, event);

    if(this.options.starteffect) this.options.starteffect(this.element);
  },

  updateDrag: function(event, pointer) {
    if(!this.dragging) this.startDrag(event);

    if(!this.options.quiet){
      Position.prepare();
      Droppables.show(pointer, this.element);
    }

    Draggables.notify('onDrag', this, event);

    this.draw(pointer);
    if(this.options.change) this.options.change(this);

    if(this.options.scroll) {
      this.stopScrolling();

      var p;
      if (this.options.scroll == window) {
        var winScroll = this._getWindowScroll(this.options.scroll);
        p = [ winScroll.left, winScroll.top, winScroll.left+winScroll.width, winScroll.top+winScroll.height ];
      } else {
        p = Position.page(this.options.scroll).toArray();
        p[0] += this.options.scroll.scrollLeft + Position.deltaX;
        p[1] += this.options.scroll.scrollTop + Position.deltaY;
        p.push(p[0]+this.options.scroll.offsetWidth);
        p.push(p[1]+this.options.scroll.offsetHeight);
      }
      var speed = [0,0];
      if(pointer[0] < (p[0]+this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[0]+this.options.scrollSensitivity);
      if(pointer[1] < (p[1]+this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[1]+this.options.scrollSensitivity);
      if(pointer[0] > (p[2]-this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[2]-this.options.scrollSensitivity);
      if(pointer[1] > (p[3]-this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[3]-this.options.scrollSensitivity);
      this.startScrolling(speed);
    }

    // fix AppleWebKit rendering
    if(Prototype.Browser.WebKit) window.scrollBy(0,0);

    Event.stop(event);
  },

  finishDrag: function(event, success) {
    this.dragging = false;

    if(this.options.quiet){
      Position.prepare();
      var pointer = [Event.pointerX(event), Event.pointerY(event)];
      Droppables.show(pointer, this.element);
    }

    if(this.options.ghosting) {
      if (!this._originallyAbsolute)
        Position.relativize(this.element);
      delete this._originallyAbsolute;
      Element.remove(this._clone);
      this._clone = null;
    }

    var dropped = false;
    if(success) {
      dropped = Droppables.fire(event, this.element);
      if (!dropped) dropped = false;
    }
    if(dropped && this.options.onDropped) this.options.onDropped(this.element);
    Draggables.notify('onEnd', this, event);

    var revert = this.options.revert;
    if(revert && Object.isFunction(revert)) revert = revert(this.element);

    var d = this.currentDelta();
    if(revert && this.options.reverteffect) {
      if (dropped == 0 || revert != 'failure')
        this.options.reverteffect(this.element,
          d[1]-this.delta[1], d[0]-this.delta[0]);
    } else {
      this.delta = d;
    }

    if(this.options.zindex)
      this.element.style.zIndex = this.originalZ;

    if(this.options.endeffect)
      this.options.endeffect(this.element);

    Draggables.deactivate(this);
    Droppables.reset();
  },

  keyPress: function(event) {
    if(event.keyCode!=Event.KEY_ESC) return;
    this.finishDrag(event, false);
    Event.stop(event);
  },

  endDrag: function(event) {
    if(!this.dragging) return;
    this.stopScrolling();
    this.finishDrag(event, true);
    Event.stop(event);
  },

  draw: function(point) {
    var pos = this.element.cumulativeOffset();
    if(this.options.ghosting) {
      var r   = Position.realOffset(this.element);
      pos[0] += r[0] - Position.deltaX; pos[1] += r[1] - Position.deltaY;
    }

    var d = this.currentDelta();
    pos[0] -= d[0]; pos[1] -= d[1];

    if(this.options.scroll && (this.options.scroll != window && this._isScrollChild)) {
      pos[0] -= this.options.scroll.scrollLeft-this.originalScrollLeft;
      pos[1] -= this.options.scroll.scrollTop-this.originalScrollTop;
    }

    var p = [0,1].map(function(i){
      return (point[i]-pos[i]-this.offset[i])
    }.bind(this));

    if(this.options.snap) {
      if(Object.isFunction(this.options.snap)) {
        p = this.options.snap(p[0],p[1],this);
      } else {
      if(Object.isArray(this.options.snap)) {
        p = p.map( function(v, i) {
          return (v/this.options.snap[i]).round()*this.options.snap[i] }.bind(this));
      } else {
        p = p.map( function(v) {
          return (v/this.options.snap).round()*this.options.snap }.bind(this));
      }
    }}

    var style = this.element.style;
    if((!this.options.constraint) || (this.options.constraint=='horizontal'))
      style.left = p[0] + "px";
    if((!this.options.constraint) || (this.options.constraint=='vertical'))
      style.top  = p[1] + "px";

    if(style.visibility=="hidden") style.visibility = ""; // fix gecko rendering
  },

  stopScrolling: function() {
    if(this.scrollInterval) {
      clearInterval(this.scrollInterval);
      this.scrollInterval = null;
      Draggables._lastScrollPointer = null;
    }
  },

  startScrolling: function(speed) {
    if(!(speed[0] || speed[1])) return;
    this.scrollSpeed = [speed[0]*this.options.scrollSpeed,speed[1]*this.options.scrollSpeed];
    this.lastScrolled = new Date();
    this.scrollInterval = setInterval(this.scroll.bind(this), 10);
  },

  scroll: function() {
    var current = new Date();
    var delta = current - this.lastScrolled;
    this.lastScrolled = current;
    if(this.options.scroll == window) {
      var winScroll = this._getWindowScroll(this.options.scroll);
      if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
        var d = delta / 1000;
        this.options.scroll.scrollTo( winScroll.left + d*this.scrollSpeed[0], winScroll.top + d*this.scrollSpeed[1] );
      }
    } else {
      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;
      this.options.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;
    }

    Position.prepare();
    Droppables.show(Draggables._lastPointer, this.element);
    Draggables.notify('onDrag', this);
    if (this._isScrollChild) {
      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;
      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;
      if (Draggables._lastScrollPointer[0] < 0)
        Draggables._lastScrollPointer[0] = 0;
      if (Draggables._lastScrollPointer[1] < 0)
        Draggables._lastScrollPointer[1] = 0;
      this.draw(Draggables._lastScrollPointer);
    }

    if(this.options.change) this.options.change(this);
  },

  _getWindowScroll: function(w) {
    var T, L, W, H;
    if (w.document.documentElement && documentElement.scrollTop) {
      T = w.document.documentElement.scrollTop;
      L = w.document.documentElement.scrollLeft;
    } else if (w.document.body) {
      T = w.document.body.scrollTop;
      L = w.document.body.scrollLeft;
    }
    if (w.innerWidth) {
      W = w.innerWidth;
      H = w.innerHeight;
    } else if (w.document.documentElement && documentElement.clientWidth) {
      W = w.document.documentElement.clientWidth;
      H = w.document.documentElement.clientHeight;
    } else {
      W = w.document.body.offsetWidth;
      H = w.document.body.offsetHeight;
    }
    return { top: T, left: L, width: W, height: H };
  }
});

Draggable._dragging = { };

/*--------------------------------------------------------------------------*/

var SortableObserver = Class.create({
  initialize: function(element, observer) {
    this.element   = $(element);
    this.observer  = observer;
    this.lastValue = Sortable.serialize(this.element);
  },

  onStart: function() {
    this.lastValue = Sortable.serialize(this.element);
  },

  onEnd: function() {
    Sortable.unmark();
    if(this.lastValue != Sortable.serialize(this.element))
      this.observer(this.element)
  }
});

var Sortable = {
  SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,

  sortables: { },

  _findRootElement: function(element) {
    while (element.tagName.toUpperCase() != "BODY") {
      if(element.id && Sortable.sortables[element.id]) return element;
      element = element.parentNode;
    }
  },

  options: function(element) {
    element = Sortable._findRootElement($(element));
    if(!element) return;
    return Sortable.sortables[element.id];
  },

  destroy: function(element){
    element = $(element);
    var s = Sortable.sortables[element.id];

    if(s) {
      Draggables.removeObserver(s.element);
      s.droppables.each(function(d){ Droppables.remove(d) });
      s.draggables.invoke('destroy');

      delete Sortable.sortables[s.element.id];
    }
  },

  create: function(element) {
    element = $(element);
    var options = Object.extend({
      element:     element,
      tag:         'li',       // assumes li children, override with tag: 'tagname'
      dropOnEmpty: false,
      tree:        false,
      treeTag:     'ul',
      overlap:     'vertical', // one of 'vertical', 'horizontal'
      constraint:  'vertical', // one of 'vertical', 'horizontal', false
      containment: element,    // also takes array of elements (or id's); or false
      handle:      false,      // or a CSS class
      only:        false,
      delay:       0,
      hoverclass:  null,
      ghosting:    false,
      quiet:       false,
      scroll:      false,
      scrollSensitivity: 20,
      scrollSpeed: 15,
      format:      this.SERIALIZE_RULE,

      // these take arrays of elements or ids and can be
      // used for better initialization performance
      elements:    false,
      handles:     false,

      onChange:    Prototype.emptyFunction,
      onUpdate:    Prototype.emptyFunction
    }, arguments[1] || { });

    // clear any old sortable with same element
    this.destroy(element);

    // build options for the draggables
    var options_for_draggable = {
      revert:      true,
      quiet:       options.quiet,
      scroll:      options.scroll,
      scrollSpeed: options.scrollSpeed,
      scrollSensitivity: options.scrollSensitivity,
      delay:       options.delay,
      ghosting:    options.ghosting,
      constraint:  options.constraint,
      handle:      options.handle };

    if(options.starteffect)
      options_for_draggable.starteffect = options.starteffect;

    if(options.reverteffect)
      options_for_draggable.reverteffect = options.reverteffect;
    else
      if(options.ghosting) options_for_draggable.reverteffect = function(element) {
        element.style.top  = 0;
        element.style.left = 0;
      };

    if(options.endeffect)
      options_for_draggable.endeffect = options.endeffect;

    if(options.zindex)
      options_for_draggable.zindex = options.zindex;

    // build options for the droppables
    var options_for_droppable = {
      overlap:     options.overlap,
      containment: options.containment,
      tree:        options.tree,
      hoverclass:  options.hoverclass,
      onHover:     Sortable.onHover
    };

    var options_for_tree = {
      onHover:      Sortable.onEmptyHover,
      overlap:      options.overlap,
      containment:  options.containment,
      hoverclass:   options.hoverclass
    };

    // fix for gecko engine
    Element.cleanWhitespace(element);

    options.draggables = [];
    options.droppables = [];

    // drop on empty handling
    if(options.dropOnEmpty || options.tree) {
      Droppables.add(element, options_for_tree);
      options.droppables.push(element);
    }

    (options.elements || this.findElements(element, options) || []).each( function(e,i) {
      var handle = options.handles ? $(options.handles[i]) :
        (options.handle ? $(e).select('.' + options.handle)[0] : e);
      options.draggables.push(
        new Draggable(e, Object.extend(options_for_draggable, { handle: handle })));
      Droppables.add(e, options_for_droppable);
      if(options.tree) e.treeNode = element;
      options.droppables.push(e);
    });

    if(options.tree) {
      (Sortable.findTreeElements(element, options) || []).each( function(e) {
        Droppables.add(e, options_for_tree);
        e.treeNode = element;
        options.droppables.push(e);
      });
    }

    // keep reference
    this.sortables[element.identify()] = options;

    // for onupdate
    Draggables.addObserver(new SortableObserver(element, options.onUpdate));

  },

  // return all suitable-for-sortable elements in a guaranteed order
  findElements: function(element, options) {
    return Element.findChildren(
      element, options.only, options.tree ? true : false, options.tag);
  },

  findTreeElements: function(element, options) {
    return Element.findChildren(
      element, options.only, options.tree ? true : false, options.treeTag);
  },

  onHover: function(element, dropon, overlap) {
    if(Element.isParent(dropon, element)) return;

    if(overlap > .33 && overlap < .66 && Sortable.options(dropon).tree) {
      return;
    } else if(overlap>0.5) {
      Sortable.mark(dropon, 'before');
      if(dropon.previousSibling != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden"; // fix gecko rendering
        dropon.parentNode.insertBefore(element, dropon);
        if(dropon.parentNode!=oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    } else {
      Sortable.mark(dropon, 'after');
      var nextElement = dropon.nextSibling || null;
      if(nextElement != element) {
        var oldParentNode = element.parentNode;
        element.style.visibility = "hidden"; // fix gecko rendering
        dropon.parentNode.insertBefore(element, nextElement);
        if(dropon.parentNode!=oldParentNode)
          Sortable.options(oldParentNode).onChange(element);
        Sortable.options(dropon.parentNode).onChange(element);
      }
    }
  },

  onEmptyHover: function(element, dropon, overlap) {
    var oldParentNode = element.parentNode;
    var droponOptions = Sortable.options(dropon);

    if(!Element.isParent(dropon, element)) {
      var index;

      var children = Sortable.findElements(dropon, {tag: droponOptions.tag, only: droponOptions.only});
      var child = null;

      if(children) {
        var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1.0 - overlap);

        for (index = 0; index < children.length; index += 1) {
          if (offset - Element.offsetSize (children[index], droponOptions.overlap) >= 0) {
            offset -= Element.offsetSize (children[index], droponOptions.overlap);
          } else if (offset - (Element.offsetSize (children[index], droponOptions.overlap) / 2) >= 0) {
            child = index + 1 < children.length ? children[index + 1] : null;
            break;
          } else {
            child = children[index];
            break;
          }
        }
      }

      dropon.insertBefore(element, child);

      Sortable.options(oldParentNode).onChange(element);
      droponOptions.onChange(element);
    }
  },

  unmark: function() {
    if(Sortable._marker) Sortable._marker.hide();
  },

  mark: function(dropon, position) {
    // mark on ghosting only
    var sortable = Sortable.options(dropon.parentNode);
    if(sortable && !sortable.ghosting) return;

    if(!Sortable._marker) {
      Sortable._marker =
        ($('dropmarker') || Element.extend(document.createElement('DIV'))).
          hide().addClassName('dropmarker').setStyle({position:'absolute'});
      document.getElementsByTagName("body").item(0).appendChild(Sortable._marker);
    }
    var offsets = dropon.cumulativeOffset();
    Sortable._marker.setStyle({left: offsets[0]+'px', top: offsets[1] + 'px'});

    if(position=='after')
      if(sortable.overlap == 'horizontal')
        Sortable._marker.setStyle({left: (offsets[0]+dropon.clientWidth) + 'px'});
      else
        Sortable._marker.setStyle({top: (offsets[1]+dropon.clientHeight) + 'px'});

    Sortable._marker.show();
  },

  _tree: function(element, options, parent) {
    var children = Sortable.findElements(element, options) || [];

    for (var i = 0; i < children.length; ++i) {
      var match = children[i].id.match(options.format);

      if (!match) continue;

      var child = {
        id: encodeURIComponent(match ? match[1] : null),
        element: element,
        parent: parent,
        children: [],
        position: parent.children.length,
        container: $(children[i]).down(options.treeTag)
      };

      /* Get the element containing the children and recurse over it */
      if (child.container)
        this._tree(child.container, options, child);

      parent.children.push (child);
    }

    return parent;
  },

  tree: function(element) {
    element = $(element);
    var sortableOptions = this.options(element);
    var options = Object.extend({
      tag: sortableOptions.tag,
      treeTag: sortableOptions.treeTag,
      only: sortableOptions.only,
      name: element.id,
      format: sortableOptions.format
    }, arguments[1] || { });

    var root = {
      id: null,
      parent: null,
      children: [],
      container: element,
      position: 0
    };

    return Sortable._tree(element, options, root);
  },

  /* Construct a [i] index for a particular node */
  _constructIndex: function(node) {
    var index = '';
    do {
      if (node.id) index = '[' + node.position + ']' + index;
    } while ((node = node.parent) != null);
    return index;
  },

  sequence: function(element) {
    element = $(element);
    var options = Object.extend(this.options(element), arguments[1] || { });

    return $(this.findElements(element, options) || []).map( function(item) {
      return item.id.match(options.format) ? item.id.match(options.format)[1] : '';
    });
  },

  setSequence: function(element, new_sequence) {
    element = $(element);
    var options = Object.extend(this.options(element), arguments[2] || { });

    var nodeMap = { };
    this.findElements(element, options).each( function(n) {
        if (n.id.match(options.format))
            nodeMap[n.id.match(options.format)[1]] = [n, n.parentNode];
        n.parentNode.removeChild(n);
    });

    new_sequence.each(function(ident) {
      var n = nodeMap[ident];
      if (n) {
        n[1].appendChild(n[0]);
        delete nodeMap[ident];
      }
    });
  },

  serialize: function(element) {
    element = $(element);
    var options = Object.extend(Sortable.options(element), arguments[1] || { });
    var name = encodeURIComponent(
      (arguments[1] && arguments[1].name) ? arguments[1].name : element.id);

    if (options.tree) {
      return Sortable.tree(element, arguments[1]).children.map( function (item) {
        return [name + Sortable._constructIndex(item) + "[id]=" +
                encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));
      }).flatten().join('&');
    } else {
      return Sortable.sequence(element, arguments[1]).map( function(item) {
        return name + "[]=" + encodeURIComponent(item);
      }).join('&');
    }
  }
};

// Returns true if child is contained within element
Element.isParent = function(child, element) {
  if (!child.parentNode || child == element) return false;
  if (child.parentNode == element) return true;
  return Element.isParent(child.parentNode, element);
};

Element.findChildren = function(element, only, recursive, tagName) {
  if(!element.hasChildNodes()) return null;
  tagName = tagName.toUpperCase();
  if(only) only = [only].flatten();
  var elements = [];
  $A(element.childNodes).each( function(e) {
    if(e.tagName && e.tagName.toUpperCase()==tagName &&
      (!only || (Element.classNames(e).detect(function(v) { return only.include(v) }))))
        elements.push(e);
    if(recursive) {
      var grandchildren = Element.findChildren(e, only, recursive, tagName);
      if(grandchildren) elements.push(grandchildren);
    }
  });

  return (elements.length>0 ? elements.flatten() : []);
};

Element.offsetSize = function (element, type) {
  return element['offset' + ((type=='vertical' || type=='height') ? 'Height' : 'Width')];
};
// script.aculo.us controls.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
//           (c) 2005-2010 Ivan Krstic (http://blogs.law.harvard.edu/ivan)
//           (c) 2005-2010 Jon Tirsen (http://www.tirsen.com)
// Contributors:
//  Richard Livsey
//  Rahul Bhargava
//  Rob Wills
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

// Autocompleter.Base handles all the autocompletion functionality
// that's independent of the data source for autocompletion. This
// includes drawing the autocompletion menu, observing keyboard
// and mouse events, and similar.
//
// Specific autocompleters need to provide, at the very least,
// a getUpdatedChoices function that will be invoked every time
// the text inside the monitored textbox changes. This method
// should get the text for which to provide autocompletion by
// invoking this.getToken(), NOT by directly accessing
// this.element.value. This is to allow incremental tokenized
// autocompletion. Specific auto-completion logic (AJAX, etc)
// belongs in getUpdatedChoices.
//
// Tokenized incremental autocompletion is enabled automatically
// when an autocompleter is instantiated with the 'tokens' option
// in the options parameter, e.g.:
// new Ajax.Autocompleter('id','upd', '/url/', { tokens: ',' });
// will incrementally autocomplete with a comma as the token.
// Additionally, ',' in the above example can be replaced with
// a token array, e.g. { tokens: [',', '\n'] } which
// enables autocompletion on multiple tokens. This is most
// useful when one of the tokens is \n (a newline), as it
// allows smart autocompletion after linebreaks.

if(typeof Effect == 'undefined')
  throw("controls.js requires including script.aculo.us' effects.js library");

var Autocompleter = { };
Autocompleter.Base = Class.create({
  baseInitialize: function(element, update, options) {
    element          = $(element);
    this.element     = element;
    this.update      = $(update);
    this.hasFocus    = false;
    this.changed     = false;
    this.active      = false;
    this.index       = 0;
    this.entryCount  = 0;
    this.oldElementValue = this.element.value;

    if(this.setOptions)
      this.setOptions(options);
    else
      this.options = options || { };

    this.options.paramName    = this.options.paramName || this.element.name;
    this.options.tokens       = this.options.tokens || [];
    this.options.frequency    = this.options.frequency || 0.4;
    this.options.minChars     = this.options.minChars || 1;
    this.options.onShow       = this.options.onShow ||
      function(element, update){
        if(!update.style.position || update.style.position=='absolute') {
          update.style.position = 'absolute';
          Position.clone(element, update, {
            setHeight: false,
            offsetTop: element.offsetHeight
          });
        }
        Effect.Appear(update,{duration:0.15});
      };
    this.options.onHide = this.options.onHide ||
      function(element, update){ new Effect.Fade(update,{duration:0.15}) };

    if(typeof(this.options.tokens) == 'string')
      this.options.tokens = new Array(this.options.tokens);
    // Force carriage returns as token delimiters anyway
    if (!this.options.tokens.include('\n'))
      this.options.tokens.push('\n');

    this.observer = null;

    this.element.setAttribute('autocomplete','off');

    Element.hide(this.update);

    Event.observe(this.element, 'blur', this.onBlur.bindAsEventListener(this));
    Event.observe(this.element, 'keydown', this.onKeyPress.bindAsEventListener(this));
  },

  show: function() {
    if(Element.getStyle(this.update, 'display')=='none') this.options.onShow(this.element, this.update);
    if(!this.iefix &&
      (Prototype.Browser.IE) &&
      (Element.getStyle(this.update, 'position')=='absolute')) {
      new Insertion.After(this.update,
       '<iframe id="' + this.update.id + '_iefix" '+
       'style="display:none;position:absolute;filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0);" ' +
       'src="javascript:false;" frameborder="0" scrolling="no"></iframe>');
      this.iefix = $(this.update.id+'_iefix');
    }
    if(this.iefix) setTimeout(this.fixIEOverlapping.bind(this), 50);
  },

  fixIEOverlapping: function() {
    Position.clone(this.update, this.iefix, {setTop:(!this.update.style.height)});
    this.iefix.style.zIndex = 1;
    this.update.style.zIndex = 2;
    Element.show(this.iefix);
  },

  hide: function() {
    this.stopIndicator();
    if(Element.getStyle(this.update, 'display')!='none') this.options.onHide(this.element, this.update);
    if(this.iefix) Element.hide(this.iefix);
  },

  startIndicator: function() {
    if(this.options.indicator) Element.show(this.options.indicator);
  },

  stopIndicator: function() {
    if(this.options.indicator) Element.hide(this.options.indicator);
  },

  onKeyPress: function(event) {
    if(this.active)
      switch(event.keyCode) {
       case Event.KEY_TAB:
       case Event.KEY_RETURN:
         this.selectEntry();
         Event.stop(event);
       case Event.KEY_ESC:
         this.hide();
         this.active = false;
         Event.stop(event);
         return;
       case Event.KEY_LEFT:
       case Event.KEY_RIGHT:
         return;
       case Event.KEY_UP:
         this.markPrevious();
         this.render();
         Event.stop(event);
         return;
       case Event.KEY_DOWN:
         this.markNext();
         this.render();
         Event.stop(event);
         return;
      }
     else
       if(event.keyCode==Event.KEY_TAB || event.keyCode==Event.KEY_RETURN ||
         (Prototype.Browser.WebKit > 0 && event.keyCode == 0)) return;

    this.changed = true;
    this.hasFocus = true;

    if(this.observer) clearTimeout(this.observer);
      this.observer =
        setTimeout(this.onObserverEvent.bind(this), this.options.frequency*1000);
  },

  activate: function() {
    this.changed = false;
    this.hasFocus = true;
    this.getUpdatedChoices();
  },

  onHover: function(event) {
    var element = Event.findElement(event, 'LI');
    if(this.index != element.autocompleteIndex)
    {
        this.index = element.autocompleteIndex;
        this.render();
    }
    Event.stop(event);
  },

  onClick: function(event) {
    var element = Event.findElement(event, 'LI');
    this.index = element.autocompleteIndex;
    this.selectEntry();
    this.hide();
  },

  onBlur: function(event) {
    // needed to make click events working
    setTimeout(this.hide.bind(this), 250);
    this.hasFocus = false;
    this.active = false;
  },

  render: function() {
    if(this.entryCount > 0) {
      for (var i = 0; i < this.entryCount; i++)
        this.index==i ?
          Element.addClassName(this.getEntry(i),"selected") :
          Element.removeClassName(this.getEntry(i),"selected");
      if(this.hasFocus) {
        this.show();
        this.active = true;
      }
    } else {
      this.active = false;
      this.hide();
    }
  },

  markPrevious: function() {
    if(this.index > 0) this.index--;
      else this.index = this.entryCount-1;
    this.getEntry(this.index).scrollIntoView(true);
  },

  markNext: function() {
    if(this.index < this.entryCount-1) this.index++;
      else this.index = 0;
    this.getEntry(this.index).scrollIntoView(false);
  },

  getEntry: function(index) {
    return this.update.firstChild.childNodes[index];
  },

  getCurrentEntry: function() {
    return this.getEntry(this.index);
  },

  selectEntry: function() {
    this.active = false;
    this.updateElement(this.getCurrentEntry());
  },

  updateElement: function(selectedElement) {
    if (this.options.updateElement) {
      this.options.updateElement(selectedElement);
      return;
    }
    var value = '';
    if (this.options.select) {
      var nodes = $(selectedElement).select('.' + this.options.select) || [];
      if(nodes.length>0) value = Element.collectTextNodes(nodes[0], this.options.select);
    } else
      value = Element.collectTextNodesIgnoreClass(selectedElement, 'informal');

    var bounds = this.getTokenBounds();
    if (bounds[0] != -1) {
      var newValue = this.element.value.substr(0, bounds[0]);
      var whitespace = this.element.value.substr(bounds[0]).match(/^\s+/);
      if (whitespace)
        newValue += whitespace[0];
      this.element.value = newValue + value + this.element.value.substr(bounds[1]);
    } else {
      this.element.value = value;
    }
    this.oldElementValue = this.element.value;
    this.element.focus();

    if (this.options.afterUpdateElement)
      this.options.afterUpdateElement(this.element, selectedElement);
  },

  updateChoices: function(choices) {
    if(!this.changed && this.hasFocus) {
      this.update.innerHTML = choices;
      Element.cleanWhitespace(this.update);
      Element.cleanWhitespace(this.update.down());

      if(this.update.firstChild && this.update.down().childNodes) {
        this.entryCount =
          this.update.down().childNodes.length;
        for (var i = 0; i < this.entryCount; i++) {
          var entry = this.getEntry(i);
          entry.autocompleteIndex = i;
          this.addObservers(entry);
        }
      } else {
        this.entryCount = 0;
      }

      this.stopIndicator();
      this.index = 0;

      if(this.entryCount==1 && this.options.autoSelect) {
        this.selectEntry();
        this.hide();
      } else {
        this.render();
      }
    }
  },

  addObservers: function(element) {
    Event.observe(element, "mouseover", this.onHover.bindAsEventListener(this));
    Event.observe(element, "click", this.onClick.bindAsEventListener(this));
  },

  onObserverEvent: function() {
    this.changed = false;
    this.tokenBounds = null;
    if(this.getToken().length>=this.options.minChars) {
      this.getUpdatedChoices();
    } else {
      this.active = false;
      this.hide();
    }
    this.oldElementValue = this.element.value;
  },

  getToken: function() {
    var bounds = this.getTokenBounds();
    return this.element.value.substring(bounds[0], bounds[1]).strip();
  },

  getTokenBounds: function() {
    if (null != this.tokenBounds) return this.tokenBounds;
    var value = this.element.value;
    if (value.strip().empty()) return [-1, 0];
    var diff = arguments.callee.getFirstDifferencePos(value, this.oldElementValue);
    var offset = (diff == this.oldElementValue.length ? 1 : 0);
    var prevTokenPos = -1, nextTokenPos = value.length;
    var tp;
    for (var index = 0, l = this.options.tokens.length; index < l; ++index) {
      tp = value.lastIndexOf(this.options.tokens[index], diff + offset - 1);
      if (tp > prevTokenPos) prevTokenPos = tp;
      tp = value.indexOf(this.options.tokens[index], diff + offset);
      if (-1 != tp && tp < nextTokenPos) nextTokenPos = tp;
    }
    return (this.tokenBounds = [prevTokenPos + 1, nextTokenPos]);
  }
});

Autocompleter.Base.prototype.getTokenBounds.getFirstDifferencePos = function(newS, oldS) {
  var boundary = Math.min(newS.length, oldS.length);
  for (var index = 0; index < boundary; ++index)
    if (newS[index] != oldS[index])
      return index;
  return boundary;
};

Ajax.Autocompleter = Class.create(Autocompleter.Base, {
  initialize: function(element, update, url, options) {
    this.baseInitialize(element, update, options);
    this.options.asynchronous  = true;
    this.options.onComplete    = this.onComplete.bind(this);
    this.options.defaultParams = this.options.parameters || null;
    this.url                   = url;
  },

  getUpdatedChoices: function() {
    this.startIndicator();

    var entry = encodeURIComponent(this.options.paramName) + '=' +
      encodeURIComponent(this.getToken());

    this.options.parameters = this.options.callback ?
      this.options.callback(this.element, entry) : entry;

    if(this.options.defaultParams)
      this.options.parameters += '&' + this.options.defaultParams;

    new Ajax.Request(this.url, this.options);
  },

  onComplete: function(request) {
    this.updateChoices(request.responseText);
  }
});

// The local array autocompleter. Used when you'd prefer to
// inject an array of autocompletion options into the page, rather
// than sending out Ajax queries, which can be quite slow sometimes.
//
// The constructor takes four parameters. The first two are, as usual,
// the id of the monitored textbox, and id of the autocompletion menu.
// The third is the array you want to autocomplete from, and the fourth
// is the options block.
//
// Extra local autocompletion options:
// - choices - How many autocompletion choices to offer
//
// - partialSearch - If false, the autocompleter will match entered
//                    text only at the beginning of strings in the
//                    autocomplete array. Defaults to true, which will
//                    match text at the beginning of any *word* in the
//                    strings in the autocomplete array. If you want to
//                    search anywhere in the string, additionally set
//                    the option fullSearch to true (default: off).
//
// - fullSsearch - Search anywhere in autocomplete array strings.
//
// - partialChars - How many characters to enter before triggering
//                   a partial match (unlike minChars, which defines
//                   how many characters are required to do any match
//                   at all). Defaults to 2.
//
// - ignoreCase - Whether to ignore case when autocompleting.
//                 Defaults to true.
//
// It's possible to pass in a custom function as the 'selector'
// option, if you prefer to write your own autocompletion logic.
// In that case, the other options above will not apply unless
// you support them.

Autocompleter.Local = Class.create(Autocompleter.Base, {
  initialize: function(element, update, array, options) {
    this.baseInitialize(element, update, options);
    this.options.array = array;
  },

  getUpdatedChoices: function() {
    this.updateChoices(this.options.selector(this));
  },

  setOptions: function(options) {
    this.options = Object.extend({
      choices: 10,
      partialSearch: true,
      partialChars: 2,
      ignoreCase: true,
      fullSearch: false,
      selector: function(instance) {
        var ret       = []; // Beginning matches
        var partial   = []; // Inside matches
        var entry     = instance.getToken();
        var count     = 0;

        for (var i = 0; i < instance.options.array.length &&
          ret.length < instance.options.choices ; i++) {

          var elem = instance.options.array[i];
          var foundPos = instance.options.ignoreCase ?
            elem.toLowerCase().indexOf(entry.toLowerCase()) :
            elem.indexOf(entry);

          while (foundPos != -1) {
            if (foundPos == 0 && elem.length != entry.length) {
              ret.push("<li><strong>" + elem.substr(0, entry.length) + "</strong>" +
                elem.substr(entry.length) + "</li>");
              break;
            } else if (entry.length >= instance.options.partialChars &&
              instance.options.partialSearch && foundPos != -1) {
              if (instance.options.fullSearch || /\s/.test(elem.substr(foundPos-1,1))) {
                partial.push("<li>" + elem.substr(0, foundPos) + "<strong>" +
                  elem.substr(foundPos, entry.length) + "</strong>" + elem.substr(
                  foundPos + entry.length) + "</li>");
                break;
              }
            }

            foundPos = instance.options.ignoreCase ?
              elem.toLowerCase().indexOf(entry.toLowerCase(), foundPos + 1) :
              elem.indexOf(entry, foundPos + 1);

          }
        }
        if (partial.length)
          ret = ret.concat(partial.slice(0, instance.options.choices - ret.length));
        return "<ul>" + ret.join('') + "</ul>";
      }
    }, options || { });
  }
});

// AJAX in-place editor and collection editor
// Full rewrite by Christophe Porteneuve <tdd@tddsworld.com> (April 2007).

// Use this if you notice weird scrolling problems on some browsers,
// the DOM might be a bit confused when this gets called so do this
// waits 1 ms (with setTimeout) until it does the activation
Field.scrollFreeActivate = function(field) {
  setTimeout(function() {
    Field.activate(field);
  }, 1);
};

Ajax.InPlaceEditor = Class.create({
  initialize: function(element, url, options) {
    this.url = url;
    this.element = element = $(element);
    this.prepareOptions();
    this._controls = { };
    arguments.callee.dealWithDeprecatedOptions(options); // DEPRECATION LAYER!!!
    Object.extend(this.options, options || { });
    if (!this.options.formId && this.element.id) {
      this.options.formId = this.element.id + '-inplaceeditor';
      if ($(this.options.formId))
        this.options.formId = '';
    }
    if (this.options.externalControl)
      this.options.externalControl = $(this.options.externalControl);
    if (!this.options.externalControl)
      this.options.externalControlOnly = false;
    this._originalBackground = this.element.getStyle('background-color') || 'transparent';
    this.element.title = this.options.clickToEditText;
    this._boundCancelHandler = this.handleFormCancellation.bind(this);
    this._boundComplete = (this.options.onComplete || Prototype.emptyFunction).bind(this);
    this._boundFailureHandler = this.handleAJAXFailure.bind(this);
    this._boundSubmitHandler = this.handleFormSubmission.bind(this);
    this._boundWrapperHandler = this.wrapUp.bind(this);
    this.registerListeners();
  },
  checkForEscapeOrReturn: function(e) {
    if (!this._editing || e.ctrlKey || e.altKey || e.shiftKey) return;
    if (Event.KEY_ESC == e.keyCode)
      this.handleFormCancellation(e);
    else if (Event.KEY_RETURN == e.keyCode)
      this.handleFormSubmission(e);
  },
  createControl: function(mode, handler, extraClasses) {
    var control = this.options[mode + 'Control'];
    var text = this.options[mode + 'Text'];
    if ('button' == control) {
      var btn = document.createElement('input');
      btn.type = 'submit';
      btn.value = text;
      btn.className = 'editor_' + mode + '_button';
      if ('cancel' == mode)
        btn.onclick = this._boundCancelHandler;
      this._form.appendChild(btn);
      this._controls[mode] = btn;
    } else if ('link' == control) {
      var link = document.createElement('a');
      link.href = '#';
      link.appendChild(document.createTextNode(text));
      link.onclick = 'cancel' == mode ? this._boundCancelHandler : this._boundSubmitHandler;
      link.className = 'editor_' + mode + '_link';
      if (extraClasses)
        link.className += ' ' + extraClasses;
      this._form.appendChild(link);
      this._controls[mode] = link;
    }
  },
  createEditField: function() {
    var text = (this.options.loadTextURL ? this.options.loadingText : this.getText());
    var fld;
    if (1 >= this.options.rows && !/\r|\n/.test(this.getText())) {
      fld = document.createElement('input');
      fld.type = 'text';
      var size = this.options.size || this.options.cols || 0;
      if (0 < size) fld.size = size;
    } else {
      fld = document.createElement('textarea');
      fld.rows = (1 >= this.options.rows ? this.options.autoRows : this.options.rows);
      fld.cols = this.options.cols || 40;
    }
    fld.name = this.options.paramName;
    fld.value = text; // No HTML breaks conversion anymore
    fld.className = 'editor_field';
    if (this.options.submitOnBlur)
      fld.onblur = this._boundSubmitHandler;
    this._controls.editor = fld;
    if (this.options.loadTextURL)
      this.loadExternalText();
    this._form.appendChild(this._controls.editor);
  },
  createForm: function() {
    var ipe = this;
    function addText(mode, condition) {
      var text = ipe.options['text' + mode + 'Controls'];
      if (!text || condition === false) return;
      ipe._form.appendChild(document.createTextNode(text));
    };
    this._form = $(document.createElement('form'));
    this._form.id = this.options.formId;
    this._form.addClassName(this.options.formClassName);
    this._form.onsubmit = this._boundSubmitHandler;
    this.createEditField();
    if ('textarea' == this._controls.editor.tagName.toLowerCase())
      this._form.appendChild(document.createElement('br'));
    if (this.options.onFormCustomization)
      this.options.onFormCustomization(this, this._form);
    addText('Before', this.options.okControl || this.options.cancelControl);
    this.createControl('ok', this._boundSubmitHandler);
    addText('Between', this.options.okControl && this.options.cancelControl);
    this.createControl('cancel', this._boundCancelHandler, 'editor_cancel');
    addText('After', this.options.okControl || this.options.cancelControl);
  },
  destroy: function() {
    if (this._oldInnerHTML)
      this.element.innerHTML = this._oldInnerHTML;
    this.leaveEditMode();
    this.unregisterListeners();
  },
  enterEditMode: function(e) {
    if (this._saving || this._editing) return;
    this._editing = true;
    this.triggerCallback('onEnterEditMode');
    if (this.options.externalControl)
      this.options.externalControl.hide();
    this.element.hide();
    this.createForm();
    this.element.parentNode.insertBefore(this._form, this.element);
    if (!this.options.loadTextURL)
      this.postProcessEditField();
    if (e) Event.stop(e);
  },
  enterHover: function(e) {
    if (this.options.hoverClassName)
      this.element.addClassName(this.options.hoverClassName);
    if (this._saving) return;
    this.triggerCallback('onEnterHover');
  },
  getText: function() {
    return this.element.innerHTML.unescapeHTML();
  },
  handleAJAXFailure: function(transport) {
    this.triggerCallback('onFailure', transport);
    if (this._oldInnerHTML) {
      this.element.innerHTML = this._oldInnerHTML;
      this._oldInnerHTML = null;
    }
  },
  handleFormCancellation: function(e) {
    this.wrapUp();
    if (e) Event.stop(e);
  },
  handleFormSubmission: function(e) {
    var form = this._form;
    var value = $F(this._controls.editor);
    this.prepareSubmission();
    var params = this.options.callback(form, value) || '';
    if (Object.isString(params))
      params = params.toQueryParams();
    params.editorId = this.element.id;
    if (this.options.htmlResponse) {
      var options = Object.extend({ evalScripts: true }, this.options.ajaxOptions);
      Object.extend(options, {
        parameters: params,
        onComplete: this._boundWrapperHandler,
        onFailure: this._boundFailureHandler
      });
      new Ajax.Updater({ success: this.element }, this.url, options);
    } else {
      var options = Object.extend({ method: 'get' }, this.options.ajaxOptions);
      Object.extend(options, {
        parameters: params,
        onComplete: this._boundWrapperHandler,
        onFailure: this._boundFailureHandler
      });
      new Ajax.Request(this.url, options);
    }
    if (e) Event.stop(e);
  },
  leaveEditMode: function() {
    this.element.removeClassName(this.options.savingClassName);
    this.removeForm();
    this.leaveHover();
    this.element.style.backgroundColor = this._originalBackground;
    this.element.show();
    if (this.options.externalControl)
      this.options.externalControl.show();
    this._saving = false;
    this._editing = false;
    this._oldInnerHTML = null;
    this.triggerCallback('onLeaveEditMode');
  },
  leaveHover: function(e) {
    if (this.options.hoverClassName)
      this.element.removeClassName(this.options.hoverClassName);
    if (this._saving) return;
    this.triggerCallback('onLeaveHover');
  },
  loadExternalText: function() {
    this._form.addClassName(this.options.loadingClassName);
    this._controls.editor.disabled = true;
    var options = Object.extend({ method: 'get' }, this.options.ajaxOptions);
    Object.extend(options, {
      parameters: 'editorId=' + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport) {
        this._form.removeClassName(this.options.loadingClassName);
        var text = transport.responseText;
        if (this.options.stripLoadedTextTags)
          text = text.stripTags();
        this._controls.editor.value = text;
        this._controls.editor.disabled = false;
        this.postProcessEditField();
      }.bind(this),
      onFailure: this._boundFailureHandler
    });
    new Ajax.Request(this.options.loadTextURL, options);
  },
  postProcessEditField: function() {
    var fpc = this.options.fieldPostCreation;
    if (fpc)
      $(this._controls.editor)['focus' == fpc ? 'focus' : 'activate']();
  },
  prepareOptions: function() {
    this.options = Object.clone(Ajax.InPlaceEditor.DefaultOptions);
    Object.extend(this.options, Ajax.InPlaceEditor.DefaultCallbacks);
    [this._extraDefaultOptions].flatten().compact().each(function(defs) {
      Object.extend(this.options, defs);
    }.bind(this));
  },
  prepareSubmission: function() {
    this._saving = true;
    this.removeForm();
    this.leaveHover();
    this.showSaving();
  },
  registerListeners: function() {
    this._listeners = { };
    var listener;
    $H(Ajax.InPlaceEditor.Listeners).each(function(pair) {
      listener = this[pair.value].bind(this);
      this._listeners[pair.key] = listener;
      if (!this.options.externalControlOnly)
        this.element.observe(pair.key, listener);
      if (this.options.externalControl)
        this.options.externalControl.observe(pair.key, listener);
    }.bind(this));
  },
  removeForm: function() {
    if (!this._form) return;
    this._form.remove();
    this._form = null;
    this._controls = { };
  },
  showSaving: function() {
    this._oldInnerHTML = this.element.innerHTML;
    this.element.innerHTML = this.options.savingText;
    this.element.addClassName(this.options.savingClassName);
    this.element.style.backgroundColor = this._originalBackground;
    this.element.show();
  },
  triggerCallback: function(cbName, arg) {
    if ('function' == typeof this.options[cbName]) {
      this.options[cbName](this, arg);
    }
  },
  unregisterListeners: function() {
    $H(this._listeners).each(function(pair) {
      if (!this.options.externalControlOnly)
        this.element.stopObserving(pair.key, pair.value);
      if (this.options.externalControl)
        this.options.externalControl.stopObserving(pair.key, pair.value);
    }.bind(this));
  },
  wrapUp: function(transport) {
    this.leaveEditMode();
    // Can't use triggerCallback due to backward compatibility: requires
    // binding + direct element
    this._boundComplete(transport, this.element);
  }
});

Object.extend(Ajax.InPlaceEditor.prototype, {
  dispose: Ajax.InPlaceEditor.prototype.destroy
});

Ajax.InPlaceCollectionEditor = Class.create(Ajax.InPlaceEditor, {
  initialize: function($super, element, url, options) {
    this._extraDefaultOptions = Ajax.InPlaceCollectionEditor.DefaultOptions;
    $super(element, url, options);
  },

  createEditField: function() {
    var list = document.createElement('select');
    list.name = this.options.paramName;
    list.size = 1;
    this._controls.editor = list;
    this._collection = this.options.collection || [];
    if (this.options.loadCollectionURL)
      this.loadCollection();
    else
      this.checkForExternalText();
    this._form.appendChild(this._controls.editor);
  },

  loadCollection: function() {
    this._form.addClassName(this.options.loadingClassName);
    this.showLoadingText(this.options.loadingCollectionText);
    var options = Object.extend({ method: 'get' }, this.options.ajaxOptions);
    Object.extend(options, {
      parameters: 'editorId=' + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport) {
        var js = transport.responseText.strip();
        if (!/^\[.*\]$/.test(js)) // TODO: improve sanity check
          throw('Server returned an invalid collection representation.');
        this._collection = eval(js);
        this.checkForExternalText();
      }.bind(this),
      onFailure: this.onFailure
    });
    new Ajax.Request(this.options.loadCollectionURL, options);
  },

  showLoadingText: function(text) {
    this._controls.editor.disabled = true;
    var tempOption = this._controls.editor.firstChild;
    if (!tempOption) {
      tempOption = document.createElement('option');
      tempOption.value = '';
      this._controls.editor.appendChild(tempOption);
      tempOption.selected = true;
    }
    tempOption.update((text || '').stripScripts().stripTags());
  },

  checkForExternalText: function() {
    this._text = this.getText();
    if (this.options.loadTextURL)
      this.loadExternalText();
    else
      this.buildOptionList();
  },

  loadExternalText: function() {
    this.showLoadingText(this.options.loadingText);
    var options = Object.extend({ method: 'get' }, this.options.ajaxOptions);
    Object.extend(options, {
      parameters: 'editorId=' + encodeURIComponent(this.element.id),
      onComplete: Prototype.emptyFunction,
      onSuccess: function(transport) {
        this._text = transport.responseText.strip();
        this.buildOptionList();
      }.bind(this),
      onFailure: this.onFailure
    });
    new Ajax.Request(this.options.loadTextURL, options);
  },

  buildOptionList: function() {
    this._form.removeClassName(this.options.loadingClassName);
    this._collection = this._collection.map(function(entry) {
      return 2 === entry.length ? entry : [entry, entry].flatten();
    });
    var marker = ('value' in this.options) ? this.options.value : this._text;
    var textFound = this._collection.any(function(entry) {
      return entry[0] == marker;
    }.bind(this));
    this._controls.editor.update('');
    var option;
    this._collection.each(function(entry, index) {
      option = document.createElement('option');
      option.value = entry[0];
      option.selected = textFound ? entry[0] == marker : 0 == index;
      option.appendChild(document.createTextNode(entry[1]));
      this._controls.editor.appendChild(option);
    }.bind(this));
    this._controls.editor.disabled = false;
    Field.scrollFreeActivate(this._controls.editor);
  }
});

//**** DEPRECATION LAYER FOR InPlace[Collection]Editor! ****
//**** This only  exists for a while,  in order to  let ****
//**** users adapt to  the new API.  Read up on the new ****
//**** API and convert your code to it ASAP!            ****

Ajax.InPlaceEditor.prototype.initialize.dealWithDeprecatedOptions = function(options) {
  if (!options) return;
  function fallback(name, expr) {
    if (name in options || expr === undefined) return;
    options[name] = expr;
  };
  fallback('cancelControl', (options.cancelLink ? 'link' : (options.cancelButton ? 'button' :
    options.cancelLink == options.cancelButton == false ? false : undefined)));
  fallback('okControl', (options.okLink ? 'link' : (options.okButton ? 'button' :
    options.okLink == options.okButton == false ? false : undefined)));
  fallback('highlightColor', options.highlightcolor);
  fallback('highlightEndColor', options.highlightendcolor);
};

Object.extend(Ajax.InPlaceEditor, {
  DefaultOptions: {
    ajaxOptions: { },
    autoRows: 3,                                // Use when multi-line w/ rows == 1
    cancelControl: 'link',                      // 'link'|'button'|false
    cancelText: 'cancel',
    clickToEditText: 'Click to edit',
    externalControl: null,                      // id|elt
    externalControlOnly: false,
    fieldPostCreation: 'activate',              // 'activate'|'focus'|false
    formClassName: 'inplaceeditor-form',
    formId: null,                               // id|elt
    highlightColor: '#ffff99',
    highlightEndColor: '#ffffff',
    hoverClassName: '',
    htmlResponse: true,
    loadingClassName: 'inplaceeditor-loading',
    loadingText: 'Loading...',
    okControl: 'button',                        // 'link'|'button'|false
    okText: 'ok',
    paramName: 'value',
    rows: 1,                                    // If 1 and multi-line, uses autoRows
    savingClassName: 'inplaceeditor-saving',
    savingText: 'Saving...',
    size: 0,
    stripLoadedTextTags: false,
    submitOnBlur: false,
    textAfterControls: '',
    textBeforeControls: '',
    textBetweenControls: ''
  },
  DefaultCallbacks: {
    callback: function(form) {
      return Form.serialize(form);
    },
    onComplete: function(transport, element) {
      // For backward compatibility, this one is bound to the IPE, and passes
      // the element directly.  It was too often customized, so we don't break it.
      new Effect.Highlight(element, {
        startcolor: this.options.highlightColor, keepBackgroundImage: true });
    },
    onEnterEditMode: null,
    onEnterHover: function(ipe) {
      ipe.element.style.backgroundColor = ipe.options.highlightColor;
      if (ipe._effect)
        ipe._effect.cancel();
    },
    onFailure: function(transport, ipe) {
      alert('Error communication with the server: ' + transport.responseText.stripTags());
    },
    onFormCustomization: null, // Takes the IPE and its generated form, after editor, before controls.
    onLeaveEditMode: null,
    onLeaveHover: function(ipe) {
      ipe._effect = new Effect.Highlight(ipe.element, {
        startcolor: ipe.options.highlightColor, endcolor: ipe.options.highlightEndColor,
        restorecolor: ipe._originalBackground, keepBackgroundImage: true
      });
    }
  },
  Listeners: {
    click: 'enterEditMode',
    keydown: 'checkForEscapeOrReturn',
    mouseover: 'enterHover',
    mouseout: 'leaveHover'
  }
});

Ajax.InPlaceCollectionEditor.DefaultOptions = {
  loadingCollectionText: 'Loading options...'
};

// Delayed observer, like Form.Element.Observer,
// but waits for delay after last key input
// Ideal for live-search fields

Form.Element.DelayedObserver = Class.create({
  initialize: function(element, delay, callback) {
    this.delay     = delay || 0.5;
    this.element   = $(element);
    this.callback  = callback;
    this.timer     = null;
    this.lastValue = $F(this.element);
    Event.observe(this.element,'keyup',this.delayedListener.bindAsEventListener(this));
  },
  delayedListener: function(event) {
    if(this.lastValue == $F(this.element)) return;
    if(this.timer) clearTimeout(this.timer);
    this.timer = setTimeout(this.onTimerEvent.bind(this), this.delay * 1000);
    this.lastValue = $F(this.element);
  },
  onTimerEvent: function() {
    this.timer = null;
    this.callback(this.element, $F(this.element));
  }
});
// script.aculo.us slider.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010

// Copyright (c) 2005-2010 Marty Haught, Thomas Fuchs
//
// script.aculo.us is freely distributable under the terms of an MIT-style license.
// For details, see the script.aculo.us web site: http://script.aculo.us/

if (!Control) var Control = { };

// options:
//  axis: 'vertical', or 'horizontal' (default)
//
// callbacks:
//  onChange(value)
//  onSlide(value)
Control.Slider = Class.create({
  initialize: function(handle, track, options) {
    var slider = this;

    if (Object.isArray(handle)) {
      this.handles = handle.collect( function(e) { return $(e) });
    } else {
      this.handles = [$(handle)];
    }

    this.track   = $(track);
    this.options = options || { };

    this.axis      = this.options.axis || 'horizontal';
    this.increment = this.options.increment || 1;
    this.step      = parseInt(this.options.step || '1');
    this.range     = this.options.range || $R(0,1);

    this.value     = 0; // assure backwards compat
    this.values    = this.handles.map( function() { return 0 });
    this.spans     = this.options.spans ? this.options.spans.map(function(s){ return $(s) }) : false;
    this.options.startSpan = $(this.options.startSpan || null);
    this.options.endSpan   = $(this.options.endSpan || null);

    this.restricted = this.options.restricted || false;

    this.maximum   = this.options.maximum || this.range.end;
    this.minimum   = this.options.minimum || this.range.start;

    // Will be used to align the handle onto the track, if necessary
    this.alignX = parseInt(this.options.alignX || '0');
    this.alignY = parseInt(this.options.alignY || '0');

    this.trackLength = this.maximumOffset() - this.minimumOffset();

    this.handleLength = this.isVertical() ?
      (this.handles[0].offsetHeight != 0 ?
        this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/,"")) :
      (this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth :
        this.handles[0].style.width.replace(/px$/,""));

    this.active   = false;
    this.dragging = false;
    this.disabled = false;

    if (this.options.disabled) this.setDisabled();

    // Allowed values array
    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
    if (this.allowedValues) {
      this.minimum = this.allowedValues.min();
      this.maximum = this.allowedValues.max();
    }

    this.eventMouseDown = this.startDrag.bindAsEventListener(this);
    this.eventMouseUp   = this.endDrag.bindAsEventListener(this);
    this.eventMouseMove = this.update.bindAsEventListener(this);

    // Initialize handles in reverse (make sure first handle is active)
    this.handles.each( function(h,i) {
      i = slider.handles.length-1-i;
      slider.setValue(parseFloat(
        (Object.isArray(slider.options.sliderValue) ?
          slider.options.sliderValue[i] : slider.options.sliderValue) ||
         slider.range.start), i);
      h.makePositioned().observe("mousedown", slider.eventMouseDown);
    });

    this.track.observe("mousedown", this.eventMouseDown);
    document.observe("mouseup", this.eventMouseUp);
    document.observe("mousemove", this.eventMouseMove);

    this.initialized = true;
  },
  dispose: function() {
    var slider = this;
    Event.stopObserving(this.track, "mousedown", this.eventMouseDown);
    Event.stopObserving(document, "mouseup", this.eventMouseUp);
    Event.stopObserving(document, "mousemove", this.eventMouseMove);
    this.handles.each( function(h) {
      Event.stopObserving(h, "mousedown", slider.eventMouseDown);
    });
  },
  setDisabled: function(){
    this.disabled = true;
  },
  setEnabled: function(){
    this.disabled = false;
  },
  getNearestValue: function(value){
    if (this.allowedValues){
      if (value >= this.allowedValues.max()) return(this.allowedValues.max());
      if (value <= this.allowedValues.min()) return(this.allowedValues.min());

      var offset = Math.abs(this.allowedValues[0] - value);
      var newValue = this.allowedValues[0];
      this.allowedValues.each( function(v) {
        var currentOffset = Math.abs(v - value);
        if (currentOffset <= offset){
          newValue = v;
          offset = currentOffset;
        }
      });
      return newValue;
    }
    if (value > this.range.end) return this.range.end;
    if (value < this.range.start) return this.range.start;
    return value;
  },
  setValue: function(sliderValue, handleIdx){
    if (!this.active) {
      this.activeHandleIdx = handleIdx || 0;
      this.activeHandle    = this.handles[this.activeHandleIdx];
      this.updateStyles();
    }
    handleIdx = handleIdx || this.activeHandleIdx || 0;
    if (this.initialized && this.restricted) {
      if ((handleIdx>0) && (sliderValue<this.values[handleIdx-1]))
        sliderValue = this.values[handleIdx-1];
      if ((handleIdx < (this.handles.length-1)) && (sliderValue>this.values[handleIdx+1]))
        sliderValue = this.values[handleIdx+1];
    }
    sliderValue = this.getNearestValue(sliderValue);
    this.values[handleIdx] = sliderValue;
    this.value = this.values[0]; // assure backwards compat

    this.handles[handleIdx].style[this.isVertical() ? 'top' : 'left'] =
      this.translateToPx(sliderValue);

    this.drawSpans();
    if (!this.dragging || !this.event) this.updateFinished();
  },
  setValueBy: function(delta, handleIdx) {
    this.setValue(this.values[handleIdx || this.activeHandleIdx || 0] + delta,
      handleIdx || this.activeHandleIdx || 0);
  },
  translateToPx: function(value) {
    return Math.round(
      ((this.trackLength-this.handleLength)/(this.range.end-this.range.start)) *
      (value - this.range.start)) + "px";
  },
  translateToValue: function(offset) {
    return ((offset/(this.trackLength-this.handleLength) *
      (this.range.end-this.range.start)) + this.range.start);
  },
  getRange: function(range) {
    var v = this.values.sortBy(Prototype.K);
    range = range || 0;
    return $R(v[range],v[range+1]);
  },
  minimumOffset: function(){
    return(this.isVertical() ? this.alignY : this.alignX);
  },
  maximumOffset: function(){
    return(this.isVertical() ?
      (this.track.offsetHeight != 0 ? this.track.offsetHeight :
        this.track.style.height.replace(/px$/,"")) - this.alignY :
      (this.track.offsetWidth != 0 ? this.track.offsetWidth :
        this.track.style.width.replace(/px$/,"")) - this.alignX);
  },
  isVertical:  function(){
    return (this.axis == 'vertical');
  },
  drawSpans: function() {
    var slider = this;
    if (this.spans)
      $R(0, this.spans.length-1).each(function(r) { slider.setSpan(slider.spans[r], slider.getRange(r)) });
    if (this.options.startSpan)
      this.setSpan(this.options.startSpan,
        $R(0, this.values.length>1 ? this.getRange(0).min() : this.value ));
    if (this.options.endSpan)
      this.setSpan(this.options.endSpan,
        $R(this.values.length>1 ? this.getRange(this.spans.length-1).max() : this.value, this.maximum));
  },
  setSpan: function(span, range) {
    if (this.isVertical()) {
      span.style.top = this.translateToPx(range.start);
      span.style.height = this.translateToPx(range.end - range.start + this.range.start);
    } else {
      span.style.left = this.translateToPx(range.start);
      span.style.width = this.translateToPx(range.end - range.start + this.range.start);
    }
  },
  updateStyles: function() {
    this.handles.each( function(h){ Element.removeClassName(h, 'selected') });
    Element.addClassName(this.activeHandle, 'selected');
  },
  startDrag: function(event) {
    if (Event.isLeftClick(event)) {
      if (!this.disabled){
        this.active = true;

        var handle = Event.element(event);
        var pointer  = [Event.pointerX(event), Event.pointerY(event)];
        var track = handle;
        if (track==this.track) {
          var offsets  = this.track.cumulativeOffset();
          this.event = event;
          this.setValue(this.translateToValue(
           (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength/2)
          ));
          var offsets  = this.activeHandle.cumulativeOffset();
          this.offsetX = (pointer[0] - offsets[0]);
          this.offsetY = (pointer[1] - offsets[1]);
        } else {
          // find the handle (prevents issues with Safari)
          while((this.handles.indexOf(handle) == -1) && handle.parentNode)
            handle = handle.parentNode;

          if (this.handles.indexOf(handle)!=-1) {
            this.activeHandle    = handle;
            this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
            this.updateStyles();

            var offsets  = this.activeHandle.cumulativeOffset();
            this.offsetX = (pointer[0] - offsets[0]);
            this.offsetY = (pointer[1] - offsets[1]);
          }
        }
      }
      Event.stop(event);
    }
  },
  update: function(event) {
   if (this.active) {
      if (!this.dragging) this.dragging = true;
      this.draw(event);
      if (Prototype.Browser.WebKit) window.scrollBy(0,0);
      Event.stop(event);
   }
  },
  draw: function(event) {
    var pointer = [Event.pointerX(event), Event.pointerY(event)];
    var offsets = this.track.cumulativeOffset();
    pointer[0] -= this.offsetX + offsets[0];
    pointer[1] -= this.offsetY + offsets[1];
    this.event = event;
    this.setValue(this.translateToValue( this.isVertical() ? pointer[1] : pointer[0] ));
    if (this.initialized && this.options.onSlide)
      this.options.onSlide(this.values.length>1 ? this.values : this.value, this);
  },
  endDrag: function(event) {
    if (this.active && this.dragging) {
      this.finishDrag(event, true);
      Event.stop(event);
    }
    this.active = false;
    this.dragging = false;
  },
  finishDrag: function(event, success) {
    this.active = false;
    this.dragging = false;
    this.updateFinished();
  },
  updateFinished: function() {
    if (this.initialized && this.options.onChange)
      this.options.onChange(this.values.length>1 ? this.values : this.value, this);
    this.event = null;
  }
});
/*
 * QBuilder - builds a domNode
 * @param {String} nodeName - the name of the dom node to be created eg 'div'
 * @param {Object} options - attributes to be added to your dom node
 * @param {Array|String} children - child nodes
 * @param {Object} ext - keys to be extended onto your domNode (careful to not overwrite anything important)
 * @returns {QInputBuilder.el|undefined|doc.createElement|Element|QBuilder.el}
 */
function QBuilder(nodeName, options, children, ext)
{
	if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 9 && (nodeName == 'input' || nodeName == 'textarea') || nodeName == 'select')
	{
		//ie cant build inputs normally so we have to jump through hoops
		var el = QInputBuilder(nodeName, options, children);
	}
	else
	{
		var doc = document;
		if (options && options.document)
		{
			doc = options.document;
		}

		el = doc.createElement(nodeName);

		if(!children && typeof options != 'object')
		{
			children = options;
		}
		else
		{
			for(var nom in options)
			{
				if(nom == 'className')
				{
					el.className = options.className;
				}
				else if(nom == 'id')
				{
					el.id = options.id;
				}
				else if(nom == 'name')
				{
					el.name= options.name;
				}
				else if(nom.substring(0, 2) == 'on')
				{
					el[nom] = Function(options[nom]);
				}
				else if(nom == 'checked')
				{
					if (options[nom])
					{
						el.defaultChecked = true;
						el.setAttribute('checked','checked');
					}
				}
				else if(nom == 'disabled')
				{
					if (options[nom])
					{
						el.setAttribute('disabled', 'disabled');
					}
				}
				else if(nom == 'htmlFor')
				{
					el.htmlFor = options[nom];
					el.setAttribute('for', options[nom]);
				}
				else if(nom == 'style')
				{
					// Can't setAttribute style in ie7, so we'll use the frameworks setStyle
					$(el).setStyle(options[nom]);
				}
				else if (typeof options[nom] != 'undefined' && nom != 'document')
				{
					el.setAttribute(nom, options[nom]);
				}
			}
		}

		if(children)
		{
			if(typeof children === 'object')
			{
				if(children.length)
				{
					for(var i=0, len=children.length; i<len; ++i)
					{
						var ch = children[i];
						if(ch === undefined)
						{
							ch = 'undefined';
						}
						if((typeof ch=='string' || typeof ch=='number') && ch != '')
						{
							el.appendChild(doc.createTextNode(ch));
						}
						else if (ch)
						{
							//check to see if its a real dom node
							if(ch.nodeType)
							{
								el.appendChild(ch);
							}
							else
							{
								//something weird is going on so just put what ever the results of String is.
								el.appendChild(doc.createTextNode(String(ch)));
							}
						}
						else
						{
							//console.warn('QBuilder::ch is null.');
						}
					}
				}
			}
			else
			{
				var node;
				if(typeof children=='string' || typeof children=='number')
				{
					node = doc.createTextNode(children);
				}
				else
				{
					node = children;
				}
				el.appendChild(node);
			}
		}
	}

	if (ext && el)
		Object.extend(el, ext);

	return el;
}

function QInputBuilder(nodeName, options, children)
{
	var attr = '';
	var doc = document;
	if (options && options.document)
	{
		doc = options.document;
	}
	for(var nom in options)
	{
		var val = options[nom];
		var key = '';
		switch(nom)
		{
			case 'className':
				key = 'class';
			break;
			case 'id':
				key = 'id';
			break;
			case 'checked':

				if (options[nom])
				{
					key = 'checked';
				}
			break;
			case 'htmlFor':
				key = 'for';
			break;
			default:
				key = nom;
		}
		if (val != undefined)
		{
			//Only set the value if it is defined, otherwise an undefined value will
			// be the string "undefined" instead of the actual undefined value
			attr += key+'="'+val+'" ';
		}
	}
	var parent = QBuilder('div');
	parent.innerHTML = '<'+nodeName+' '+attr+' />';
	var el = parent.firstChild.cloneNode(true);
	removeElement(parent);//clear the memory leak

	if(children)
	{
		var type = typeof children;
		if(type === 'object')
		{
			for(var i=0, len=children.length; i<len; ++i)
			{
				var ch = children[i];
				var node;
				if(typeof ch=='string' || typeof ch=='number')
				{
					node = doc.createTextNode(ch);
				}
				else
				{
					node = ch;
				}
				//IE8 has problems with the number of children, so only append a child if there is one...
				if (node)
				{
					el.appendChild(node);
				}
			}
		}
		else if(type=='string' || type=='number')
		{
			el.appendChild(doc.createTextNode(children));
		}
	}
	return el;
}

/** will take a string and parse out the html entities **/
function QEntity(str, mode) {
	str = (str) ? str : "";
	mode = (mode) ? mode : "string";

	var e = document.createElement("div");
	e.innerHTML = str;

	if (mode == "numeric") {
		return "&#" + e.innerHTML.charCodeAt(0) + ";";
	}
	else if (mode == "utf16") {
		var un = e.innerHTML.charCodeAt(0).toString(16);
		while (un.length < 4) un = "0" + un;
		return "\\u" + un;
	}
	else return e.innerHTML;
}
/**
*
* Inline Editor Class
* @author oliverh@qualtrics.com
* makes a text input that manipulates an underlying node.
*/


/*
the inlineEditor parentObj needs to have the following:
function getInner() - returns the dom node to manipulate
function getText() - returns the text of the dom node (the text to put in the editor)
function setText() - what to call when the editor needs to change the text.
*/
var inlineEditor = Class.create({
	parentObj:null,
	element:null,
	optionsElement:null,
	menuButtonElement:null,
	documentClickObserver:null,
	skipAnEvent:0,//this is so that the document editor hider doesnt kick in right when they mouse up the first time
	positionShiftTriggers: null,//this is an array with the top and left stored. they are checked whenever things change to see if we need to move the editor.
	editorType:null,
	updateInner:true,//updateInner updates the source node as they type looking at how the new text affects the dimensions and adjusting. if false then the editor will not touch it until the end.
	height:null,
	seriesIndex:null,
	lastTextLength:0,
	lastChoiceHeight:0,
	align:'left',
	repeatCount:0,
	blockKeyUp:false,
	initTime:null,
	eventType:null,
	padding:[2, 3, 2, 3],
	borderWidth:[2, 1, 1, 2],
	/**
	* initialize starts off the editor creation
	* @param options.richText bool - forces richtext mode
	* @param options.evt event - a mouse event
	*/
	initialize:function(parentObj, options)
	{
		//this is a hack that really shouldnt be in this class
		if(window.BaseForm && BaseForm.getInstance() && !BaseForm.getInstance().getPermission('editQuestions'))
		{
			return;
		}

		//remove any old ones.
		if(this.removeInlineEditor(options) === false)
		{
			//we weren't allowed to remove the old one so we can't create a new one either
			return;
		}

		if(parentObj.updateInner === false)
		{
			this.updateInner = false;
		}
		if(!options) options = {};
		this.options = options;
		this.lang = options.lang || 'EN';

		if(parentObj.beforeEdit)
		{
			parentObj.beforeEdit(this);
		}

		this.padding = this.options.padding || this.padding;
		this.borderWidth = this.options.borderWidth || this.borderWidth;

		// permanently store the parentObj for posterity.
		inlineEditor_lastParentObj = parentObj;

		this.initTime = new Date();
		//we need these and they are missing in prototype
		Event.KEY_SPACE = 32;
		Event.KEY_SHIFT = 16;
		Event.KEY_CTRL= 17;
		Event.KEY_ALT= 18;
		Event.CAPS = 20;

		this.parentObj = parentObj;
		if(options.seriesIndex != undefined)
		{
			this.seriesIndex = options.seriesIndex;
			//lets always select a series cause we don't really know if its edited or not, and select is nicer
			options.select = true;
		}
		var thisObj = this;
		parentObj.editing = 1;
		if(parentObj && $(parentObj.id))
		{
			$(parentObj.id).addClassName('Editing');
		}
		//reset the position shift triggers. these are checked whenever things change to see if we need to move the editor.
		this.positionShiftTriggers = new Array();

		this.cachedInner = this.parentObj.getInner(this.seriesIndex, this.lang, options.useLanguage);//the innermost object with the actual text

		if(options.evt)
		{
			var evt = options.evt;
			this.eventType = evt.type;
			//we add this flag in the init so that the removeInlineEditor event doesnt ever close on the same event.

			if(this.eventType == 'mousedown')
			{

				//the editor always gets removed on a document mousedown
				//so when this mousedown bubbles up to the document, it is going to instantly remove itself.
				//so tell the document observer to skip events for 1 millisecond.
				//this will allow all the events observers to flush through the system.
				//this works because the timer wont event start until the event finishes propgating.
				this.skipAnEvent = true;
				setTimeout(this.cancelSkipEvent.bind(this), 1);
			}
		}

		this.createEditor(evt, options); //creates this.element

		//you can have the editor ajax in a stylesheet for use in a iframe editor.
		if(this.editorType == 'iframe')
		{
			if(parentObj && parentObj.styleSheetPath != undefined)
			{
				var inlineEditorObj = this;
				new Ajax.Request(parentObj.styleSheetPath, {
					onSuccess:function(transport)
					{
						inlineEditorObj.externalStyles = transport.responseText;
						inlineEditorObj.insertExternalStyles();
					},
					onFailure:function(transport)
					{
						QError('Cannot load styleSheetPath:  '+parentObj.styleSheetPath);
					}
				});
			}
		}

		//save the original text in case we want to revert
		this.parentObj.originalText = this.parentObj.getText(this.seriesIndex, this.lang);
		//get rid of any tabs in the text
		this.sanitizeText();

		if(this.parentObj.options)
		{
			this.optionsElement = this.createOptions();
		}
		if(this.parentObj.hasMenu || this.parentObj.buildMenu && this.parentObj.hasMenu !== false)
		{
			this.menuButtonElement = QBuilder('div',{className:'inlineEditorOptions', editordowncallback:'showMenu($el, $evt)'},[QBuilder('b',{bubbleup:true},[QBuilder('b',{bubbleup:true})])]);
		}
		//allow for a custom menu button
		if(this.parentObj.buildInlineEditorMenuButton)
		{
			this.menuButtonElement = this.parentObj.buildInlineEditorMenuButton(this.seriesIndex);
		}

		//set the padding
		$(this.element).setStyle({
			padding:this.padding[0]+'px'+' '+this.padding[1]+'px'+' '+this.padding[2]+'px'+' '+this.padding[3]+'px'
		});
		//set the borderWidth
		$(this.element).setStyle({
			borderWidth:this.borderWidth[0]+'px'+' '+this.borderWidth[1]+'px'+' '+this.borderWidth[2]+'px'+' '+this.borderWidth[3]+'px'
		});

		//focus the editor. This is complex to the max.
		//we have to focus on a mouseup event so if they made the editor with a mousedown
		//then we have to set up a mouse up event that will focus.
		if(this.editorType != 'iframe')//the iframe selects itself and this code doesnt even work on it, because its a different document.
		{
			//only do this for init by click
			if(options && options.evt && options.evt.type == 'mousedown')
			{
				//some weirdness to get it to select correctly when they click it
				var oneTimeSelectFunction=function()
				{
					Event.stopObserving(document, 'mouseup', oneTimeSelectFunction);
					Event.stopObserving(document, 'touchend', oneTimeSelectFunction);
					//we need to update the text here to escape any html stuff in the parent so it is the same size
					//and shape as the editor
					if(thisObj.updateInner)
					{
						thisObj.updateDom(thisObj.parentObj.getText(thisObj.seriesIndex, thisObj.lang));
					}
					//focus or select the text
					if(options && options.select)
					{
						thisObj.selectAll();
					}
					else if(parentObj.getEdited)
					{
						thisObj.autoFocus();
					}
				};
				Event.observe(document, 'mouseup', oneTimeSelectFunction);
				Event.observe(document, 'touchend', oneTimeSelectFunction);
			}
		}

		//setup the removing of the editor on document click
		thisObj.setDocumentClickObserver();

		//prevent javascript from running when we stick it on the page
		//this works because the script only runs when its appended.
		var htmlStorage = this.element.innerHTML;
		this.element.innerHTML = '';
		//stick the editor on the page (with no content)
		if ($('pageDiv'))
			$('pageDiv').appendChild(this.element);
		else if ($('mainContentDiv'))
			$('mainContentDiv').appendChild(this.element);
		//put the html back after its been appended so they can see and edit everything
		this.element.innerHTML = htmlStorage;
		htmlStorage = null;

		this.updateEditorPosition();

		if(this.editorType == 'fck')
		{
			if(this.options.overlay !== false)
			{
				this.overlayObj = QualtricsCPTools.Overlay.ShowOverlay({
					parentId:'pageDiv',
					zindex:11500
				});
			}

			var ckWidth = this.options.ckWidth || $(this.element).offsetWidth;
			var ckHeight = this.options.ckHeight || $(this.element).offsetHeight;

			if(this.options.ckMinHeight && ckHeight < this.options.ckMinHeight)
			{
				ckHeight = this.options.ckMinHeight;
			}
			var contentsLangDirection = (this.lang == 'AR' || this.lang == 'HE')?'rtl':'ltr'; // Make sure the text is pointing the right way
			//this.fck.resize(200, 1000);
			var fckStorageTextArea = QBuilder('textarea', {id:'fckStorageTextArea'}, [$('inlineEditor_FCKInput').innerText || $('inlineEditor_FCKInput').textContent]);
			var fckStorageUnit = QBuilder('div',{id:'fckStorageUnit'},[
				fckStorageTextArea
			]);

			$('pageDiv').appendChild(fckStorageUnit);
			// Check if a lanaguage is set in the control panel if it is use that language for ckeditor's interface

			var ckLang = this.lang;
			if (Qualtrics.User.language)
				ckLang = Qualtrics.User.language;

			var ckOptions = {
				width:ckWidth,
				height:ckHeight,
				language:ckLang,
				contentsLangDirection:contentsLangDirection,
				on:{
					instanceReady:function(e)
					{
						e.editor.focus();
					}
				}
			};

			if (this.options.toolbar)
				ckOptions.toolbar = this.options.toolbar;

			this.fck = CKEDITOR.replace(fckStorageTextArea,ckOptions);

			$('fckStorageUnit').setStyle({position:'absolute', top:this.top+'px',left:this.left+'px', zIndex:'12000', display:'block'});
			CKEDITOR.on('instanceReady',this.updateFCKPosition.bind(this));
		}

		if(this.fck && this.editorType == 'fck')
		{
			if($('fckStorageUnit'))
			{
				//update its value
				if(this.fck)
				{
					//NOTE: this will probably only run the 2nd time the fck is used, because its too slow the first time.
					//the first time it will get its data automatically, from the interim textarea.
					//this.fck.updating = true;
					//setTimeout(this.updateFckText.bind(this), 100);//ie6 has a little panic attack if you dont run this as a timeout.
					// just update the text. Webkit was freaking out the second time because of the timeout.
					// We don't support ie6 in edit section anymore so the timeout is not needed anyway.
					this.updateFckText();
				}
			}
		}

		if(options.zIndex || this.parentObj.zIndex)
		{
			$(this.element).setStyle({zIndex:options.zIndex || this.parentObj.zIndex});
		}
		if(this.optionsElement)
		{
			$('pageDiv').appendChild(this.optionsElement);
			this.setupOptions();
		}
		if(this.menuButtonElement)
		{
			$('pageDiv').appendChild(this.menuButtonElement);
			this.setupMenuButton();
		}
		//we need to update the text here to escape any html stuff in the parent so it is the same size
		//and shape as the editor
		//this will also init the checkPositionShift values so it doesnt trigger the first time they enter text
		if(this.updateInner)
		{
			this.updateDom(parentObj.getText(this.seriesIndex, this.lang));
		}
		else
		{
			this.updateEditorWidth();
		}

		//if we havent set up a mouseup to focus the editor then do it right now.
		if(!oneTimeSelectFunction)
		{
			//focus
			if(options && options.select)
			{
				this.selectAll();
			}
			else{
				this.deferredAutoFocus();
			}
		}

		if(this.parentObj.onEdit)
		{
			this.parentObj.onEdit();
		}
		//instance is set at the bottom so removeInlineEditor can remove any old ones properly
		inlineEditor.instance = this;
	},
	getSelfFunction:function()
	{
		return Qualtrics.Event.getSelfFunction('inlineEditor', null, arguments);
	},
	getInner:function(update)
	{
		if(!this.cachedInner || update)
		{
			 this.cachedInner = this.parentObj.getInner(this.seriesIndex, this.lang);
		}
		return this.cachedInner;
	},
	restart:function()
	{
		this.parentObj.edit(null,null,{select:true, seriesIndex:this.seriesIndex, lang:this.lang});
	},
	cancelSkipEvent:function()
	{
		this.skipAnEvent = false;
	},
	updateFckText:function()
	{
		var editor = inlineEditor.getInstance();
		if (editor)
		{
			var data = editor.parentObj.getText(this.seriesIndex, this.lang);
			this.setFckText(data);
		}

	},
	setFckText:function(data)
	{
		if (this.fck.setData)
		{
			this.fck.setData(data);
			this.fck.updating = false;
			this.fck.focus();
		}
		else
		{
			var that = this;
			CKEDITOR.on('loaded', function()
			{
				that.fck.setData(data);
				that.fck.updating = false;
				if (that.fck.focus)
					that.fck.focus();
			});
		}
	},
	setSeriesIndex:function(seriesIndex, opt_evt)
	{
		var lang = this.lang;
		//force the inlineEditor to remove. We dont want to pass the event here because the event can tell the remove not to run.
		this.removeInlineEditor({transitional:true});
		this.parentObj.edit(opt_evt, {seriesIndex:seriesIndex, lang:lang});
	},
	deferredAutoFocus:function()
	{
		var thisObj = this;
		setTimeout(function(){thisObj.autoFocus();},1);
	},
	/**
	* focuses or selects, based on if its has been edited or not.
	*/
	autoFocus:function()
	{
		if(this.parentObj.getEdited) //the parentObj.edited property is optional.
		{
			if(this.parentObj.getEdited(this.lang))
			{
				this.focus();
			}
			else
			{
				this.selectAll();
			}
		}
		else
		{
			this.focus();
		}
	},
	focus:function(opt_position)
	{
		var caretPosition = opt_position;
		var anchorNode = null;
		if(typeof opt_position == 'object')
		{
			caretPosition = opt_position.offset;
			anchorNode = opt_position.node;
		}
		if(anchorNode && anchorNode.descendantOf && !$(anchorNode.descendantOf(this.getTextElement())))
		{
			//we have an invalid anchorNode so cancel it.
			anchorNode = null;
			caretPosition = null;
		}

		if(!this.element)
		{
			return;
		}
		var textObj = this.getTextElement();
		if(this.editorType == 'textarea')
		{
			if (caretPosition  === undefined)
			{
				var val = this.getValue();
				if(val) caretPosition = val.length;
			}
			//prototype doesnt do ie very well
			if(this.element.createTextRange)
			{
				var end = caretPosition;
				var range = this.element.createTextRange();
				if(range){
					range.collapse(true);
					range.moveStart('character', end);
					range.moveEnd('character', end);
					try{
						range.select();
					}catch(e){
						if ($(this.element).focus) // Somewhat of a hack, but IE stops complaining
							$(this.element).focus();
					}
				}
			}
			else
			{
				if($(this.element).focus)
				{
					$(this.element).focus();
					//try to put the focus at the end
					if(this.element.setSelectionRange)
					{
						var end = caretPosition;

						try{
							/* this causes random firefox js errors and i dont know why
							TODO: figure out what the error is caused by, it only happens when you edit the x axis of a matrix*/
							this.element.setSelectionRange(end,end);
						}catch(e)
						{

						}
					}
				}
			}
		}
		else if(this.editorType == 'div')
		{
			//ie only
			if(document.body.createTextRange)
			{
				//I cant figure out how to position IE yet so it just goes to the end regardless of what position says. lame.
				textObj.focus();
				var textrange = document.selection.createRange();
				textrange.moveToElementText(textObj);
				textrange.collapse(false); //false means collapse to end
				textrange.select();
			}
			else
			{
				if(textObj)
				{
					textObj.focus();
					if(!anchorNode)
					{
						//if no anchorNode is specified then find the last text node in the editor
						 anchorNode = textObj.childNodes[textObj.childNodes.length-1];
						 caretPosition = undefined; //reset this. if this was set it no longer applies.
					}
					if (caretPosition === undefined && anchorNode)
					{
						//if no caretPosition is specified then use the end of the anchor
						caretPosition = anchorNode.length || anchorNode.textContent && anchorNode.textContent.length;
					}

					if(caretPosition !== undefined)
					{
						//focus at the caret position
						var sel = window.getSelection();
						//var el = this.getTextElement();
						if(sel.setPosition)
						{
							sel.setPosition(anchorNode, caretPosition);
						}
						else
						{
							//firefox
							try
							{
								sel.selectAllChildren(anchorNode);
								sel.collapseToStart();
								sel.extend(anchorNode, caretPosition);
								sel.collapseToEnd();
							}
							catch(e) {}
						}
					}
				}
			}
		}
		else if(this.editorType == 'iframe')
		{

			//i dont know why these need to be delayed but it just doesnt work otherwise
			var that =  this;
			if(this.element && this.element.contentWindow && this.iFrameLoaded) //makes sure its loaded before we do stuff to it
			{
				if(!anchorNode)
				{
					//if no anchorNode is specified then find the last text node in the editor
					 anchorNode = textObj.childNodes[textObj.childNodes.length-1];
					 caretPosition = undefined; //reset this. if this was set it no longer applies.
				}
				if(anchorNode.firstChild && anchorNode.firstChild.nodeType === 3)
				{
					//use the text node
					anchorNode = anchorNode.firstChild;
				}
				if (caretPosition === undefined && anchorNode.length)
				{ //if no caretPosition is specified then use the end of the anchor
					caretPosition = anchorNode.length;
				}

				//firefox on the mac crashes on the selectall command, but it doesnt if we throw these bold commands
				//before we call it. weird.
				try{
					//firefox 3 gives weird errors without this try catch
					var win  = that.element.contentWindow;

					that.element.contentDocument.execCommand('SelectAll', false,"");

					selObj = win.getSelection();
					selObj.collapseToEnd();
					win.focus();

					if(caretPosition !== undefined)
					{
						var range= win.getSelection().getRangeAt(0);

						range.setStart(anchorNode, caretPosition);
						range.setEnd(anchorNode, caretPosition);
					}
					win.focus();
				}
				catch(e)
				{
					console.log('anchorNode', anchorNode);
					console.log('caretPosition', caretPosition);
					console.error(e);
				}
			}
		}
	},
	selectAll:function(debug)
	{
		if(this.editorType == 'textarea')
		{
			if(this.element)
			{
				//ie8 seems to be having trouble doing this select unless its defered;
				var that = this;
				(function(){
					if(that.element)
					{
						that.element.focus();
						that.element.select();
					}
				}).defer();
			}
		}
		else if(this.editorType == 'div')
		{
			if(document.body.createTextRange)
			{
				var textrange = document.body.createTextRange();
				try{
					textrange.moveToElementText(this.getTextElement());
					textrange.execCommand('SelectAll', false,"");
				}catch(e)
				{
					//alert('selectAll error: '+e.message+' called by '+ debug);
				}

			}
			//safari will use setBaseAndExtent
			else if(window.getSelection() && window.getSelection().setBaseAndExtent){
				if(this.getTextElement())
					window.getSelection().setBaseAndExtent(this.getTextElement(), 0, this.getTextElement(), this.getTextElement().childNodes.length);
			}
			else
			{
				//firefox v3 and beyond
				if(this.getTextElement()){
					this.getTextElement().focus();
					document.execCommand('selectAll', false, null);
				}
			}
		}
		else if(this.editorType == 'iframe')
		{
			var that = this;
			setTimeout(function(){
				if(that.element && that.element.contentWindow)
				{
					that.element.contentWindow.focus();
					//firefox on the mac crashes on the selectall command, but it doesnt if we throw these bold on/off commands
					//before we call it. weird
					that.element.contentDocument.execCommand('bold', false,"");
					that.element.contentDocument.execCommand('bold', false,"");
					that.element.contentDocument.execCommand('selectAll', false, null);
				}
			},100);
		}

	},
	getSelectRange:function()
	{
		return this.getCaret();
	},
	getCaret:function()
	{
		var el = this.getTextElement();
		var start = 0, end = 0, normalizedValue, range, textInputRange, len, endRange;

		if (typeof el.selectionStart == "number" && typeof el.selectionEnd == "number") {
			start = el.selectionStart;
			end = el.selectionEnd;
		}
		else if(window.getSelection && window.getSelection())
		{
			var win = this.element.contentWindow || window; //the contentWindow is for iframes support
			var range = win.getSelection().getRangeAt(0);

			start = range.startOffset;
			end = range.endOffset;

			el = range.parentElement && range.parentElement() || range.commonAncestorContainer || el;
		}
	    else if(el.createTextRange)
	    {
			range = document.selection.createRange();
			if (range && range.parentElement() == el)
			{
				len = this.getValue().length;
				normalizedValue = this.getValue().replace(/\r\n/g, "\n");

				// Create a working TextRange that lives only in the input
				textInputRange = el.createTextRange();
				textInputRange.moveToBookmark(range.getBookmark());

				// Check if the start and end of the selection are at the very end
				// of the input, since moveStart/moveEnd doesn't return what we want
				// in those cases
				endRange = el.createTextRange();
				endRange.collapse(false);

				if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1)
				{
					start = end = len;
				}
				else
				{
					start = -textInputRange.moveStart("character", -len);
					start += normalizedValue.slice(0, start).split("\n").length - 1;

				    if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1)
				    {
						end = len;
				    }
				    else
				    {
						end = -textInputRange.moveEnd("character", -len);
						end += normalizedValue.slice(0, end).split("\n").length - 1;
				    }
				}
			}
		}
		return {
			node:el,
			offset:start,
			start: start,
			end: end
		};
	},
	/**
	* when the editor is initialized it can ajax in a stylesheet defined in parentObj.styleSheetPath.
	* it puts it in this.externalStyles this inserts them into the iframe.
	* it only does this once, because it is called twice. once from the ajax.onSuccess and once from the iframe.onLoad (whichever one executes last).
	*/
	insertExternalStyles:function()
	{
		//this only works and is only needed on iframes.
		//check to see if both the ajax and the iframes are loaded.
		if(this.externalStyles && this.editorType == 'iframe')
		{
			if(this.iFrameLoaded)
			{
				var doc = this.element.contentDocument;
				if(doc)
				{
					var head = doc.getElementsByTagName('head')[0];
					if(head)
					{
						var styleResets = QBuilder('style',{type:'text/css', title:'StyleResets', rel:'stylesheet', media:'screen'},this.externalStyles);
						head.appendChild(styleResets);
						/*if(doc.styleSheets[0] && doc.styleSheets[0].insertRule)
						{
							//reset rules
							doc.styleSheets[0].insertRule("body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,textarea,p,blockquote,th,td { margin:0; padding:0; font-family:arial;}",0);
							//now we need to make the elements look right

						}*/
					}
				}
				return;
			}
		}
	},
	createEditor:function(evt, options)
	{
		if(!evt)
		{
			evt = window.event;
		}

		//check to see if we need a rich text editor
		//if they have ctrl pressed then no rich text
		var forceTextArea = (evt && evt.ctrlKey) || (evt && evt.metaKey);
		var content = this.parentObj.getText(this.seriesIndex, this.lang);
		var safeDisplay = QualtricsTools.filterForDisplay(content);

		if(options && options.richText != undefined)
		{
			forceTextArea = !options.richText;
		}

		if(options && options.fck)
		{
			//they want a full rich text editor. but it can take a while to load the first time
			//so we put in a text area that can work in place of it until it gets here.
			//also the fck can get its initial value from it automatically.
			this.editorType = 'fck';
			this.interimInput = QBuilder('textarea',{id:'inlineEditor_FCKInput', style:'visibility:hidden;'},[content]);
			this.element = QBuilder('div',{id:'InlineEditorElement', className:'inlineEditor',style:'background:white'},[this.interimInput]);
			this.updateEditorWidth();
		}
		else
		{
			if(this.parentObj.html && !forceTextArea)
			{
				//make an iframe editor, cause the browser cant do an editable div (firefox)
				if(QBuilder('div').contentEditable === undefined) //firefox puts weird resizing things on its editable divs and i cant figure out why.
				{
					this.editorType = 'iframe';
					var that = this;

					var inlineEditor = Builder.node('iframe',{
						id:'InlineEditorElement',
						className:'inlineEditor',
						scrolling:'no',
						style:'line-height:0px; vertical-align:bottom',
						name:'inlineEditor',
						frameBorder:0
					},content);

					$(inlineEditor).setStyle({
						opacity:0
					});
					Event.observe(inlineEditor,'load',function(){

						var doc = null;
						if(inlineEditor.contentDocument)
						{
							doc = inlineEditor.contentDocument;
							win = inlineEditor.contentWindow;
							that.loaded = true;
							that.iFrameLoaded = true;
							if(doc)
							{
								var bod = doc.getElementsByTagName('body')[0];
								bod.innerHTML = that.parentObj.getText(that.seriesIndex, that.lang);
								doc.designMode="on";
								bod.contentEditable='true';

								bod.style.margin = '0px';
								//assign behavior to the editor
								that.element = inlineEditor;

								that.setupEditor();
								that.updateEditorWidth();

								//the opacity is preset to 0 when its created
								//setting the opacity to nothing shows the editor only after it is completly set up
								$(inlineEditor).setStyle({
									opacity:''
								});
								that.autoFocus();

								bod = null;
								inlineEditor = null;

								//if the parent has a stylesheet path then try to insert it at this point.
								//this only will work if the stylesheet has already been successfully ajaxed in.
								if(that.parentObj.styleSheetPath)
								{
									that.insertExternalStyles();
								}
							}
						}
					});
					that.element = inlineEditor;
					inlineEditor.activate = function(){}; //todo: remove this
				}

				else
				{

					//make an editable div (IE & FF 3)
					this.editorType = 'div';
					var inlineEditor= QBuilder('div',{className:'inlineEditor'},
					[
						QBuilder('div',{id:'InlineEditorElement', scrolling:'no',contentEditable:true, frameborder:"no", style:'outline:none'})
					]);
					//assign behavior to the editor
					this.element = inlineEditor;
					inlineEditor = null;
					this.getTextElement().innerHTML = safeDisplay;
					this.setupEditor();
				}
			}
			else
			{
				//a textarea will suffice
				if(content) content = content.strip();
				this.editorType = 'textarea';
				var inlineEditor = QBuilder('textarea',{
					id:'InlineEditorElement',
					className:'inlineEditor',
					type:'text',
					autocomplete:'off',
					name:'inlineEditor'
				});
				//ie9 has a bug that puts </body> in every text area that we create. so setting the value after its created wipes out the existing erroneous text
				inlineEditor.value = content;
				this.element = inlineEditor;
				inlineEditor = null;
				this.setupEditor();
			}

		}
	},
	/**
	* this will check for things that we can not have, it is called on init right after the editor is created.
	*/
	sanitizeText:function()
	{
		var text = this.parentObj.getText(this.seriesIndex, this.lang);
		if(this.editorType == 'textarea')
		{
			//we can't have any tabs because they cant be rendered in html.
			//replace tabs with a space, .
			var newText = String(text).replace(/\t/g, " ");
			//only update if it actually did anything, because updating is slow and recursive.
			if(newText != text)
			{
				text = newText;
				this.updateText(text);
				this.setValue(text);
			}
		}
	},
	hasRichText:function(opt_text, var_args)
	{
		if(opt_text === undefined)
		{
			opt_text = this.getValue();
		}
		var stripped = this.getStrippedFormatting(opt_text);
		if(opt_text !== stripped)
		{
			return true;
		}
		return false;
	},
	getStrippedFormatting:function(text)
	{
		return QualtricsCPTools.stripFormatting(text);
	},
	removeFormatting:function()
	{
		var text = this.getValue();
		var stripped = String(this.getStrippedFormatting(text));
		this.updateText(stripped);
		this.setValue(stripped);
	},
	updateRemoveFormattingButton:function(opt_text, var_args)
	{
		var toolbar = $('RichTextToolBar');
		if(opt_text === undefined)
		{
			opt_text = this.getValue();
		}
		if(toolbar)
		{
			if(this.hasRichText(opt_text))
			{
				$(toolbar).addClassName('HasRichText');
			}
			else
			{
				$(toolbar).removeClassName('HasRichText');
			}
		}
	},
	createOptions:function()
	{
		//NOTE: these options are positioned at the end of InlineEditor.updateEditorWidth();
		if(this.parentObj.html)
		{
			var viewModeClass = "Normal";
			if(this.editorType == 'textarea')
			{
				viewModeClass = "Code";
			}
			var modeOptions = QBuilder('div',{className:'Section inlineEditorHTMLButtons '+viewModeClass},[
				QBuilder('div',{className:'LeftCap'}),
				QBuilder('div',{className:'MidSection'},[
					QBuilder('span',{className:'NormalButton', editorupcallback:'switchToRichText', p1:'$evt'}, getMessage('EditSection','NormalView')),
					QBuilder('span',{className:'CodeButton', editorupcallback:'switchToTextArea', p1:'$evt'}, getMessage('EditSection','HTMLView'))
				]),
				QBuilder('div',{className:'RightCap'})
			]);
			var removeFormatting = QBuilder('div',{className:'Section LargeSection RemoveFormatting'},[
				QBuilder('div',{className:'LeftCap'}),
				QBuilder('div',{className:'MidSection'},[
					QBuilder('span',{className:'Button', editorupcallback:'removeFormatting'}, getMessage('EditSection', 'RemoveFormatting'))
				]),
				QBuilder('div',{className:'RightCap'})
			]);
			var fck = QBuilder('div',{className:'Section LargeSection RichTextSection'},[
				QBuilder('div',{className:'LeftCap'},[
					QBuilder('span',{className:'Icon'})
				]),
				QBuilder('div',{className:'MidSection'},[
					QBuilder('span',{className:'Button', editorupcallback:'switchToFCK'}, getMessage('ResultsSection', 'RichTextEditor') + '...')
				]),
				QBuilder('div',{className:'RightCap'})
			]);
			var pipedText = '';


				pipedText = QBuilder('div',{className:'Section LargeSection PipedTextSection'},[
					QBuilder('div',{className:'LeftCap'},[
						QBuilder('span',{className:'Icon'})
					]),
					QBuilder('div',{className:'MidSection'},[
						QBuilder('span',{className:'Button', editordowncallback:'openPipedText($el)'},getMessage('Piping', 'PipedText') + '...')
					]),
					QBuilder('div',{className:'RightCap'})
				]);

			var options = QBuilder('div',{id:'RichTextToolBar', className:'RichTextToolBar'},[
				fck,
				pipedText,
				removeFormatting,
				modeOptions
			]);
		}
		else if(this.editorType == 'textarea')
		{
			if(this.parentObj.multiline)
			{
				options = QBuilder('div',{className:'inlineEditorHTMLButtons Code'},[
					QBuilder('div',{className:'LeftCap'}),
					QBuilder('div',{className:'MidSection'},[
						QBuilder('span',{className:'NormalButton', editorupcallback:'switchToRichText'},'Normal View'),
						QBuilder('span',{className:'CodeButton'},'Code View')
					]),
					QBuilder('div',{className:'RightCap'})
				]);
			}
		}
		return options;
	},
	showMenu:function(clickedEl, evt)
	{

		if(!clickedEl) clickedEl = this.menuButtonElement;
		//in the options we need to give it the scope of the build function.
		//and we need to have the first parameter of the build function be the seriesIndex (if there is one)
		QMenu.showMenu(this.parentObj.buildMenu, clickedEl, {scope:this.parentObj, p1:this.seriesIndex, p2:this.lang}, evt);
		return;
	},
	stopHideOptionsSequence:function()
	{
		//stop the hide sequence from executing.
		if(this.timer)
		{
			this.timer.stop();
		}
		$(this.optionsElement).setStyle({opacity:1});
	},
	startHideOptionsSequence:function()
	{
		if($(this.optionsElement) && $(this.optionsElement).hasClassName('Expanded'))
		{
			if(this.showTimer)
			{
				this.showTimer.stop();
			}
			$(this.optionsElement).setStyle({opacity:0.5});
			var that = this;
			this.timer = new PeriodicalExecuter(function(pe){
				pe.stop();
				pe = null;
				that.hideOptions();
			}, 1.7);
		}
	},
	hideOptions:function()
	{
		if($(this.optionsElement))
		{
			$(this.optionsElement).setStyle({opacity:1});
			$(this.optionsElement).setStyle({width:''});
			$(this.optionsElement).removeClassName('Expanded');
		}
	},
	optionsClick:function(evt)
	{
		if(Event.isLeftClick(evt))
		{
			Qualtrics.Event.baseDistributerReader(evt, Event.element(evt), 'editorclickcallback', this);
			Event.stop(evt);
		}
	},
	optionsDown:function(evt)
	{
		if(Event.isLeftClick(evt))
		{
			Qualtrics.Event.baseDistributerReader(evt, Event.element(evt), 'editordowncallback', this);
			Event.stop(evt);
		}
	},
	optionsUp:function(evt)
	{
		if(Event.isLeftClick(evt))
		{
			Qualtrics.Event.baseDistributerReader(evt, Event.element(evt), 'editorupcallback', this);
			Event.stop(evt);
		}
	},
	toggleTextEntry:function()
	{
		this.parentObj.toggleTextEntry();
		this.parentObj.parentObj.refreshCanvas();
		//we need to unset the cachedInner cause new selections have been created
		this.cachedInner = null;
		this.checkPositionShift();
	},
	/**
	* switchToTextArea is going into code view.
	**/
	switchToTextArea:function(evt)
	{
		var minHeight = 150;
		var height = $(this.getInner()).getHeight();
		if(height < minHeight)
		{
			height = minHeight;
		}
		var parentObj = this.parentObj;
		var editor = parentObj.edit(evt, null, {richText:false, lang:this.lang, transitional:true});
		$(editor.getTextElement()).setStyle({
			fontFamily:'Courier, monospace',
			fontWeight:'normal',
			height:height+'px',
			overflow:'auto'
		});

		editor.codeViewMode = true;
	},
	switchToRichText:function(evt)
	{
		var parentObj = this.parentObj;
		parentObj.edit(evt, null, {richText:true, lang:this.lang, transitional:true});
	},
	switchToFCK:function(evt)
	{
		var parentObj = this.parentObj;
		new inlineEditor(parentObj, this.getFCKEditorOptions(evt));
	},
	getFCKEditorOptions:function(evt)
	{
		var defaultOptions = this.getDefaultFCKEditorOptions(evt);
		return defaultOptions;
	},
	getDefaultFCKEditorOptions:function(evt)
	{
		var lang = this.lang;
		return {evt:evt, fck:true, lang:lang, transitional:true, ckWidth:this.options.ckWidth, ckHeight:this.options.ckHeight, ckMinHeight:this.options.ckMinHeight};
	},
	openPipedText:function(clickedEl)
	{
		QModules.loadModule('pipedtext.js');
		if(Qualtrics.PipedText)
		{
			this.keepOpen = true;
			var pipedText = new Qualtrics.PipedText(clickedEl, 'inlineEditor.insert', {position:this.getCaret()});
			pipedText.menu.onClose = this.allowClose.bind(this);
		}
	},
	keepEditorOpen:function()
	{
		this.keepOpen = true;
	},
	allowClose:function()
	{
		this.keepOpen = false;
	},
	removeChoice:function()
	{
		this.removeInlineEditor();
		this.parentObj.removeSelectionAndRefresh();
	},
	setupOptions:function()
	{
		var that = this;
		that.optionsElement.onclick = function(evt){
			if(!evt) evt = window.event;
			that.optionsClick(evt);
		};
		that.optionsElement.onmousedown = function(evt){
			if(!evt) evt = window.event;
			that.optionsDown(evt);
		};
		that.optionsElement.onmouseup = function(evt){
			if(!evt) evt = window.event;
			that.optionsUp(evt);
		};

	},
	setupMenuButton:function()
	{
		var that = this;
		if(this.menuButtonElement)
		{
			that.menuButtonElement.onclick = function(evt){
				if(!evt) evt = window.event;
				that.optionsClick(evt);
			};
			that.menuButtonElement.onmousedown = function(evt){
				if(!evt) evt = window.event;

				that.optionsDown(evt);
			};
			that.menuButtonElement.onmouseup = function(evt){
				if(!evt) evt = window.event;
				that.optionsUp(evt);
			};
		}
	},
	setupEditor:function()
	{
		var inner = this.getInner();
		if(!inner)
		{
			inner = this.getInner(true);
		}
		// positions the editor, assigns all its key behaviours and some other stuff
		var parentFontSize = ($(inner).getStyle('font-size'));
		var parentFontFamily = ($(inner).getStyle('font-family'));
		var parentFontWeight = ($(inner).getStyle('font-weight'));
		var parentAlign = ($(inner).getStyle('text-align'));
		if(inner.parentNode)
		{
			var vAlign = ($(inner.parentNode).getStyle('vertical-align'));
		}


		if(parentFontSize)
		{
			this.getTextElement().style.fontSize = parentFontSize;
		}
		//we don't do lineHeight matching on html sources
		//because firefox 3 has issues with it and we don't really need it.
		if(!this.parentObj.html)
		{
			var parentLineHeight = ($(this.getInner()).getStyle('line-height'));
			if(parentLineHeight)
			{
				this.getTextElement().style.lineHeight = parentLineHeight;
			}
		}
		if(parentFontFamily)
		{
			this.getTextElement().style.fontFamily = parentFontFamily;
		}
		if(parentFontWeight)
		{
			this.getTextElement().style.fontWeight = parentFontWeight;
		}
		if(parentAlign && parentAlign == 'right') //only do right aligns because left will screw up direction rtl
		{
			this.getTextElement().style.textAlign = parentAlign;
			this.align = parentAlign;
		}

		if(this.lang == 'AR' || this.lang == 'HE'){
			this.getTextElement().style.direction = 'rtl';
		}
		if(vAlign)
		{

			this.vAlign = vAlign;
		}

		var that = this;
		var eventElement = that.getEventElement();
		//I would love to use prototype for this, but its slow and leaks memory.
		//So I have to abstract browsers myself.
		if(eventElement.attachEvent)
		{
			//ie
			eventElement.attachEvent('onkeydown',that.doKeyDown,false);
			eventElement.attachEvent('onkeyup',that.doKeyUp,false);
			eventElement.attachEvent('onkeypress',that.doKeyPress,false);
			eventElement.attachEvent('onpaste',that.realPaste,false);
			eventElement.attachEvent('input',that.doInput,false);
            // we only need this event if validChars is set
            if(this.parentObj.validChars)
            {
                eventElement.attachEvent('input',that.doChange,false);
            }
		}
		else
		{
			//others
			eventElement.addEventListener('keydown',that.doKeyDown,false);
			eventElement.addEventListener('keyup',that.doKeyUp,false);
			eventElement.addEventListener('keypress',that.doKeyPress,false);

			// We need to watch for this event for resizing images
			eventElement.addEventListener('input',that.doInput,false);

            // we only need this event if validChars is set
            if(this.parentObj.validChars)
            {
                eventElement.addEventListener('input',that.doChange,false);
            }
			if(that.editorType == 'iframe')
			{
				eventElement.addEventListener('dragdrop',that.doDrop,false);
			}
			else
			{
				eventElement.addEventListener('drop',that.doDrop,false);
			}
			if (Qualtrics.Browser.Features.onPaste)
			{
				//real paste for parsing and running a parent.onPaste
				eventElement.addEventListener('paste',that.realPaste,false);
			}
			else
			{
				//fake paste for parsing
				that.lastText = that.getValue();
				eventElement.addEventListener('input',that.doInputPaste,false);
			}
		}

		eventElement = null;

	},
	/**
	* checks to see if there is a keymap associated
	* @param {String} key - the key eg. 'backspace', 'up', 'enter'
	*/
	hasCustomKeyMap:function(key)
	{
		var thisObj = inlineEditor.getInstance();
		var parentObj = thisObj.parentObj;

		if(parentObj.keyMap && parentObj.keyMap[key] !== undefined)
		{
			return true;
		}
		return false;
	},
	/**
	* checks to see if there is a keymap associated and executes the mapped function and returns the results
	* if the key is mapped to null it returns true.
	* @param {String} key - the key eg. 'backspace', 'up', 'enter'
	*/
	useCustomKeyMap:function(key, evt)
	{
		var thisObj = inlineEditor.getInstance();
		var parentObj = thisObj.parentObj;

		if(parentObj.keyMap && parentObj.keyMap[key] !== undefined)
		{
			if(parentObj[parentObj.keyMap[key]])
			{
				var target = parentObj[parentObj.keyMap[key]](thisObj, evt);
				if(target && target.edit)
				{
					target.edit(null,null,{select:true, lang:thisObj.lang});
				}
			}
			else
			{
				//a key mapped to null means just prevent the default inline editor
				if(parentObj.keyMap[key] === null)
				{
					return true;
				}
				//pre defined keymaps

				if(parentObj.keyMap[key] === 'close')
				{
					this.removeInlineEditor();
					return false;
				}
			}
			return true;
		}

		return false;
	},
    /**
     * added to strip illegal characters on paste
     *
     * @param evt - the event object
     */
    doChange:function(evt)
    {
        var thisObj = inlineEditor.getInstance();

        var validChars = thisObj.parentObj.validChars;
        if(typeof validChars == 'string')
        {
            validChars = new RegExp(validChars);
        }
        if(validChars)
        {
                var chr = evt.target.value;
                var result = '';
                for(var i = 0; i < chr.length; i++)
                {
                    if(chr.charAt(i) && chr.charAt(i).match(validChars))
                    {
                        result += chr.charAt(i);
                    }
                }
            thisObj.setValue(result);
        }
    },
	doKeyDown:function(evt)
	{
		//ie wont let us stop these keys unless its an onkeydown event
		if (!evt) var evt = window.event;

		var thisObj = inlineEditor.getInstance();
		thisObj.blockKeyUp = false;
		var parentObj = thisObj.parentObj;
		thisObj.repeatCount++;

		if(parentObj.onKeyDown && parentObj.onKeyDown(evt) === false)
		{
			Event.stop(evt);
			return false;
		}

		if(evt.keyCode == Event.KEY_BACKSPACE)
		{
			thisObj.parentObj.changed = true;
			//firefox deletes the last choice also if its tied to keyup
			//and msie wont let us stop the event if its tied keypress.
			//so they need to be separated
			if(thisObj.hasCustomKeyMap('backspace'))
			{
				var result = thisObj.useCustomKeyMap('backspace', evt);
				return;
			}
		}
		else if(evt.keyCode == Event.KEY_ESC)
		{
			if ((evt.keyCode == Event.KEY_ESC) && thisObj.hasCustomKeyMap('esc'))
			{
				return thisObj.useCustomKeyMap('esc', evt);
			}
			if (thisObj)
			{
				thisObj.setValue(parentObj.originalText);
				thisObj.removeInlineEditor({evt:evt});
				Event.stop(evt);
				return;
			}
		}
		else if(evt.keyCode == Event.KEY_UP || (evt.keyCode == Event.KEY_TAB && evt.shiftKey))
		{
			if ((evt.keyCode == Event.KEY_UP) && thisObj.hasCustomKeyMap('up'))
			{
				return thisObj.useCustomKeyMap('up');
			}

			var customUp = thisObj.useCustomKeyMap('up', evt);
			if ( (evt.shiftKey && evt.keyCode == Event.KEY_TAB) &&
			      thisObj.hasCustomKeyMap('shiftTab'))
			{
				return thisObj.useCustomKeyMap('shiftTab', evt);
			}

			var prevSelection = parentObj.getPrev && parentObj.getPrev(thisObj.seriesIndex);
			if (prevSelection)
			{
				prevSelection.edit(null,null,{select:true, lang:thisObj.lang});
			}
			else
			{
				var prevGroup = parentObj.getPrevGroup && parentObj.getPrevGroup(thisObj.seriesIndex);
				if(prevGroup)
				{
					prevGroup.edit(null,null,{select:true, lang:thisObj.lang});
				}
			}

			evt.preventDefault(); //to make sure we don't scroll up on the page

			return false;
		}
		else if(evt.keyCode == Event.KEY_DOWN || evt.keyCode == Event.KEY_TAB)
		{
			if(evt.keyCode == Event.KEY_TAB)
			{
				Event.stop(evt);
				if(thisObj.codeViewMode)
				{
					//insert a tab
					thisObj.insert('\t');
					return true;
				}
			}
			if ( (evt.keyCode == Event.KEY_DOWN) &&
			      thisObj.hasCustomKeyMap('down') )
			{
				return thisObj.useCustomKeyMap('down', evt);
			}

			if ( (evt.keyCode == Event.KEY_TAB) &&
			      thisObj.hasCustomKeyMap('tab') )
			{
				return thisObj.useCustomKeyMap('tab', evt);
			}
			var nextSelection = parentObj.getNext && parentObj.getNext(thisObj.seriesIndex);

			if(nextSelection)
			{
				nextSelection.edit(null,null,{select:true, lang:thisObj.lang});
			}
			else
			{
				var nextGroup = parentObj.getNextGroup && parentObj.getNextGroup(thisObj.seriesIndex);
				if(nextGroup)
				{
					nextGroup.edit(null,null,{select:true, lang:thisObj.lang});
				}
			}

			evt.preventDefault(); //to make sure we don't scroll down on the page

			return false;
		}
		else if(evt.keyCode == Event.KEY_LEFT || evt.keyCode == Event.KEY_RIGHT)
		{
			if(evt.metaKey && Qualtrics.Browser.Gecko)
			{
				//firefox on the mac goes page history which is annoying
				Event.stop(evt);

			}
			if(evt.keyCode == Event.KEY_LEFT)
			{
				if(evt.ctrlKey && !evt.shiftKey)
				{
					//check to see if the function exists
					if(parentObj.getLeft)
					{
						var leftSelection = parentObj.getLeft();
						if(leftSelection)
						{
							leftSelection.edit(null,null,{select:true, lang:thisObj.lang});
							//we only want to prevent this action if there is something to go to
							//there is no point in disabling the left key on choices
							Event.stop(evt);
							return false;
						}
					}
					return true;
				}
				if (parentObj.keyMap && parentObj.keyMap['left'])
				{
					var selectionRange = thisObj.getSelectRange();
					var caretPos = selectionRange.start;

					if ( caretPos == selectionRange.end &&
					     caretPos == 0 &&
					     thisObj.hasCustomKeyMap('left') )
					{
						Event.stop(evt);
						return thisObj.useCustomKeyMap('left', evt);
					}
				}
			}
			else if(evt.keyCode == Event.KEY_RIGHT)
			{
				if (evt.ctrlKey && !evt.shiftKey)
				{
					//check to see if the function exists
					if(parentObj.getRight)
					{
						var rightSelection = parentObj.getRight();
						if(rightSelection)
						{
							rightSelection.edit(null,null,{select:true, lang:thisObj.lang});
							//we only want to prevent this action if there is something to go to
							//there is no point in disabling the right key on choices
							Event.stop(evt);
							return false;
						}
					}
					return true;
				}
				if (parentObj.keyMap && parentObj.keyMap['right'])
				{
					var selectionRange = thisObj.getSelectRange();
					var caretPos = selectionRange.start;

					if ( caretPos == selectionRange.end &&
					     caretPos == thisObj.getValue().length &&
					     thisObj.hasCustomKeyMap('right') )
					{
						Event.stop(evt);
						return thisObj.useCustomKeyMap('right', evt);
					}
				}
			}
		}
		else if(evt.keyCode == Event.KEY_SPACE)
		{
			if(thisObj.editorType == 'textarea')
			{
				//dont allow multiple spaces cause they wont sync up well


				//inputText = inputText.replace(/d/g, 'X');
				var inputText = thisObj.getValue();
				if (inputText.charCodeAt(inputText.length-1) == Event.KEY_SPACE)
				{
					Event.stop(evt);
				}
				//thisObj.setValue('what');
			}
		}
		/* if its not a return key or a bunch of other keys then set it to edited, and add some rough width for the new letter*/

		if(evt.keyCode != Event.KEY_RETURN)
		{
			if(thisObj.isModifyKey(evt))
			{
				var hasSelection = thisObj.element.selectionEnd - thisObj.element.selectionStart;

				//dont let it go beyond the max length
				if (!hasSelection && thisObj.parentObj.maxlength !== undefined && thisObj.getValue().length >= thisObj.parentObj.maxlength)
				{
					if(evt.keyCode != Event.KEY_BACKSPACE && evt.keyCode != Event.KEY_DELETE)
					{
						Event.stop(evt);
						return;
					}
				}
				//the width doesnt change till key up, and thats sometimes too slow,
				//so we need to add our own estimated space for the new letter
				if(!thisObj.parentObj.multiline && (thisObj.editorType != 'div' && !this.updateInner))//div will auto browser resize
				{
					thisObj.estimateEditorWidth();
				}

			}

			//it always saves on keyup, but if they are a fast typer and there is a key down right now and they push tab or something before the last key has up'ed.
			//then they last key will never save because the editor will destroy itself before then.
			//so save it now so we are guaranteed to catched any keys in limbo.
			thisObj.updateText(thisObj.getValue());

			//fresh is a choice that has just been created with an enter stroke, perhaps erroneously, and it needs to be removed
			//if they dont do anything with it
			thisObj.parentObj.fresh = 0;
		}
	},
	doKeyUp:function(evt)
	{
		var thisObj = inlineEditor.getInstance();
		//there are no more repeats because the key is up.
		thisObj.repeatCount = 0;
		if (thisObj.blockKeyUp)
		{
			return;
		}
		if(thisObj.isModifyKey(evt))
		{
			thisObj.updateText(thisObj.getValue());
		}
	},
	/**
	* inlineEditor.isModifyKey
	* returns true if the key press actually changes the content of the field.
	* @param {Event} evt
	*/
	isModifyKey:function(evt)
	{
		if(evt.keyCode != Event.KEY_SHIFT &&
		evt.keyCode != Event.KEY_CTRL &&
		evt.keyCode != Event.KEY_ALT &&
		evt.keyCode != Event.KEY_CAPS &&
		evt.keyCode != Event.KEY_LEFT &&
		evt.keyCode != Event.KEY_RIGHT &&
		evt.keyCode != Event.KEY_UP &&
		evt.keyCode != Event.KEY_DOWN &&
		evt.keyCode != Event.KEY_TAB &&
		evt.keyCode != 224 && //meta
		!evt.ctrlKey && !evt.metaKey
		)
		{
			return true;
		}
		return false;
	},
	doKeyPress:function(evt)
	{
		//safari and ie need return to be keypress if its going to stop the page from submitting
		if (!evt) var evt = window.event;
		var thisObj = inlineEditor.getInstance();

		var parentObj = thisObj.parentObj;
		if(evt.keyCode == Event.KEY_RETURN)
		{
			if ( evt.shiftKey && thisObj.hasCustomKeyMap('shiftEnter') )
			{
				Event.stop(evt);
				return thisObj.useCustomKeyMap('shiftEnter', evt);
			}

			if (thisObj.hasCustomKeyMap('enter') )
			{
				if(!thisObj.parentObj.multiline)
				{
					Event.stop(evt);
				}
				return thisObj.useCustomKeyMap('enter', evt);
			}
			if(thisObj.parentObj.multiline)
			{
				if(window.QuestionActions) {
					//this hardcoded edit section stuff shouldn't really be here - oliverh@qualtrics.com
					//TODO: refactor to be more modular

					//the height is obviously going to shift here cause multiline grows when its edited
					//so rather than wait 2 seconds for the heightwatcher lets just do an instant refresh
					var questionObj = thisObj.parentObj.parentObj;
					questionObj.checkForHeightShift();
				}
			}
			else
			{
				//non multilines have no business hitting enter.
				Event.stop(evt);
			}
		}
		else if(evt.keyCode == Event.KEY_TAB)
		{
			//firefox on the mac takes focus out and starts doing its own tabs without this
			Event.stop(evt);
		}
		else if(thisObj.parentObj.onType) //dont do this for tab and return and all the other useless keys
		{
			if(thisObj.isModifyKey(evt))
			{
				thisObj.parentObj.onType(thisObj, thisObj.seriesIndex, thisObj.lang);
				thisObj.parentObj.changed = true;
			}
		}
		else if(thisObj.isModifyKey(evt))
		{
			//mark the editable as changed.
			thisObj.parentObj.changed = true;
			if(evt.keyCode != Event.KEY_BACKSPACE && evt.keyCode != Event.KEY_DELETE)
			{
				var validChars = thisObj.parentObj.validChars;
				if(typeof validChars == 'string') validChars = new RegExp(validChars);
				if(validChars)
				{
					var code = '';
					if(evt.charCode)
						code = evt.charCode;
					else
						code = evt.keyCode;

					if(code)
					{
						var chr = String.fromCharCode(code);
						if(chr && !chr.match(validChars))
						{
							Event.stop(evt);
						}
					}
				}
			}
		}
	},
	clear:function()
	{
		this.getTextElement().innerHTML = '';
		this.updateText('');
	},
	/**
	* @{String} text - the text you want to insert
	* @{DomNode} position.node - the child node you want to insert within.
	* @{Number} position.offset - this is where you want to insert within position.node.
	*/
	insert:function(text, position)
	{
		var locatorText = "<span id='qtmpinsert'>"+text+"</span>";

		if(this.editorType == 'div')
		{
			if(document.selection)
			{
				//ie, NOTE: the inline editor does not currently support a positioned focus in IE so its just going to go to the end.
				this.focus(position);
				document.selection.createRange().pasteHTML(text);
				//ie is weird. none of this locatorText stuff is going to work, but we also don't need it because the cursor
				//should already be where we want it. exit.

				this.updateText(this.getValue());
				return;
			}
			else
			{
				this.focus(position);

				document.execCommand("InsertHTML",false, locatorText);
			}
		}
		else if(this.editorType == 'iframe')
		{
			//iframe
			if(this.iFrameLoaded)
			{
				this.element.contentDocument.execCommand( 'inserthtml', false, locatorText);
			}
		}
		else if(this.editorType == 'textarea')
		{
			position = position || {};
			var val = this.getValue();
			var firstPos = position.offset !== undefined ? position.offset:val.length;
			var secondPos = position.end || firstPos;
			var first = val.substring(0, firstPos);
			var last = val.substring(secondPos);
			this.setValue(first+text+last);
			this.updateText(this.getValue());
			this.focus({offset:(first+text).length});
			return;
		}
		//we now need to position after the piped text we just inserted
		//I dont know how to get the text node that we just inserted so I have wrapped the text in a span that I can now locate.
		//now we have to replace the span with just the original text.
		var textNode, doc = this.element.contentDocument || document;
		var els = $(this.element).select('#qtmpinsert');
		for (var i = 0; i < els.length; ++i)
		{
			textNode = doc.createTextNode(els[i].innerHTML);
			els[i].parentNode.insertBefore(textNode, els[i]);//insert the real text right before the locator
			$(els[i]).remove();//remove the locator
		}
		if (textNode)
		{
			this.focus({node:textNode, offset:textNode.length});
		}


		if(this.updateInner)
		{
			this.updateDom();
		}
		this.updateText(this.getValue());
		this.updateEditorWidth();

	},
	/**
	* this is when something is dragged and dropped in.
	*/
	doDrop:function()
	{
		var thisObj = inlineEditor.getInstance();
		setTimeout(function(){
			thisObj.updateText(thisObj.getValue());
		}, 100);
	},
	doInput:function()
	{
		var thisObj = inlineEditor.getInstance();
		thisObj.updateDom();
		thisObj.updateText(thisObj.getValue());
		thisObj.updateEditorWidth();
	},
	/**
	* doInputPaste is for browsers that do not support the onpaste events.
	* so we use an oninput event and check the lengths.
	* we use this for the 'parse' feature.  (and it produces a lot of false positives)
	*/
	doInputPaste:function(evt)
	{

		//firefox really needs an onpaste, but we can fake it.
		//IMPORTANT NOTE:  this method produces a lot of false positives. So your paste function needs to not be too destructive.
		//a false paste will be detected when you do anything in the middle of the string.

		var thisObj = inlineEditor.getInstance();

		var oldString = thisObj.lastText;
		var newString = thisObj.getValue();
		var diff = newString.length - oldString.length;
		var pasteDetected = false;
		if(Math.abs(diff) > 1)
		{
			pasteDetected = true;
		}
		else if (diff === 1)
		{
			//its 1 longer than the old string, so this is probably a regular character keystroke,
			//but lets check the first part of it to make sure its the same
			var firstPart = newString.substring(0, newString.length-1);
			if(firstPart !== oldString)
			{
				pasteDetected = true;
			}

		}
		else if (diff === -1)
		{
			//its 1 shorter than the old string, so this is probably a backspace
			//but lets check the first part of it to make sure its the same
			var firstPart = oldString.substring(0, oldString.length-1);
			if(firstPart !== newString)
			{
				pasteDetected = true;
			}
		}
		else if (diff === 0)
		{
			//this could be an arrow key or something
			//so lets check to see if the 2 strings are the same
			if(oldString !== newString)
			{
				pasteDetected = true;
			}
		}
		if(pasteDetected)
		{
			thisObj.doPaste(evt);
		}
		thisObj.lastText = newString;
	},
	/**
	* doPaste is called on an onPaste event and an onInput event that has been filtered to resemble a paste
	*/
	doPaste:function()
	{
		var thisObj = inlineEditor.getInstance();
		if (thisObj.repeatCount > 0)
		{
			thisObj.blockKeyUp = true;
		}

		if (this.parentObj && this.parentObj.onChange)
		{
			this.parentObj.onChange();
		}

		thisObj.doParse.bind(thisObj).defer();
	},
	/**
	* realPaste
	* this gets run ONLY on browsers that support the onPaste command natively (no firefox 2)
	* so on the parent you can have an onPaste feature and a parse feature. the parse will get run universally (with some false positives)
	* and the onPaste will get run only on the native onPaste browsers. so keep degradation in mind when writing with these features.
	*/
	realPaste:function(evt)
	{
		var thisObj = inlineEditor.getInstance();
		var oldVal = thisObj.getValue();
		if(thisObj && thisObj.editorType != 'textarea')
		{
			if(thisObj.parentObj.onPaste)
			{
				thisObj.parentObj.onPaste.bind(thisObj.parentObj).defer(thisObj, oldVal);
			}
		}
		//run the parser.
		thisObj.doPaste(evt);
	},
	/**
	* runs a parse from the parentObj if it exists.
	*/
	doParse:function()
	{
		var thisObj = inlineEditor.getInstance();
		if(thisObj)
		{
			if(thisObj.parentObj.parse && thisObj.parentObj.parse(thisObj.getValue(), thisObj.seriesIndex, thisObj.lang))
			{
				return;
			}
			//if there is no parse function or parse result then just update as normal
			thisObj.updateText(thisObj.getValue());
		}
	},
	/**
	* getTextElement - abstraction to get text elements for iframes, divs, and textareas
	* frame must return the inner *BODY* element
	* @return node - the part of the editor that contains the text
	*/
	getTextElement:function()
	{
		if(this.editorType == 'iframe')
		{
			if(this.element.contentDocument)
			{
				var doc = this.element.contentDocument;
				if(doc)
				{
					var bod = doc.getElementsByTagName('body')[0];
					return bod;
				}
			}
		}
		else if(this.editorType == 'div')
		{
			if(this.element)
				return this.element.firstChild;
		}
		else if(this.editorType == 'textarea')
		{
			return this.element;
		}
		else if(this.editorType == 'fck')
		{
			if(this.element)
				return this.element.firstChild;
		}
		return false;
	},
	getEventElement:function()
	{
		//abstraction to get text elements for iframes, divs, and textareas
		//iframe must return the inner *DOCUMENT* for events to be attached to
		if(this.editorType == 'iframe')
		{
			if(this.element && this.element.contentDocument)
			{
				return this.element.contentDocument;
			}
		}
		return this.element;
	},
	getValue:function()
	{
		if(this.element)
		{
			if(this.editorType == 'div')
			{
				var text = this.getTextElement().innerHTML;

				// remove the trailing br tag that contenteditable divs sometimes like to append
				if (text.slice(-4) == '<br>')
					text = text.slice(0,-4);

				return text;
			}
			else if(this.editorType == 'iframe')
			{
				if (this.iFrameLoaded)
				{
					return this.getTextElement().innerHTML;
				}
				//just give the parent back what it gave us since it never loaded the iframe.
				if(this.parentObj.getText)
				{
					return this.parentObj.getText();
				}
			}
			else if(this.editorType == 'fck')
			{
				if (this.fck)
				{
					//TODO: fix this
					if (this.fck.getData)
					{
						var data = this.fck.getData();
					}
					//the fck has a timeout on its updater to help ie6
					//but we dont want to return data from the fck while its in the middle of updating.
					if (data !== null && !this.fck.updating)
					{
						return data;
					}
				}
				//the fck isnt ready yet, but we have that text area.
				if (this.parentObj.getText)
				{
					return this.parentObj.getText();
				}
				else
				{
					return this.getTextElement().innerHTML;
				}

			}
			else
			{
				return this.getTextElement().value;
			}

		}

		return null;
	},
	getPlainTextValue:function()
	{
		var val = this.getValue();

		if(val != undefined)
		{
			return val.stripTags();
		}
		return "";
	},
	setValue:function(v)
	{
		if(this.editorType == 'textarea')
		{
			this.getTextElement().value = String(v);
		}
		else
		{
			this.getTextElement().innerHTML = String(v);
		}
	},
	setDocumentClickObserver:function()
	{
		var that = this;
		//this removes the editor if they click anywhere
		that.documentClickObserver = that.removeByDocumentClick.bindAsEventListener(that);
		Event.observe(document, 'mousedown', that.documentClickObserver);
	},
	removeDocumentClickObserver:function()
	{
		Event.stopObserving(document, 'mousedown', this.documentClickObserver);
	},
	removeByDocumentClick:function(evt)
	{

		if(this.element) //could have already been removed by something else
		{
			//now on to the real removing
			if(Event.isLeftClick(evt))
			{
				if(this.skipAnEvent)
				{
					this.skipAnEvent = false;
					return;
				}
				//this checks to see what they are actually clicking on, and if its an editor we dont want it to go away
				var clickedEl = Event.element(evt);
				var parent = clickedEl.parentNode;
				if(clickedEl.getAttribute('keepeditoropen')){
					return;
				}
				if(clickedEl.getAttribute('keepeditoropenforever')){
					//this is dangerous, you are now responsible for unsetting this at some point.
					this.keepOpen = true;
					return;
				}
				if(clickedEl.id == 'InlineEditorElement')
				{
					return;
				}
				//we need this one as well because the inline editor might have children tags that wont have that id.
				var iswithin = (Position.within(this.element, mousePos[0], mousePos[1]));

				if(!iswithin)
				{
					//always remove the editor

					//they might be in the fck and also might be clicking on the scroll bar so hide the overlay.
					if(this.editorType == 'fck')
					{
						//only close the inline and fck editor if the overlay itself is clicked on.
						var overlayId = this.overlayObj && this.overlayObj._id;
						if(overlayId)
						{
							if ($(clickedEl).id == overlayId)
							{
								this.overlayObj.remove();
							}
							else
							{
								return;
							}
						}
					}

					var removed = this.removeInlineEditor({evt:evt});
					if(removed === false)
					{
						//the editor was NOT removed for some reason so lets exit.
						return;
					}


					//help ie do its job by focusing what they clicked on.
					if(clickedEl && clickedEl.nodeName == 'INPUT' && !clickedEl.disabled)
					{
						Form.Element.focus(clickedEl);  //focusing the event target solves a really weird IE bug where switching directly to another text box (spin edit box) doesn't direct events targets to the new textbox. see bug #14092
					}
					clickedEl = null;
				}
			}
		}
	},
	getHeight:function()
	{
		return this.height;
	},
	/**
	 * inlineEditor.getTotalPaddingWidth
	 * @return {Number} the sum of the left and right borders and padding in pixels
	 **/
	getTotalPaddingWidth:function()
	{
		return this.padding[1]+this.padding[3]+this.borderWidth[1]+this.borderWidth[3];
	},
	/**
	 * inlineEditor.getTotalPaddingHeight
	 * @return {Number} the sum of the top and bottom borders and padding in pixels
	 **/
	getTotalPaddingHeight:function()
	{
		return this.padding[0]+this.padding[2]+this.borderWidth[0]+this.borderWidth[2];
	},
	updateEditorWidth:function()
	{
		var oldWidth = this.width;
		var oldHeight = this.height;
		if(this.editorType == 'div' && !this.updateInner)
		{
			//divs auto adjust in the browser so all we need to do is set mins and maxes
			var choiceWidth = this.getInner().offsetWidth;
			$(this.element).setStyle({
				minWidth:(choiceWidth)+'px'
			});
			var choiceHeight = this.getInner().offsetHeight;
			var el = this.getTextElement();
			$(el).setStyle({
				minHeight:(choiceHeight)+'px'
			});
			if(this.parentObj.getMinWidth)
			{
				$(el).setStyle({
					minWidth:(this.parentObj.getMinWidth())+'px'
				});
			}
			if(this.parentObj.getMinHeight)
			{
				$(el).setStyle({
					minHeight:(this.parentObj.getMinHeight())+'px'
				});
			}
			if(this.parentObj.getMaxWidth)
			{
				$(el).setStyle({
					maxWidth:(this.parentObj.getMaxWidth())+'px'
				});
			}
			if(this.parentObj.getMaxHeight)
			{
				$(el).setStyle({
					maxHeight:(this.parentObj.getMaxHeight())+'px'
				});
			}
			this.width = el.offsetWidth;
			this.height = el.offsetHeight;
		}
		else
		{
			var existingEditorPaddingWidth = this.getTotalPaddingWidth();
			var existingEditorPaddingHeight = this.getTotalPaddingHeight();
			if(this.parentObj.getDimensions)
			{
				//override the auto dimention calculation with numbers from the parent
				var dims = this.parentObj.getDimensions();
				if(dims && (dims.width || dims.height))
				{
					if(dims.width)
					{
						$(this.element).setStyle({
							width:(dims.width-existingEditorPaddingWidth)+'px'
						});
					}
					if(dims.height)
					{
						$(this.element).setStyle({
							height:(dims.height-existingEditorPaddingHeight)+'px'
						});
					}
					return;
				}
			}

			choiceWidth = this.getInner().offsetWidth;
			choiceHeight = this.getInner().offsetHeight;

			if (choiceHeight == 0)
				choiceHeight = this.lastChoiceHeight;
			else
				this.lastChoiceHeight = choiceHeight;


			var inputLeftPadding = this.getInputLeftPadding();

			//we need to add enough space for a next letter, so the input doesnt scroll around for a second on a new letter
			var nextLetterWidth = 10;
			if(this.parentObj.getNextLetterWidth)
			{
				nextLetterWidth = this.parentObj.getNextLetterWidth();
			}

			//a space wont make the input box longer cause of the way spaces are handled in html
			//so we need to detect it and adjust manually

			var inputText = this.getValue();
			if(inputText != undefined)
			{

				if(inputText.charCodeAt(inputText.length-1) == Event.KEY_SPACE)
				{
					nextLetterWidth += 10;
				}
				//ie has a really weird bug where it puts in the background color into the question text html when i change the color
				//but it happens to not be needed for multiline(question text) editors.
				if(!this.parentObj.multiline)
				{
					if(inputText != undefined && inputText.length === 0)
					{
						$(this.element).addClassName('WillBeDeleted');
					}else{
						$(this.element).removeClassName('WillBeDeleted');
					}
				}
				if(Qualtrics.Browser.WebKit)
				{
					choiceWidth = (choiceWidth + 10);
				}

				this.width = (choiceWidth - (inputLeftPadding*2)+nextLetterWidth);

				if(inputText.length > 0 && !this.parentObj.multiline)
				{
					choiceHeight = $(this.getInner()).offsetHeight;
					this.width = $(this.getInner()).offsetWidth + nextLetterWidth;
				}

				$(this.element).setStyle({
					width:this.width+'px'
				});

				var additionalLines = (function(searchStr, str) {
					var startIndex = 0, searchStrLen = searchStr.length;
					var index, indices = 0;
					while ((index = str.indexOf(searchStr, startIndex)) > -1) {
						indices++;
						startIndex = index + searchStrLen;
					}
					return indices;
				})('\n', inputText);

				// font size is bigger in translate section.
			    if (Qualtrics.Translate)
				{
					var lineHeight = 19;
				}
				else
				{
					lineHeight = 13;
				}
				choiceHeight += additionalLines * lineHeight + 2;
				choiceHeight = (choiceHeight < lineHeight) ? lineHeight : choiceHeight;

				if(!this.codeViewMode)
				{
					$(this.element).setStyle({
						height: choiceHeight+'px'
					});
				}


				var newHeight = choiceHeight + existingEditorPaddingHeight;
				if(this.height && newHeight != this.height)
				{
					//if the height has changed there is a change the position might need to change also (matrix scale points);
					this.updateEditorPosition();
				}
				this.height = newHeight;

			}
		}
		this.updateButtonPosition();

		if(this.parentObj.multiline)
		{
			//set the options position to the top right
			var optionsHeight = 18;
			if(this.optionsElement)
			{
				$(this.optionsElement).setStyle({
					left:this.left+'px',
					top:(this.top-optionsHeight) + 'px',
						width:this.width + (inputLeftPadding*2) + 'px'
				});
			}
		}
		if(this.parentObj.onUpdate)
		{
			this.parentObj.onUpdate(this);
		}
		if((oldHeight || oldWidth) && (this.height != oldHeight || this.width != oldWidth))
		{
			if(this.parentObj.onDimensionChange)
			{
				this.parentObj.onDimensionChange(this.width, this.height);
			}
		}
	},
	updateFCKPosition:function(ev)
	{
		//make sure that the editor is loaded before we start acting on it
		//it should be because this is run on the instanceReady event
		if(ev.editor && ev.editor._ && ev.editor._.cke_contents && ev.editor._.cke_contents.$)
		{


			$('fckStorageUnit').setStyle({zIndex:'12000', display:'block'});
			//update its position
			var top = this.top;
			var left = this.left;

			//find the toolbar
			var contents = ev.editor._.cke_contents.$;
			var toolbar = $(contents).up().previous();
			if(toolbar)
			{
				//position the ckeditor up so the bottom of the toolbar is flush with the top of the parent
				top -= toolbar.offsetHeight;
			}
			$('fckStorageUnit').setStyle({position:'absolute', top:top+'px',left:left+'px'});
		}
	//	console.dir(this.fck['_'])
	},
	updateButtonPosition:function(opt_width)
	{
		if(this.menuButtonElement)
		{
			//set the menu position to the right side
			var optionsHeight = 19;
			var textBoxPadding = 8;
			if(this.menuButtonElement)
			{
				$(this.menuButtonElement).setStyle({
					left:(this.left+(opt_width || this.width)+textBoxPadding)+'px',
					top:(this.top)+'px'
				});
			}
		}
	},
	estimateEditorWidth:function()
	{
		var estimatedWidth = $(this.element).offsetWidth;

		$(this.element).setStyle({
			width:(estimatedWidth)+'px'
		});
		this.updateButtonPosition(estimatedWidth);
	},
	/**
	* updates the inline editor position.
	*/
	updateEditorPosition:function()
	{
		this.top = undefined;
		this.left = undefined;
		var pos = undefined;
		if(this.parentObj.getPosition)
		{
			//override the position calculation with numbers from the parent
			pos = this.parentObj.getPosition();
			if(pos && (pos.top !== undefined || pos.left !== undefined))
			{
				this.top = pos.top;
				this.left = pos.left;
			}
		}
		if(this.top == undefined || this.left == undefined)
		{
			//try to figure out the position based on the node returned by getInner()
			var element = this.getInner();
			if(element)
			{
				//we need to know if we are inside any weird scrolling divs.
				//so we get a cumulative scroll offset of anything that is scrolled except for the window scroll.
				var scrollElement = element;
				var scrollOffset = [0,0];
				do {

					if(scrollElement.nodeName !== 'HTML' && scrollElement.nodeName !== 'BODY')
					{
						scrollOffset[0] += scrollElement.scrollLeft || 0;
						scrollOffset[1] += scrollElement.scrollTop  || 0;
					}
					scrollElement = scrollElement.parentNode;
				} while (scrollElement);

				pos = Position.cumulativeOffset(element);

				pos[0] -= scrollOffset[0];
				pos[1] -= scrollOffset[1];
				pos = Q_Window.preparePos(pos);

				var leftOffset = this.getLeftOffset(); //padding + border width on our editor

				var vOffset = -2;
				if(Qualtrics.Browser.IE)
				{
					vOffset = 0;
					leftOffset += 2;
				}
				if(Qualtrics.Browser.Safari && Qualtrics.Browser.Version < 530)
				{
					leftOffset += 3;
					//safari has a bug where it doesnt figure the valign into the cumulative offset
					//so we have to offset it ourselves.
					//note that this is a *SAFARI* bug, not a webkit bug.
					//****As of Safari 4.0.5 (more likely earlier) this bug has been fixed.
					//****Also, in Chrome the above check for Qualtrics.Browser.Safari returns true,
					//****so we have to be careful.
					if(this.vAlign && this.vAlign == 'middle')
					{
						if(this.height)
						{
							var parentHeight = element && element.parentNode.offsetHeight;
							if(parentHeight)
							{
								vOffset += (parentHeight / 2) - (this.height / 2);
							}
						}
					}
				}
				this.left = pos[0] - leftOffset + 1;
				this.top = pos[1] + vOffset - 1;

				//firefox chops the top off the window in q_windows to prevent people from scrolling.
				//and so we need to account for that sometimes.
			}
		}
		if(this.element)
		{
			$(this.element).setStyle({
				left:this.left+'px',
				top:this.top+'px'
			});
		}
	},
	getRightOffset:function()
	{
		//this is to prevent question text from overlapping the add buttons
		var rightOffset = 0;
		if(this.parentObj.rightOffset != undefined)
		{
			rightOffset = this.parentObj.rightOffset;
		}
		return rightOffset;
	},
	getLeftOffset:function()
	{
		if(this.parentObj.getLeftOffset)
		{
			return this.parentObj.getLeftOffset();
		}
		else
		{
			//this is for the padding that we add.
			if(this.align == 'center')
			{
				return 6; //dont know
			}
			return this.padding[3] + this.borderWidth[3];
		}
	},
	getInputLeftPadding:function()
	{
		var padding = $(this.getInner()).getStyle('paddingLeft');
		padding = padding.substr(0, padding.indexOf('px'));

		return Number(padding);
	},
	checkPositionShift:function()
	{
		if(this.align && this.align !== 'left')
		{
			//if it isnt aligned left then its going to always be shifting around
			//depending on how big the text is
			//so we need to update the position everytime.
			this.updateEditorPosition();
			this.updateEditorWidth();
			return;
		}
		/* this uses quick offsetTops to check if the object has shifted while editing for some reason
		if it has we will reposition the editor to match it*/
		var el = $(this.parentObj.id);
		if(el)
		{
			var parent = el.parentNode;
			var quickTop = el.offsetTop + parent.offsetTop;
			var quickLeft = el.offsetLeft + parent.offsetLeft;
			if(this.positionShiftTriggers[0] != quickLeft || this.positionShiftTriggers[1] != quickTop)
			{
				this.updateEditorPosition();
				this.updateEditorWidth();
			}
			//set the positionshift triggers to the new position for next time
			this.positionShiftTriggers[0] = quickLeft;
			this.positionShiftTriggers[1] = quickTop;
		}
	},
	/**
	* updateDom will change the dom to match whatever is passed in 'text'
	* it will do html escaping so it is like the text in the editor, while its being edited
	* updateDom is called by updateText, and on initialize.
	* @param {String} text - the text
	* @param {Boolean} opt_forceUpdate - if true, will not worry about delaying if its too fast.
	* @param {Boolean} opt_updatePosition - if false will not update position and width, this is just to save cpu cycles when it isnt helpful.
	*/
	updateDom:function(text, opt_forceUpdate, opt_updatePosition)
	{
		var display = text || this.parentObj.getText(this.seriesIndex, this.lang);
		var safeDisplay = QualtricsTools.filterForDisplay(display);
		var domNode = this.getInner();

		if(domNode)
		{
			if(!this.parentObj.html)
			{
				//if its code view then we should have whitespace:pre on the cachedInner.
				//except that it wont work in ie because ie wont recognize a \n in when using innerHTML,
				//but it works out fine because we don't need innerHTML cause we are working with just code.
				//so we just throw the text right in without any html parsing.

				//Note: webkit will leave the highlight when you clear the node with innerHTML = '' so we use a whitespace char which is ignored in html
				domNode.innerHTML = ' ';
				domNode.appendChild(document.createTextNode(display || ' '));
				if(Qualtrics.Browser.WebKit)
				{
					//OK get ready for a crazy hack. In webkit if you have a block level element within an inline element eg. <label><div>hi</div><label>
					//label.offsetWidth gets reported as 0 for the rest of time. even after you get rid of the block level element (we have escaped it)
					// so we "reset" it by setting it to display=block, then calling its width so it figures it out, and then setting it back to inline.
					var oldDisplay = domNode.style.display;
					if(oldDisplay == 'inline')
					{
						domNode.style.display = 'block';
						domNode.offsetWidth; //remind webkit that it should have a new width now. it must be cached or something.
						domNode.style.display = oldDisplay;
					}
				}
			}
			else
			{
				if(safeDisplay !== undefined && safeDisplay.stripScripts && safeDisplay.stripScripts() == '')
				{
					//make sure there is room to type something new. (the way that it can be empty is if all they have is a script tag)
					safeDisplay += '<br />';
				}

				//everything else will just create html out of the display
				domNode.innerHTML = safeDisplay;
			}
			if(opt_updatePosition !== false)
			{
				this.updateEditorWidth();
				this.checkPositionShift();
			}
		}
		this.updateRemoveFormattingButton(text);
		domNode = null;
	},
	/**
	* updateText will change the text on the thing that we are editing
	* it will do html escaping so it is like the text in the editor, while its being edited
	* updateText is ONLY USED WHILE ITS BEING EDITED.
	* @param {String} text - the text
	* @param {Boolean} opt_forceUpdate - if true, will not worry about delaying if its too fast.
	* @param {Boolean} opt_updatePosition - if false will not update position and width, this is just to save cpu cycles when it isnt helpful.
	*/
	updateText:function(text, opt_forceUpdate, opt_updatePosition)
	{
		text = String(text);

		if(text.length > 20000)
		{
			alert('You have exceeded the size limit. Please reduce your text');
			return;
		}
		else if (this.parentObj.maxlength)
		{
			text = text.substr(0, this.parentObj.maxlength);
		}

		//first we need to check it for new lines
		//if there are new lines that means they are pasting and we need to split
		//the lines up into separate choices


		//this has internal throttling to only let it run every 300 milliseconds
		//cause it really slows down text entry on IE6 and firefox 1.5.
		//Its confusing but it works, and it really speeds up text entry.
		var now = new Date();
		if(!opt_forceUpdate && this.lastUpdateTime && this.lastUpdateTime > now-300)
		{
			//even though we  aren't updating, we need to set the entered text so that it saves correctly
			this.parentObj.setText(text, this.seriesIndex, this.lang);
			//we aren't going to execute right now due to fast typing
			//but we do need to run the function eventually in case this is the last key they push.

			this.delayedUpdateText(text);
			return;
		}
		//cancel any previous delays. cause this now doing a real time non throttled update.
		this.cancelDelayedUpdateText();
		this.lastUpdateTime = now;


		this.parentObj.setText(text, this.seriesIndex, this.lang);

		//make the dom match the new text. this is what makes the editor grow and shrink with the new text in realtime.
		if(this.updateInner)
		{
			this.updateDom(text, opt_forceUpdate, opt_updatePosition);
		}

		if(this.parentObj && this.parentObj.parentObj && this.parentObj.parentObj.setEdited)
		{
			//this is stupid, parent should delegate -Oliver
			this.parentObj.parentObj.setEdited(1);
		}
		if (this.parentObj && this.parentObj.setEdited && !this.parentObj.isDefault)
		{
			this.parentObj.setEdited(1);
		}
	},
	/**
	* delayedUpdateText will keep pushing back the update time each time that it is called
	* it is used by updateText to eventually execute its last throttled command
	*/
	delayedUpdateText:function(text)
	{
		if(this.updateTextDelay)
		{
			clearTimeout(this.updateTextDelay);
		}
		var that = this;
		this.updateTextDelay = setTimeout(function(){
			that.updateTextDelay = null;
			that.updateText(text);

		},0.4);
	},
	/**
	* cancels the delayed update text.
	* this is used by updateText when it executes a non throttled command.
	* because we dont want to update the last delayed text after the subsequent non throttled text has been
	* succesfully updated.
	*/
	cancelDelayedUpdateText:function()
	{
		if(this.updateTextDelay)
		{
			clearTimeout(this.updateTextDelay);
			this.updateTextDelay = null;
		}
	},
	finishEdit:function()
	{
		if(this.parentObj)
		{
			this.getInner().innerHTML = QualtricsTools.filterForDisplay(this.parentObj.getText(this.seriesIndex, this.lang));
			this.updateEditorWidth();
		}
	},
	isEmpty:function()
	{
		var val = this.getValue();
		if(trim(this.getPlainTextValue()).length === 0
			&& val.indexOf('img') == -1
			&& val.indexOf('embed') == -1
			&& val.indexOf('object') == -1
			&& val.indexOf('iframe') == -1)
		{
			return true;
		}
		return false;
	},
	removeInlineEditor:function(options)
	{
		//the trick here is that because there is only ever 1 inlineEditorObj
		//it is yet to be replaced by the new one at the time of the initialize function calling this.
		//so inlineEditorObj is still the old one if there is an old one

		//in other words:
		//	*inlineEditorObj* is the old one.
		//	*this* is the current one.

		var inlineEditorObj = inlineEditor.getInstance();
		options = options || {};
		if(inlineEditorObj)
		{
			if(inlineEditorObj.parentObj.beforeClose)
			{
				if(Qualtrics.Event.execute(inlineEditorObj.parentObj.beforeClose, [options], inlineEditorObj.parentObj) === false)
				{
					return false;
				}
			}
			if(inlineEditorObj.keepOpen)
			{
				//we aren't allowed to close this yet.
				return false;
			}

			var val = inlineEditorObj.getValue();
			val = val.strip();


			//make sure they havent snuck any super long strings in
			if(inlineEditorObj.parentObj.maxlength !== undefined && inlineEditorObj.getValue().length >= inlineEditorObj.parentObj.maxlength)
			{
				inlineEditorObj.setValue(inlineEditorObj.getValue().truncate(inlineEditorObj.parentObj.maxlength));
			}
			//one last update incase they are doing some crazy fast typing/clicking. the true will force an update even if its too fast.
			if(val)
			{
				//set codeView to false so that the parent text is converted back from showing code.
				inlineEditorObj.codeViewMode = false;
				var changed = inlineEditorObj.parentObj && inlineEditorObj.parentObj.changed || inlineEditorObj.parentObj.originalText && inlineEditorObj.parentObj.originalText != inlineEditorObj.parentObj.getText(inlineEditorObj.seriesIndex, inlineEditorObj.lang);
				if(changed || this.editorType == 'fck')
				{
					//the text was changed in the inlineEditor so lets set changed on the object and make sure our text was accurately set.
					inlineEditorObj.parentObj.changed = true;
					inlineEditorObj.updateText(val,true, false);
				}
				else
				{
					//we will update the dom one last time without calling setText on the underlying object
					inlineEditorObj.updateDom(val,true, false);
				}
			}

			//make sure there are no more timeouts scheduled to happen.
			inlineEditorObj.cancelDelayedUpdateText();
			//get rid of the pre whitespace on the parent if neccessary. this is for code view mode.
			if(inlineEditorObj.parentObj.multiline && !inlineEditorObj.parentObj.html)
			{
				$(inlineEditorObj.cachedInner).setStyle({'whiteSpace':''});
			}

			if ((inlineEditorObj.editorType == 'textarea') || (inlineEditorObj.editorType == 'fck') )
			{
				//sanitizeText has converted our underlying object into entities so we have to switch it back before the user sees it and gets angry.
				var inner = inlineEditorObj.getInner(inlineEditorObj.seriesIndex, inlineEditorObj.lang);
				if(inner)
				{
					if (inlineEditorObj.editorType == 'textarea') {
						inner.innerHTML = '';
						inner.appendChild(document.createTextNode(inlineEditorObj.parentObj.getText(inlineEditorObj.seriesIndex, inlineEditorObj.lang)));
					} else {
						inner.innerHTML = QualtricsTools.filterForDisplay(inlineEditorObj.parentObj.getText(inlineEditorObj.seriesIndex, inlineEditorObj.lang));
					}
				}
			}

			//remove the options events
			var optionsNode = inlineEditorObj.optionsElement;
			var menuButtonNode = inlineEditorObj.menuButtonElement;
			if(optionsNode)
			{
				//remove the options events
				optionsNode.onmouseover = null;
				optionsNode.onmouseout = null;
				optionsNode.onclick = null;
				optionsNode.onmousedown = null;
				optionsNode.onmouseup = null;
			}
			if(menuButtonNode)
			{
				menuButtonNode.onmouseover = null;
				menuButtonNode.onclick = null;
				menuButtonNode.onmouseout = null;
				menuButtonNode.onmousedown = null;
				menuButtonNode.onmouseup = null;

			}

			optionsNode = null;
			menuButtonNode = null;

			//remove the key events
			var eventElement = inlineEditorObj.getEventElement();
			if(eventElement)
			{
				if(eventElement.detachEvent)
				{
					//ie
					eventElement.detachEvent('onkeydown',inlineEditorObj.doKeyDown,false);
					eventElement.detachEvent('onkeyup',inlineEditorObj.doKeyUp,false);
					eventElement.detachEvent('onkeypress',inlineEditorObj.doKeyPress,false);
					eventElement.detachEvent('onpaste',inlineEditorObj.realPaste,false);
					eventElement.detachEvent('input',inlineEditorObj.doInput,false);
				}
				else
				{
					//others
					eventElement.removeEventListener('keydown',inlineEditorObj.doKeyDown,false);
					eventElement.removeEventListener('keyup',inlineEditorObj.doKeyUp,false);
					eventElement.removeEventListener('keypress',inlineEditorObj.doKeyPress,false);
					eventElement.removeEventListener('input',inlineEditorObj.doInput,false);

					if (Qualtrics.Browser.Features.onPaste)
					{
						eventElement.removeEventListener('paste',inlineEditorObj.realPaste,false);
					}
					else
					{
						eventElement.removeEventListener('input',inlineEditorObj.doInputPaste,false);
					}

				}

			}

			if(inlineEditorObj.getPlainTextValue() != undefined)
			{
				if(inlineEditorObj.isEmpty())
				{
					//if its empty they probably want to do something with it
					//so lets go ahead and call a function.
					if(inlineEditorObj.parentObj.onEmpty && !options.transitional && !options.clean)
					{
						inlineEditorObj.parentObj.onEmpty(inlineEditorObj.seriesIndex, inlineEditorObj.lang);
					}
				}
			}
			//unlink the objects references to them them, and then kill the dom elements.
			var editorEl = $(inlineEditorObj.element);
			inlineEditorObj.element = null;

			if(editorEl)
			{
				editorEl.blur(); //IE7 flips out if you try to remove an element that is selected sometimes. see bug #87783
				removeElement(editorEl);
			}

			var optionsEl = $(inlineEditorObj.optionsElement);
			inlineEditorObj.optionsElement = null;
			if(optionsEl)
			{
				if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 8)
				{
					removeElement.curry(optionsEl).defer();//without defer ie7 like to scroll to the bottom #85775
				}
				else
				{
					//normal browsers
					removeElement(optionsEl);
				}
			}

			//remove the menu button
			var menuEl = $(inlineEditorObj.menuButtonElement);

			inlineEditorObj.menuButtonElement = null;
			if(menuEl)
			{
				removeElement(menuEl);
			}

			inlineEditorObj.removeDocumentClickObserver();
			inlineEditorObj.documentClickObserver = null;

			if(inlineEditorObj.parentObj)
			{
				inlineEditorObj.parentObj.editing = 0;
			}

			if(inlineEditorObj.parentObj && $(inlineEditorObj.parentObj.id))
			{
				$(inlineEditorObj.parentObj.id).removeClassName('Editing');
			}

			if(inlineEditorObj.parentObj && inlineEditorObj.parentObj._afterEdit)
			{
				inlineEditorObj.parentObj._afterEdit.call(inlineEditorObj.parentObj, inlineEditorObj, inlineEditorObj.seriesIndex, inlineEditorObj.lang);
			}

			//check for an after edit callback
			if(inlineEditorObj.parentObj && inlineEditorObj.parentObj.afterEdit)
			{
				//call the after edit function with the parentObj as *this*
				//and the editor as the first param.
				inlineEditorObj.parentObj.afterEdit.call(inlineEditorObj.parentObj, inlineEditorObj, inlineEditorObj.seriesIndex, inlineEditorObj.lang);
			}

			if(inlineEditorObj.editorType == 'fck')
			{
				if(inlineEditorObj.fck)
				{
					inlineEditorObj.fck.destroy();
				}

				if($('fckStorageUnit'))
				{
					$('fckStorageUnit').remove();
				}
			}
			inlineEditorObj.parentObj.changed = false;//set it back to false so we can check it next time
			inlineEditorObj.cachedInner = null;
			inlineEditorObj = null;
			inlineEditor.instance = null;
			inlineEditor.fck = null;
		}
		//remove exited successfully
		return true;
	}
});
var inlineEditor_lastParentObj = null; //this keeps the last object that was edited around forever. it is kind of a hack to let menus get info from the inlineEditor which has just been removed.
Object.extend(inlineEditor, {
	instance:null,
	getInstance:function()
	{
		return inlineEditor.instance;
	},
	/**
	* inlineEditor.clear
	* a static shortcut function to quickly get rid of any inline editor on the page.
	*/
	clear:function()
	{
		if(inlineEditor.getInstance())
		{
			inlineEditor.getInstance().removeInlineEditor();
		}
	},
	allowClose:function()
	{
		if(inlineEditor.getInstance())
		{
			inlineEditor.getInstance().allowClose();
		}
	},
	keepEditorOpen:function()
	{
		if(inlineEditor.getInstance())
		{
			inlineEditor.getInstance().keepEditorOpen();
		}
	}
});

/* - - - - - - - - - - - - -

    Editable Class
    You can extend this class to make a more complex editable object.
    Or you can use this one directly. You can also bind a variable to your text.

- - - - - - - - - - - - - - -*/
var Editable = Class.create({
	objType:'',
	text:'',
	id:null, //this is the id of our "inner", (can also be an element)
	bindedParentObj:null,
	edited:0,
	bindedName:null,
	originalText:null, //set by inlineEditor init,
	keyMap:{enter:'onEnter'},
	changed:false,//this keeps track of if they have actually typed anything in. as opposed to just opening and closing it.
	forcedSeriesIndex:null,
	validChars:null,
    /**
	* @param {Mixed} idOrElement - can be an id string or a dom node directly if you dont have an id. this is the html thing we are editing.
	* @param {Object} opt_parentObj - used with opt_variableToBind. this is the object that contains your binded variable.
	* @param {String} opt_variableToBind - pass the name of a variable on the parentObj to bind the variable to whatever the edited text is.
	* @param {String} opt_optionsObjectName - you can give the name of a static object with properties that you would like the editor to inherit. eg. keyMap.
	*/
	initialize:function(idOrElement, opt_bindedParentObj,  opt_variableToBind, opt_optionsObjectName)
	{
		//NOTE: keep in mind that this initialize is not always run. sometimes it is extended and replaced.
		//if there is no id then something is probably just extending this. so we dont want to init.
		this.languages = {};
		if(idOrElement)
		{
			this.bindedParentObj = opt_bindedParentObj;
			if(typeof idOrElement == 'string')
			{
				this.id = idOrElement;
				this.domNode = $(this.id);
			}
			else
			{
				this.id = QualtricsCPTools.createNewId('E');
				this.domNode = idOrElement;
			}

			//init the text variable automatically.
			if(this.getInner())
			{
				this.text = this.getInner().innerHTML;
			}
			if(opt_variableToBind != null)
			{
				this.bindedName = opt_variableToBind;
			}
			if(opt_optionsObjectName)
			{
				if(typeof opt_optionsObjectName == 'string') opt_optionsObjectName = window[opt_optionsObjectName];
				Object.extend(this, opt_optionsObjectName);
			}
		}
	},
	onEnter:function(opt_editorObj)
	{
		if(!this.multiline)
		{
			if (typeof this.close != 'undefined')
			{
				this.close();
			}
			else if(opt_editorObj)
			{
				opt_editorObj.removeInlineEditor();
			}
			return false;
		}
	},
	/**
	* Editable.edit:
	* edits the editable
	* inits a new inlineEditor object with the event the options.
	* @ param {event} event - if this is called on a mouse down, then this is required.
	* @param {Object | undefined} options -
	* @return {inlineEditor} the inlineEditor object
	*/
	edit:function(event, options)
	{
		options = options || {};
		options.evt = event; //options.evt should have a click event if it was clicked!!!
		var e = new inlineEditor(this, options);
		return e;
	},
	updateBinded:function()
	{
		if(this.bindedName !== null && this.bindedParentObj)
		{
			if(this.bindedParentObj[this.bindedName] && typeof this.bindedParentObj[this.bindedName] == 'function')
			{
				//its a function so we are going to call it with the val as the first param
				this.bindedParentObj[this.bindedName](this.text);
			}
			else
			{
				//we are just going to set it as if it were a string (even if it doesnt exist)
				this.bindedParentObj[this.bindedName] = this.text;
			}
		}
	},
	onEmpty:function(seriesIndex, lang)
	{
		//revert to the original text.
		this.revert();
	},
	revert:function(seriesIndex, lang)
	{
		if(inlineEditor.getInstance())
		{
			inlineEditor.getInstance().updateText(this.originalText, true);
			//set the text of this which will also set the binded variable.
			this.setText(this.originalText);
		}
	},
	getEdited:function()
	{
		return this.edited;
	},
	setEdited:function(v)
	{
		this.edited = v;
	},
	getText:function()
	{
		return this.text.unescapeHTML();
	},
	setText:function(v)
	{
		this.text = v;
		this.updateBinded();
	},
	getInner:function()
	{
		return this.domNode || $(this.id); //fall back to getElementById for classes that might have overriden the initialize method and dont have a domNode.
	},
	refresh:function(seriesIndex, lang)
	{
		if(this.getInner(seriesIndex, lang))
			this.getInner(seriesIndex, lang).innerHTML = this.getText(seriesIndex, lang);
	},
	afterEdit:function()
	{
		//extended
	}
});
Object.extend(Editable, {
	/**
	* Editable.bindedEdit
	* this is a static function that can be used to inline edit a variable with no other dedicated function.
	* @param {DomNode} domNode - this is the element that contains the html we are going to edit.
	* @param {String} varPath - this is the dot syntax path to the variable that needs to be binded,
								the root object can be static, or must have a getInstance method.
	* @param {String} opt_instanceId - optional instanceid for getting the object out of the varPath. use this if your getInstance method needs an id.
	*/
	bindedEdit:function(domNode, varPath, opt_instanceId, opt_optionsObjectName)
	{
		var parts = QualtricsCPTools.getDotSyntaxParts(varPath, opt_instanceId);
		var editable = new Editable($(domNode), parts.root, parts.callBack, opt_optionsObjectName);
		return editable.edit();
	}
});
/*
EXAMPLES

this will make 3 <ul>s interdragable and sortable

	var listIds = ["items", "group1", "group2"];
	makeSortable(listIds);

this will just make 1 list sortable

	var listIds = ["list"];
	makeSortable(listIds);

*/

function makeSortable(listIds){

	/* if its not an array but a single string then lets put it in an array */
	if(listIds.constructor != Array){
		var listIds = [listIds];
	}
	/* go through all the lists and make them sortables,
	with all other lists a container */
	for(var i = 0; i < listIds.length; i++){
		var listId = listIds[i];
		Sortable.create( listId, {
			dropOnEmpty:true,
			containment:listIds,
			constraint:false,
			scroll:$('body'),
			onChange:function(o){
				rankOrderAll(listIds, o); /* set all the rank labels when theres a change */
				updateInputValues(listIds);
			},
			onUpdate:function(o){
				updateInputValues(listIds);
				adjustCSS(listIds);
			}
		});
		
		
		if('ontouchstart' in document.documentElement)
		{
			//its mobile WebKit! the iphone doesn't have a mouse down event which is what the sortables use
			//so we need to trigger them manually with the touch events. 
			var ul = $(listId);
			var sortable = Sortable.sortables[listId];
			for(var x=0, len=sortable.draggables.length; x<len; ++x)
			{
				var draggable = sortable.draggables[x];
				var li = draggable.element;
				Event.observe(li, 'touchstart', draggable.eventMouseDown);
				Event.observe(document, 'touchend', Draggables.eventMouseUp);
				Event.observe(document, 'touchmove', Draggables.eventMouseMove);
			}
		}
	}
}
function updateInputValues(listIds){
	/* if its not an array but a single string then lets put it in an array */
	if(listIds.constructor != Array){
		var listIds = [listIds];
	}
	for(var i = 0; i < listIds.length; i++){

		var listId = listIds[i];


		var rank = "";
		var choice = "";
		var choiceId = "";

		list = $(listId);
		var groupId = list.getAttribute('rel');

		for(var j = 0; j < list.childNodes.length; j++){
			var choiceItem = list.childNodes[j];
			if (choiceItem.nodeName != 'LI')
				continue;
			choiceId = choiceItem.id;
			/* search children for choice rank */
			for(var ranki = 0; ranki < choiceItem.childNodes.length; ranki++){
				if(choiceItem.childNodes[ranki].className == "rank"){
					rank = (choiceItem.childNodes[ranki].innerHTML);
				}
			}
			/* search children for choice label */
			for(var ranki = 0; ranki < choiceItem.childNodes.length; ranki++){
				if(choiceItem.childNodes[ranki].className == "choice"){
					choice = (choiceItem.childNodes[ranki].innerHTML);
				}
			}
			
			/*make sure theres an input for this list*/
			if($(choiceId+"~Group")){
				if(listId.indexOf('items') == -1){
					if(list.getAttribute("maxChoices"))
					{
						if(list.childNodes.length > list.getAttribute("maxChoices"))
						{
							list.previous(1).addClassName("ValidationError");
							list.previous().innerHTML = maxChoicesMsg;
							list.previous().addClassName("ValidationError");
						}
						else
						{
							list.previous(1).removeClassName("ValidationError");
							list.previous().innerHTML = "";
							list.previous().removeClassName("ValidationError");
						}
					}
				/* set the choice value to the right group */
					$(choiceId+"~Group").value = groupId;
					$(choiceId+"~Rank").value = rank;
				}else{
					$(choiceId+"~Group").value = "";
					$(choiceId+"~Rank").value = "";
				}
			}else if($(choiceId+"~Rank")){
				$(choiceId+"~Rank").value = rank;
			}else{
				console.error("Error! there is no input: "+listId+"~Rank");
			}
		}

	}
}
function rankOrderAll(listIds, itemBeingDragged){

	
	for(var i = 0; i < listIds.length; i++){
		var listId = listIds[i];
		list = $(listId);
		if(!list.edited)
		{
			$(list).removeClassName('NotEdited');
			$(list).addClassName('Edited');
			list.edited = true;
		}
		rankOrder(list, itemBeingDragged);
	}
}
function rankOrder(list, itemBeingDragged){
	var rank = 0;

	/* Preserve stack class if list is a stacked list */
	var stacked = false;
	if ($(list).getAttribute('stacked'))
	{
		stacked = true;
		
		/* Update Progress Counter */
		var progressCounterID = list.getAttribute('progressCounter');
		var itemCount = list.getAttribute('itemCount');
		if ($(progressCounterID))
		{
			$(progressCounterID).innerHTML = list.childNodes.length + ' / ' + itemCount;
		}
	}

	for (var i = 0; i < list.childNodes.length; i++)
	{
		var listItem = list.childNodes[i];
		if (!listItem || listItem.nodeName != 'LI')
		{
				continue;
		}

		if (stacked)
		{
			//Do not modify the item being dragged
			if ($(listItem).getAttribute('id') == $(itemBeingDragged).getAttribute('id'))
			{
				//continue;
			}
			
			//preserve stacked classes
			var stackedClasses = '';
			if ($(listItem).hasClassName('last'))
			{
				stackedClasses += ' last';
			}
			if ($(listItem).hasClassName('penultimate'))
			{
				stackedClasses += ' penultimate';
			}
			if ($(listItem).hasClassName('antepenultimate'))
			{
				stackedClasses += ' antepenultimate';
			}
			
		}

		rank++;
		if (i % 2 == 0)
		{
			listItem.className = "BorderColor "+list.getAttribute('regularClass');
		}
		else
		{
			listItem.className = "BorderColor "+list.getAttribute('altClass');
		}
		
		if (stacked)
		{
			listItem.className += ' stack';
		}
		
		//Add a special class to the last one rendered
		if (stacked)
		{
			//Preserve stacked classes
			listItem.className += stackedClasses;
			
			if ($(listItem).getAttribute('id') == $(itemBeingDragged).getAttribute('id'))
			{
				//listItem.className += ' last';
			}
			
			//Do not modify the item being dragged
			if ($(listItem).getAttribute('id') != $(itemBeingDragged).getAttribute('id'))
			{
				//listItem.className += ' hidden';
			}
		}
		
		var listItemContents = (list.childNodes[i].childNodes);
		for(var j = 0; j < listItemContents.length; j++){
			if(listItemContents[j].className == "rank"){

				listItemContents[j].innerHTML = rank;
			}
		}
	}
}
function adjustCSS(listIds)
{
	for (var i = 0; i < listIds.length; i++)
	{
		var listId = listIds[i];
		list = $(listId);
		adjustListCSS(list);
	}
}
function adjustListCSS(list){
	var rank = 0;
	//Really only required for stacked PGR
	if ($(list).getAttribute('stacked'))
	{
		for (var i = 0; i < list.childNodes.length; i++){
			var listItem = list.childNodes[i];
			if (!listItem || listItem.nodeName != 'LI')
					continue;

			rank++;

			$(listItem).removeClassName('antepenultimate');
			$(listItem).removeClassName('penultimate');
			//$(listItem).removeClassName('last');
			//$(listItem).removeClassName('hidden');

			if (list.childNodes.length > 2)
			{
				//Add a special class to the last one rendered
				/*
				if (i == (list.childNodes.length-1))
				{
					$(listItem).addClassName('last');
				}
				*/
				if (i == (list.childNodes.length-2))	//2nd-to-last or penultimate
				{
					$(listItem).addClassName('penultimate');
				}
				else if (i == (list.childNodes.length-3))	//3rd-to-last or antepenultimate
				{
					$(listItem).addClassName('antepenultimate');
				}
			}
			else if (list.childNodes.length == 2)
			{
				if (i == (list.childNodes.length-1))	//2nd-to-last or penultimate
				{
					$(listItem).addClassName('penultimate');
				}
				else if (i == (list.childNodes.length-2))	//3rd-to-last or antepenultimate
				{
					$(listItem).addClassName('antepenultimate');
				}
			}
			else if (list.childNodes.length == 1)
			{
				$(listItem).addClassName('antepenultimate');
			}
		}
		
	}

}
//Got from: http://elia.wordpress.com/2007/01/18/overflow-smooth-scroll-with-scriptaculous/
//Ruby on rails ticket: http://dev.rubyonrails.org/attachment/ticket/5118/effects_scroll_patch.diff
if(window.Effect)
{
	Effect.Scroll = Class.create();
	Object.extend(Object.extend(Effect.Scroll.prototype, Effect.Base.prototype), {
	  initialize: function(element) {
	    this.element = $(element);
	    var options = Object.extend({
	      x:    0,
	      y:    0,
	      mode: 'absolute'
	    } , arguments[1] || {} );
	    this.start(options);
	  },
	  setup: function() {
	    if (this.options.continuous && !this.element._ext ) {
	      this.element.cleanWhitespace();
	      this.element._ext=true;
	      this.element.appendChild(this.element.firstChild);
	    }

	    this.originalLeft=this.element.scrollLeft;
	    this.originalTop=this.element.scrollTop;

	    if(this.options.mode == 'absolute') {
	      this.options.x -= this.originalLeft;
	      this.options.y -= this.originalTop;
	    } else {

	    }
	  },
	  update: function(position) {
	  	//ie7 likes to do a fatal error if you set the scrollLeft to something that has been taken off the dom.
	  	//we can check if its still on the dom by seeing if it has width.
		if(this.element.offsetWidth)
		{
			this.element.scrollLeft = this.options.x * position + this.originalLeft;
	   		this.element.scrollTop  = this.options.y * position + this.originalTop;
		}
	  }
	});

	/**
	* ScrollContainerTo will scroll an overflowed parent to a specified child node.
	* @{DomNode} element - the parent, this should have overflow:scroll or nothing will happen
	* @{DomNode} toElement - the node that you want to scroll to.
	*/
	Effect.ScrollContainerTo = Class.create();
	Object.extend(Object.extend(Effect.ScrollContainerTo.prototype, Effect.Scroll.prototype), {
	  initialize: function(element, toElement) {
	    this.element = $(element);

	    Position.prepare();
		if(!toElement.parentNode || !element.parentNode)
		{
			//IE really hates it when you call offsetParent on something without a parentNode.
			return;
		}
		var element_y = Position.cumulativeOffset($(element))[1];
		var toElement_y = Position.cumulativeOffset($(toElement))[1];
		var y = toElement_y-element_y;
		var offset = 0;
		var options = arguments[2];
		if(options && options.offset)
		{
			offset = options.offset;
		}
	    options = Object.extend({
	      x:    0,
	      y:    y+offset,
	      mode: 'absolute'
	    } , options || {} );
	    this.start(options);
	  }
	});


	/**
	* this is my scrollTo effect that just takes coordinates
	* @author oliverh@qualtrics.com
	* @param {Number} y - the y.
	* @param {Object} options - all the regular scroll options
	*/
	Effect.ScrollToY = Class.create();
	Object.extend(Object.extend(Effect.ScrollToY.prototype, Effect.Base.prototype), {
	  initialize: function(y) {
	    this.y = y;
	    this.start(arguments[1] || {});
	  },
	  setup: function() {
	  	Position.prepare();
	    var offsets = [0, this.y];
	    var max = window.innerHeight ?
	      window.height - window.innerHeight :
	      document.body.scrollHeight -
	        (document.documentElement.clientHeight ?
	          document.documentElement.clientHeight : document.body.clientHeight);
	    this.scrollStart = Position.deltaY;
	    this.delta = (offsets[1] > max ? max : offsets[1]) - this.scrollStart;
		if(!this.delta)
		{
			this.cancel();
		}
	  },
	  update: function(position) {
	    Position.prepare();
	    window.scrollTo(Position.deltaX, this.scrollStart + (position*this.delta));
	  }
	});


	/*
	* new Effect.OverlayHighlight(el);
	* this one puts an overlaying div above the thing to highlight instead of using a background color
	*
	* @author oliverh@qualtrics.com
	* @param {DOMNode} the element you want highlighted.
	*/
	Effect.OverlayHighlight = function(element, options) {
	  var overlayOptions = Object.extend({
		  color:'#ffff99'
	  }, arguments[1] || {});

	  element = QualtricsCPTools.Highlighter.autoHighlight(element, overlayOptions).element;
	  var oldOpacity = Element.getInlineOpacity(element);
	  options = Object.extend({
	  from: element.getOpacity() || 1.0,
	  to:   0.0,
	  afterFinishInternal: function(effect) {
	    if(effect.options.to!=0) return;
	    effect.element.hide().setStyle({opacity: oldOpacity});
	  }}, arguments[1] || {});
	  return new Effect.Opacity(element,options);
	};
}

/**
* this is to support sortables in a position:fixed element
* I also added 'distancedragged' tracking attributes so we can see how far an element was dragged, this is reset by Draggable.prototype.initDrag
* use options.fixedPosition = true to use.
* @author oliverh@qualtrics.com
*/
Draggable.prototype.updateDrag = function(event, pointer) {
    if(!this.dragging) this.startDrag(event);

    //start change
    var fixedOffset = [0,0];//added by oliverh@qualtrics.com
   	if(this.options.fixedPosition) //added by oliverh@qualtrics.com
	{
	  fixedOffset = [getScrollInfo()[0], getScrollInfo()[1]];//added by oliverh@qualtrics.com
	}//end change

    if(!this.options.quiet)
	{
      Position.prepare();
      var point = pointer;//added by oliverh@qualtrics.com
	  point[0] -= fixedOffset[0];//added by oliverh@qualtrics.com
	  point[1] -= fixedOffset[1];//added by oliverh@qualtrics.com
      Droppables.show(point, this.element);
    }
	pointer[0] += fixedOffset[0];//added by oliverh@qualtrics.com
	pointer[1] += fixedOffset[1];//added by oliverh@qualtrics.com

    Draggables.notify('onDrag', this, event);

    this.draw(pointer);
    if(this.options.change) this.options.change(this);

	if(this.options.scroll) {
    	this.stopScrolling();
		var p;
		if (this.options.scroll == window) {
			with(this._getWindowScroll(this.options.scroll)) {p = [ left, top, left+width, top+height ];}
		} else {
			p = Position.page(this.options.scroll).toArray();

			p[0] += fixedOffset[0];//changed by oliverh@qualtrics.com for scripty 1.9
			p[1] += fixedOffset[1];//changed by oliverh@qualtrics.com for scripty 1.9

			p.push(p[0]+this.options.scroll.offsetWidth);
			p.push(p[1]+this.options.scroll.offsetHeight);
		}
		var speed = [0,0];

		if(pointer[0] < (p[0]+this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[0]+this.options.scrollSensitivity);
		if(pointer[1] < (p[1]+this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[1]+this.options.scrollSensitivity);
		if(pointer[0] > (p[2]-this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[2]-this.options.scrollSensitivity);
		if(pointer[1] > (p[3]-this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[3]-this.options.scrollSensitivity);
		this.startScrolling(speed);
    }

    // fix AppleWebKit rendering
    if(Prototype.Browser.WebKit && !Qualtrics.Browser.MobileWebKit) window.scrollBy(0,0);

	//add attributes to the element so things can see how far it was dragged
	var el = Event.element(event);
	if(el && el.getAttribute && el.getAttribute('distancedragged'))
	{
		if(!el.dragTracker)
		{
			el.dragTracker = [pointer[0],pointer[1]];
		}
		var distanceDragged = [Math.abs(pointer[0]-el.dragTracker[0]),Math.abs(pointer[1]-el.dragTracker[1])];
		el.setAttribute('distancedraggedx',distanceDragged[0]);
		el.setAttribute('distancedraggedy',distanceDragged[1]);
		el.setAttribute('distancedragged',distanceDragged[0]+distanceDragged[1]);
	}
    Event.stop(event);
};
/**
* added support for getting the iphone scroll pos
*/
Draggable.prototype._getWindowScroll= function(w) {
   var T, L, W, H;
   with (w.document) {
     if (w.document.documentElement && documentElement.scrollTop) {
       T = documentElement.scrollTop;
       L = documentElement.scrollLeft;
     } else if (w.document.body) {

       T = body.scrollTop || window.pageYOffset || 0; //changed to support iphone by oliverh@qualtrics.com
       L = body.scrollLeft || window.pageXOffset || 0; //changed to support iphone by oliverh@qualtrics.com
     }
     if (w.innerWidth) {
       W = w.innerWidth;
       H = w.innerHeight;
     } else if (w.document.documentElement && documentElement.clientWidth) {
       W = documentElement.clientWidth;
       H = documentElement.clientHeight;
     } else {
       W = body.offsetWidth;
       H = body.offsetHeight;
     }
   }

   return {top: T, left: L, width: W, height: H};
 };

Draggable.prototype.scroll = function() {
    var current = new Date();
    var delta = current - this.lastScrolled;
    this.lastScrolled = current;
	//if its scrolling up and we already as high as we can go then return.
    if(this.scrollSpeed[1] < 0 && this.options.scroll.scrollTop !== undefined && this.options.scroll.scrollTop < 1)
    {
		return;
    }

    if(this.options.scroll == window) {
      with (this._getWindowScroll(this.options.scroll)) {
        if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
          var d = delta / 1000;
          this.options.scroll.scrollTo( left + d*this.scrollSpeed[0], top + d*this.scrollSpeed[1] );
        }
      }
    } else {
      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;
      this.options.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;
    }

    Position.prepare();
    Droppables.show(Draggables._lastPointer, this.element);
    Draggables.notify('onDrag', this);
    if (this._isScrollChild) {
      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);
      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;
      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;
      if (Draggables._lastScrollPointer[0] < 0)
        Draggables._lastScrollPointer[0] = 0;
      if (Draggables._lastScrollPointer[1] < 0)
        Draggables._lastScrollPointer[1] = 0;
      this.draw(Draggables._lastPointer);
    }

    if(this.options.change) this.options.change(this);
};
Draggable.prototype.initDrag= function(event) {

    //if we have a grab class
    if(this.element.hasAttribute('grabClass'))
        $(this.element).addClassName(this.element.getAttribute('grabClass'));

    //if there is a trash, show it
    var trash = $('g'+this.element.parentNode.id);
    if(trash)
        QualtricsTools.fastDown($(trash),'icon').appear({duration:0.5});

	if(!Object.isUndefined(Draggable._dragging[this.element]) && Draggable._dragging[this.element]) return;
	if(Event.isLeftClick(event) || event.touches) {
		// abort on form elements, fixes a Firefox issue
		var src = Event.element(event);
		var el = Event.element(event);
		//Reset all the distance dragged stuff set in updateDrag - oliverh@qualtrics.com
		if(el)
		{
			el.dragTracker = null;
			el.setAttribute('distancedraggedx','0');
			el.setAttribute('distancedraggedy','0');
			el.setAttribute('distancedragged','0');
		}
		//end change


		if(src.getAttribute('preventDrag'))
		{
			return;
		}
		if((tag_name = src.tagName.toUpperCase()) && (
		tag_name=='INPUT' ||
		tag_name=='SELECT' ||
		tag_name=='OPTION' ||
		tag_name=='BUTTON' ||
		tag_name=='TEXTAREA')) return;

		var pointer = [Event.pointerX(event), Event.pointerY(event)];
		var pos     = Position.cumulativeOffset(this.element);
		this.offset = [0,1].map( function(i) {return (pointer[i] - pos[i])});

		if (this.element.parentNode && !this.options.ignoreParentScrollTop)
		{
			// If the element's in a scrolling container, this will fix the offset
			this.offset[1] = this.offset[1]+this.element.parentNode.scrollTop;
		}

		Draggables.activate(this);
		Event.stop(event);
	}
};
Draggable.prototype.endDrag2 = Draggable.prototype.endDrag;
Draggable.prototype.endDrag = function(event)
{
    //remove the grab class
    if(this.element.hasAttribute('grabClass'))
        $(this.element).removeClassName(this.element.getAttribute('grabClass'));

    //if there is a trash, hide it
    var trash = $('g'+this.element.parentNode.id);
    if(trash)
        QualtricsTools.fastDown($(trash),'icon').fade({duration:0.5});

    this.endDrag2(event);
};
Droppables.isAffected2 = Droppables.isAffected;
Droppables.isAffectedScroll = function(point, element, drop) {
    return (
      (drop.element!=element) &&
      ((!drop._containers) ||
        this.isContained(element, drop)) &&
      ((!drop.accept) ||
        (Element.classNames(element).detect(
          function(v) { return drop.accept.include(v) } ) )) &&
      Position.withinIncludingScrolloffsets(drop.element, point[0], point[1]) );
  };
Droppables.isAffected = function(point, element, drop)
{
	if (!drop.hasOwnProperty('isFixed'))
		drop.isFixed = QualtricsTools.isFixed(drop.element);

	if (drop.isFixed)
		point = [point[0] - scrollInfo[0], point[1] - scrollInfo[1]];

	// Sortables within scrolling frames don't work right using the normal isAffected method
	// so we will use a slightly-tweaked one instead if the SortableMayScroll flag is present
	if (element && element.parentElement && $(element.parentElement).retrieve('SortableMayScroll'))
	{
		return this.isAffectedScroll(point, element, drop);
	}

	return this.isAffected2(point, element, drop);
};
Effect.SlideRight = function(element) {
  element = $(element);
  Element.cleanWhitespace(element);
  // SlideDown need to have the content of the element wrapped in a container element with fixed height!
  var oldInnerRight = Element.getStyle(element.firstChild, 'right');
  var elementDimensions = Element.getDimensions(element);
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleY: false,
    scaleFrom: 0,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {with(Element) {
      makePositioned(effect.element);
      makePositioned(effect.element.firstChild);
      if(window.opera) setStyle(effect.element, {top: ''});
      makeClipping(effect.element);
      setStyle(effect.element, {width: '0px'});
      show(element);}},
    afterUpdateInternal: function(effect) {with(Element) {
      setStyle(effect.element.firstChild, {right:
        (effect.dims[0] - effect.element.clientWidth) + 'px'});}},
    afterFinishInternal: function(effect) {with(Element) {
      undoClipping(effect.element);
      undoPositioned(effect.element.firstChild);
      undoPositioned(effect.element);
      setStyle(effect.element.firstChild, {right: oldInnerRight});}}
    }, arguments[1] || {})
  );
};

Effect.SlideLeft = function(element) {
  element = $(element);
  Element.cleanWhitespace(element);
  var oldInnerRight = Element.getStyle(element.firstChild, 'right');
  return new Effect.Scale(element, 0,
   Object.extend({scaleContent: false,
    scaleY: false,
    scaleMode: 'box',
    scaleFrom: 100,
    restoreAfterFinish: true,
    beforeStartInternal: function(effect) {with(Element) {
      makePositioned(effect.element);
      makePositioned(effect.element.firstChild);
      if(window.opera) setStyle(effect.element, {top: ''});
      makeClipping(effect.element);
      show(element);}},
    afterUpdateInternal: function(effect) {with(Element) {
      setStyle(effect.element.firstChild, {right:
        (effect.dims[0] - effect.element.clientWidth) + 'px'});}},
    afterFinishInternal: function(effect) {with(Element) {
        [hide, undoClipping].call(effect.element);
        undoPositioned(effect.element.firstChild);
        undoPositioned(effect.element);
        setStyle(effect.element.firstChild, {right: oldInnerRight});}}
   }, arguments[1] || {})
  );
};

// CHANGES MADE FROM BLINDUP
// CHANGE from 'scaleX: false,' to scaleY: false

Effect.BlindLeft = function(element) {
  element = $(element);
  element.makeClipping();
  return new Effect.Scale(element, 0,
    Object.extend({scaleContent: false,
      scaleY: false,
      restoreAfterFinish: true,
      afterFinishInternal: function(effect) {
        effect.element.hide().undoClipping();
      }
    }, arguments[1] || {})
  );
};

// CHANGES MADE FROM BLINDDOWN
// CHANGE from 'scaleX: false,' to scaleY: false
// CHANGE afterSetup function statement's "makeClipping().setStyle({height: '0px'})" to width: '0px'

Effect.BlindRight = function(element) {
  element = $(element);
    var elementDimensions = element.getDimensions();
  return new Effect.Scale(element, 100, Object.extend({
    scaleContent: false,
    scaleY: false,
    scaleFrom: 0,
    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},
    restoreAfterFinish: true,
    afterSetup: function(effect) {
      effect.element.makeClipping().setStyle({width: '0px'}).show();
    },
    afterFinishInternal: function(effect) {
      effect.element.undoClipping();
    }
  }, arguments[1] || {}));
};

Effect.Transitions.InQuad = function(x) {return x*x};
Effect.Transitions.OutQuad= function(x) {return -1*x*(x-2);};
Effect.Transitions.InExpo = function(x) {return (x==0) ? 0 : Math.pow(2, 10 * (x - 1));};
Effect.Transitions.Elastic = function (x) {
	if (x==0 || x == 1)
		return x;
	var p = 0.3;
	var s = p/4;
	return -(Math.pow(2,10*(x-=1)) * Math.sin((x*1-s)*(2*Math.PI)/p ));
};
var INQUAD = Effect.Transitions.InQuad;
var OUTQUAD = Effect.Transitions.OutQuad;
var INEXPO = Effect.Transitions.InExpo;
var ELASTIC = Effect.Transitions.Elastic;
/*
Overshooting Transitions
*/
// Elastic (adapted from "EaseOutElastic")
Effect.Transitions.Elastic = function(pos) {
    return -1*Math.pow(4,-8*pos) * Math.sin((pos*6-1)*(2*Math.PI)/2) + 1;
};
// SwingFromTo (adapted from "BackEaseInOut")
Effect.Transitions.SwingFromTo = function(pos) {
    var s = 5.70158;
    if ((pos/=0.5) < 1) return 0.5*(pos*pos*(((s*=(1.525))+1)*pos - s));
    return 0.5*((pos-=2)*pos*(((s*=(1.525))+1)*pos + s) + 2);
};
// SwingFrom (adapted from "BackEaseIn")
Effect.Transitions.SwingFrom = function(pos) {
    var s = 1.70158;
    return pos*pos*((s+1)*pos - s);
};
// SwingTo (adapted from "BackEaseOut")
Effect.Transitions.SwingTo = function(pos) {
    var s = 1.70158;
    return (pos-=1)*pos*((s+1)*pos + s) + 1;
};

/*
Bouncing Transitions
*/
// Bounce (adapted from "EaseOutBounce")
Effect.Transitions.Bounce = function(pos) {
    if (pos < (1/2.75)) {
        return (7.5625*pos*pos);
    } else if (pos < (2/2.75)) {
        return (7.5625*(pos-=(1.5/2.75))*pos + 0.75);
    } else if (pos < (2.5/2.75)) {
        return (7.5625*(pos-=(2.25/2.75))*pos + 0.9375);
    } else {
        return (7.5625*(pos-=(2.625/2.75))*pos + 0.984375);
    }
};
// BouncePast (new creation based on "EaseOutBounce")
Effect.Transitions.BouncePast = function(pos) {
    if (pos < (1/2.75)) {
        return (7.5625*pos*pos);
    } else if (pos < (2/2.75)) {
        return 2 - (7.5625*(pos-=(1.5/2.75))*pos + 0.75);
    } else if (pos < (2.5/2.75)) {
        return 2 - (7.5625*(pos-=(2.25/2.75))*pos + 0.9375);
    } else {
        return 2 - (7.5625*(pos-=(2.625/2.75))*pos + 0.984375);
    }
};

/*
Gradual Transitions
*/
// EaseFromTo (adapted from "Quart.EaseInOut")
Effect.Transitions.EaseFromTo = function(pos) {
    if ((pos/=0.5) < 1) return 0.5*Math.pow(pos,4);
    return -0.5 * ((pos-=2)*Math.pow(pos,3) - 2);
};
// EaseFrom (adapted from "Quart.EaseIn")
Effect.Transitions.EaseFrom = function(pos) {
    return Math.pow(pos,4);
};
// EaseTo (adapted from "Quart.EaseOut")
Effect.Transitions.EaseTo = function(pos) {
    return Math.pow(pos,0.25);
};


/**
*
* Sliders changed to support touch events and activating when you click with no drag
*
**/

//initialize needs to support touch events
Control.Slider.prototype.initialize = function(handle, track, options) {
    var slider = this;

    if (Object.isArray(handle)) {
      this.handles = handle.collect( function(e) {return $(e)});
    } else {
      this.handles = [$(handle)];
    }

    this.track   = $(track);
	this.options = options || { };

    this.axis      = this.options.axis || 'horizontal';
    this.increment = this.options.increment || 1;
    this.step      = parseInt(this.options.step || '1');
    this.range     = this.options.range || $R(0,1);

    this.value     = 0; // assure backwards compat
    this.values    = this.handles.map( function() {return 0});
    this.spans     = this.options.spans ? this.options.spans.map(function(s){return $(s)}) : false;
    this.options.startSpan = $(this.options.startSpan || null);
    this.options.endSpan   = $(this.options.endSpan || null);

    this.restricted = this.options.restricted || false;

    this.maximum   = this.options.maximum || this.range.end;
    this.minimum   = this.options.minimum || this.range.start;

    // Will be used to align the handle onto the track, if necessary
    this.alignX = parseInt(this.options.alignX || '0');
    this.alignY = parseInt(this.options.alignY || '0');

    this.trackLength = this.maximumOffset() - this.minimumOffset();

    this.handleLength = this.isVertical() ?
      (this.handles[0].offsetHeight != 0 ?
        this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/,"")) :
      (this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth :
        this.handles[0].style.width.replace(/px$/,""));

    this.active   = false;
    this.dragging = false;
    this.disabled = false;

    if (this.options.disabled) this.setDisabled();

    // Allowed values array
    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;
    if (this.allowedValues) {
      this.minimum = this.allowedValues.min();
      this.maximum = this.allowedValues.max();
    }

    this.eventMouseDown = this.startDrag.bindAsEventListener(this);
    this.eventMouseUp   = this.endDrag.bindAsEventListener(this);
    this.eventMouseMove = this.update.bindAsEventListener(this);

    // Initialize handles in reverse (make sure first handle is active)
    this.handles.each( function(h,i) {
      i = slider.handles.length-1-i;
      slider.setValue(parseFloat(
        (Object.isArray(slider.options.sliderValue) ?
          slider.options.sliderValue[i] : slider.options.sliderValue) ||
         slider.range.start), i);
      h.makePositioned().observe("mousedown", slider.eventMouseDown);
    });

    this.track.observe("mousedown", this.eventMouseDown);
    document.observe("mouseup", this.eventMouseUp);
    document.observe("mousemove", this.eventMouseMove);


    //added touchevents for iPad iPhone -oliverh@qualtrics.com
    this.track.observe("touchstart", this.eventMouseDown);
    document.observe("touchend", this.eventMouseUp);
    document.observe("touchmove", this.eventMouseMove);

    this.initialized = true;
  };
Control.Slider.prototype.update= function(event) {
   if (this.active) {
      if (!this.dragging) this.dragging = true;
      this.draw(event);
      if (Prototype.Browser.WebKit && !event.touches) window.scrollBy(0,0);
      Event.stop(event);
   }
};
//start drag needs to set a value even if no drag happened
Control.Slider.prototype.startDrag= function(event) {
    if (Event.isLeftClick(event) || event.touches) {
      if (!this.disabled){
        this.active = true;

        var handle = Event.element(event);
        var pointer  = [Event.pointerX(event), Event.pointerY(event)];
        var track = handle;
        if (track==this.track) {
          // NOTE: use cumulativeOffset here, NOT viewportOffset.  pointer is based on the position of the
          // document, not the viewport.
          var offsets  = Element.cumulativeOffset(this.track);
          this.event = event;
		  if (Qualtrics.Browser.IE == true && Qualtrics.Browser.Version <= 7 && $(document.body).getStyle('direction') === 'rtl')
		  {
			  this.setValue(this.translateToValue(
			   (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength*2)
			  ));
		  }
		  else
		  {
			  this.setValue(this.translateToValue(
			   (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength/2)
			  ));
		  }
          offsets  = Position.cumulativeOffset(this.activeHandle);
          this.offsetX = (pointer[0] - offsets[0]);
          this.offsetY = (pointer[1] - offsets[1]);
        } else {
          // find the handle (prevents issues with Safari)
          while((this.handles.indexOf(handle) == -1) && handle.parentNode)
            handle = handle.parentNode;

          if (this.handles.indexOf(handle)!=-1) {
            this.activeHandle    = handle;
            this.activeHandleIdx = this.handles.indexOf(this.activeHandle);
            this.updateStyles();

            offsets  = Position.cumulativeOffset(this.activeHandle);
            this.offsetX = (pointer[0] - offsets[0]);
            this.offsetY = (pointer[1] - offsets[1]);
          }
        }
        this.draw(event); //we wanted a click with no drag to set the value - oliverh@qualtrics.com
      }
      Event.stop(event);
    }
  };
Effect.MorphClip = Class.create();
Object.extend(Object.extend(Effect.MorphClip.prototype, Effect.Base.prototype), {
  initialize: function(element) {
    this.element = $(element);
    if(!this.element) throw(Effect._elementDoesNotExistError);
    var options = Object.extend({
      style: {}
    }, arguments[1] || {});
    this.clip = options.clip;
    this.start(options);
  },
  setup: function(){
    this.transform = {
        originalValue: this.parseCSSClip(this.element.getStyle('clip')),
        targetValue: this.parseCSSClip(this.clip)
      };
  },
  parseCSSClip:function(str)
  {
	  var regex = /rect\(([\d|.]+)px,*\s*([\d|.]+)px,*\s*([\d|.]+)px,*\s*([\d|.]+)px\)/;
	  var matches = str.match(regex);
	  return {top:matches[1]*1, right:matches[2]*1,bottom:matches[3]*1, left:matches[4]*1};
  },
  update: function(position) {
	var o = this.transform.originalValue;
	var t = this.transform.targetValue;
	var top = o.top+ Math.round(((t.top - o.top) * position) * 1000)/1000;
	var right = o.right+ Math.round(((t.right - o.right) * position) * 1000)/1000;
	var bottom = o.bottom+ Math.round(((t.bottom - o.bottom) * position) * 1000)/1000;
	var left = o.left+ Math.round(((t.left - o.left) * position) * 1000)/1000;
    var style = {
	 clip:'rect('+top+'px,'+right+'px,'+bottom+'px,'+left+'px)'
	};
	this.element.setStyle(style, true);
  }
});

//this is here because IE8 freaks out if this.element.currentStyle is null
Effect.Opacity = Class.create(Effect.Base, {
  initialize: function(element) {
    this.element = $(element);
    if (!this.element) throw(Effect._elementDoesNotExistError);
    // make this work on IE on elements without 'layout'
    if (Prototype.Browser.IE && (this.element.currentStyle && !this.element.currentStyle.hasLayout))
      this.element.setStyle({zoom: 1});
    var options = Object.extend({
      from: this.element.getOpacity() || 0.0,
      to:   1.0
    }, arguments[1] || { });
    this.start(options);
  },
  update: function(position) {
    this.element.setOpacity(position);
  }
});
/** QualtricsTools.js
 This file holds all of the shared javascript needed for the survey engine and the
 control panel.  QualtricsCPTools.js and QualtricsSETools.js includes this file.
 */
//The Qualtrics variable is initialized in controlPanelFooter.tpl
Object.extend(Qualtrics, {
	Browser:{
		IE: !!(window.attachEvent && !window.opera),
		Opera: !!window.opera,
		WebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
		Safari: navigator.userAgent.indexOf('Safari/') > -1,
		MobileWebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Mobile/') > -1,
		Gecko: navigator.userAgent.indexOf('Gecko') > -1 && navigator.userAgent.indexOf('KHTML') == -1,
		Firefox: navigator.userAgent.indexOf('Firefox') > -1,
		Version:null,
		Features:null,
		getVersion:function()
		{
			var ua = navigator.userAgent.toLowerCase();
			var v = '99'; //default. this should assume features are innocent until provent guilty.
			if(Qualtrics.Browser.Firefox)
			{
				v = ua.substring(ua.lastIndexOf('firefox/')+8, ua.lastIndexOf('firefox/')+10);
			}
			else if(Qualtrics.Browser.WebKit)
			{
				v = ua.substring(ua.indexOf('applewebkit/')+12, ua.indexOf(' (khtml'));
			}
			else if(Qualtrics.Browser.IE)
			{
				v = ua.substring(ua.indexOf('msie ')+5, ua.indexOf('; w'));
			}
			//strip out the decimals
			if(v.indexOf('.') != -1)
			{
				v = v.substring(0, v.indexOf('.'));
			}
			return Number(v);
		},
		getFeatures:function()
		{
			var b = Qualtrics.Browser;
			var f = {
				onPaste:(!((b.Firefox && b.Version < 3) || b.Opera))
			};
			return f;
		}
	},
	Error:function(msg)
	{
		QError(msg);
		if(window.customErrorHandler)
		{
			window.customErrorHandler(msg);
		}
	},
	/**
	* Tells you if an object is empty even if its an array.
	*/
	isEmpty:function(obj)
	{
		if(Object.isArray(obj))
		{
			if(!obj.length) return true;
		}
		else if(!Object.values(obj).length)
		{
			return true;
		}
		return false;
	},
	getArrayValues:function(obj)
	{
		if(Object.isArray(obj))
		{
			return obj;
		}
		else
		{
			return Object.values(obj);
		}
	},
	isNumericKey:function(evt)
	{
		return (
			(evt.keyCode >= 48 && evt.keyCode <= 57) ||
			(evt.keyCode >= 96 && evt.keyCode <= 105)||
			(evt.keyCode == 8 ) || //BackSpace
			(evt.keyCode == 9) || //Tab
			(evt.keyCode == 12) || //Clear
			(evt.keyCode == 27) || //Escape
			(evt.keyCode == 37) || //Left
			(evt.keyCode == 39) || //Right
			(evt.keyCode == 46) || //Delete
			(evt.keyCode == 190 && !evt.shiftKey) || (evt.keyCode == 110 && !evt.shiftKey) || //period
			(evt.keyCode == 188 && !evt.shiftKey)  || //comma
			(evt.keyCode == 109 && !evt.shiftKey) || // - for negatives
			(evt.keyCode == 189 && !evt.shiftKey) // - for negatives
			|| evt.metaKey || evt.ctrlKey || evt.altKey //allow any key combinations
		);
	},
	//if it's a comma or period
	isNumberFormatKey:function(evt)
	{
		return (
			(evt.keyCode == 190 && !evt.shiftKey) || (evt.keyCode == 110 && !evt.shiftKey) || //period
			(evt.keyCode == 188 && !evt.shiftKey)//comma
		);
	},
	alphaNumericValidation: function(el,evt)
	{
		if(el.getAttribute('validation'))
		{
			var validation = el.getAttribute('validation');
			if(validation == 'Number' || validation == 'AlphaNumeric' || validation == 'Integer')
			{
				if (this.isNumericKey(evt))
				{
					//Don't allow period or comma for an integer type
					if(validation == 'Integer' && this.isNumberFormatKey(evt))
					{
						Event.stop(evt);
						return false;
					}
					//allow
				}
				else
				{
					//suppress if only number
					if (validation == 'Number' || validation == 'Integer')
					{
						if (evt.keyCode == 173)
						{
							//Allow - minus sign on mac keyboard (non-numpad). This bug was introduced in Gecko 15+
						}
						else
						{
							Event.stop(evt);
							return false;
						}
					}

					if (validation == 'AlphaNumeric')
					{
						if(evt.keyCode >= 65 && evt.keyCode <= 90)
						{
							//allow
						}
						else
						{
							Event.stop(evt);
							return false;
						}
					}
				}
			}
		}
		return true;
	},
	alphaNumbericInputFilter:function(evt, el)
	{
		var validation = el.getAttribute('validation');
		if(validation == 'Number')
		{
			//allow numbers and negatives commas and periods
			var testStr = el.value.replace(/[^0-9\.\-\,\%]+/g, '');
			//only replace it if we have to, because it messes with the cursor and is annoying
			if (testStr !== el.value && el.getAttribute('autoclear') != el.value)
			{
				el.value = testStr;
			}
		}
		else if(validation == 'AlphaNumeric')
		{
			//allow numbers letters negatives commas and periods
			el.value = el.value.replace(/[^0-9a-zA-Z\.\-\,]+/g, '');
		}
		else if(validation == 'CharacterSet')
		{
			//all valid chars as a regex character set in brackets WITHOUT the negate sign, thus [abc] not [^abc]
			var regex = el.getAttribute('charSet');
			if(regex)
			{
				//changes [abc] to [^abc]+
				regex = regex.replace('[','[^') + '+';

				el.value = el.value.replace(new RegExp(regex,'g'), '');
			}
		}
	},
	/**
	* Qualtrics.getInputValue
	* @param {domNode} input
	*/
	getInputValue:function(input)
	{
		var val=input.value, autoclear=input.getAttribute('autoclear');
		if(autoclear && val == autoclear)
			val = '';
		return val;
	},
	/**
	* Qualtrics.Cache
	**/
	Cache:{
		cache:{},
		set:function(key,val)
		{
			this.cache[key] = val;
		},
		get:function(key)
		{
			if (this.cache[key] !== null && typeof(this.cache[key]) != 'undefined')
				return this.cache[key];
			else
				return null;
		},
		unset:function(key)
		{
			delete this.cache[key];
		}
	},
	/**
	* returns messages out of the Messages.xml file.
	* takes a variable amount of params
	* you can just give 1 param and it will look in the 'Javascript' section
	* if you give 2 params then the 1st param is the section and the 2nd is the tag
	* more than 2 params will define replacement parameters %1 %2 and so on
	*/
	getMessage:function(var_args)
	{
		var sectionName = 'Javascript', params=null, tag = arguments[1] || arguments[0];

		if(arguments[1])
		{
			sectionName = arguments[0];
			params = Array.prototype.slice.call(arguments,2);
		}
		var messages = window.javascriptMessages;
		if(window.javascriptMessages)
		{
			if(tag && messages && window.javascriptMessages[sectionName])
			{
				//see if $item has any parameters (automatic replacements) that need to be done
				var message = window.javascriptMessages[sectionName][tag];
				if (message)
				{
					//TODO: Eventually don't do this EVER, but until then, slowly phase out entire product sections using if below \|/
					if (Qualtrics && Qualtrics.System && (Qualtrics.System.productName == 'ThreeSixty') && Qualtrics.ThreeSixty && (Qualtrics.ThreeSixty.section != 'AssessmentPortal') )
					{
						var ignoredTags = ['Survey', 'Survey1', 'Survey2', 'Survey3', 'Form', 'Form1', 'Form2', 'Form3', 'Assessment', 'Assessment1', 'Assessment2', 'Assessment3', 'Project', 'Project1', 'Project2', 'Project3'];
						if (ignoredTags.indexOf(tag) === -1)
						{
							if (Qualtrics.ThreeSixty.currentType == 'EE')
							{
								message = message.replace(new RegExp('\\b'+getMessage('SiteWide','Form')+'\\b'),getMessage('SiteWide','Survey'));
								message = message.replace(new RegExp('\\b'+getMessage('SiteWide','Form1')+'\\b'),getMessage('SiteWide','Survey1'));
								message = message.replace(new RegExp('\\b'+getMessage('SiteWide','Form2')+'\\b'),getMessage('SiteWide','Survey2'));
								message = message.replace(new RegExp('\\b'+getMessage('SiteWide','Form3')+'\\b'),getMessage('SiteWide','Survey3'));
								message = message.replace(getMessage('SiteWide','Assessment'),getMessage('SiteWide','Project'));
								message = message.replace(getMessage('SiteWide','Assessment1'),getMessage('SiteWide','Project1'));
								message = message.replace(getMessage('SiteWide','Assessment2'),getMessage('SiteWide','Project2'));
								message = message.replace(getMessage('SiteWide','Assessment3'),getMessage('SiteWide','Project3'));
							}
							else	//360
							{
								message = message.replace(getMessage('SiteWide','Survey'),getMessage('SiteWide','Form'));//capital S
								message = message.replace(getMessage('SiteWide','Survey1'),getMessage('SiteWide','Form1'));//lowercase S
								message = message.replace(getMessage('SiteWide','Survey2'),getMessage('SiteWide','Form2'));//capital S plural
								message = message.replace(getMessage('SiteWide','Survey3'),getMessage('SiteWide','Form3'));//lowercase s plural
							}
						}
					}

					if(params && params.length)
					{
						for(i=0,len=params.length; i<len; ++i)
						{
							var re = new RegExp("%"+(i+1), 'g');
							message = message.replace(re, params[i]);
						}
					}
					return message;
				}
			}
		}
		return '#'+tag;
	},
	/**
	* parses JSON with some safe guards so you dont fatal error if you get bad json
	*/
	parseJSON:function(json, opt_silent)
	{
		try{
			if(json)
			{
				if(typeof json == 'string')
				{
					var parsed = json.evalJSON();
					return parsed;
				}
				else if(typeof json == 'object')
				{
					//its probably already been parsed by an ajax abstractor like executeMultiple
					return json;
				}
			}
		}catch(e)
		{
			if(!opt_silent)
				console.error(e);
		}
		return false;
	},
	/**
	 * Wraps Object.toJSON in a try-catch, in case of circular references
	 * @return {string} json, or false on failure.
	 */
	toJSON:function(object, opt_silent)
	{
		var json;
		try
		{
			json = Object.toJSON(object);
		}
		catch(e)
		{
			if(!opt_silent)
				console.error(e);
			json = false;
		}
		return json;
	},
	getHashCode:function(str)
	{
		var hash1 = (5381<<16) + 5381;
		var hash2 = hash1;
		var hashPos = 0;
		while(hashPos < str.length) {
			hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ str.charCodeAt(hashPos);
			if( hashPos == str.length - 1) {
				break;
			}
			hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ str.charCodeAt(hashPos + 1);
			hashPos += 2;
		}

		return hash1 + (hash2 * 1566083941);
	},
	/**
	* Qualtrics.arrayCast
	* forces an object to be an array and will leave an array alone
	* @param {Array|Object|null} - an array or object or that you want to come out as an array
	*							  null will come out as an empty array
	**/
	arrayCast:function(object)
	{
		if(!object)
		{
			return [];
		}
		if(object.length !== undefined && object.push)
		{
			//its an array
			return object;
		}
		var array = [];
		for(var key in object)
		{
			array.push(object[key]);
		}
		return array;
	}
});
Qualtrics.Browser.Version = Qualtrics.Browser.getVersion();
Qualtrics.Browser.Features = Qualtrics.Browser.getFeatures();

// --------------------------------------------------------------------------------------
// THIS FILE CONTAINS ALL OF THE JAVASCRIPT PAGE FUNCTIONS USED IN THE QUALTRICS ENGINE
// --------------------------------------------------------------------------------------

// * FOR QUESTION TYPES ***************************************************************************************
/* CSS Mouse Over Handling */
var OverRegistry = [];
var dragInProgress = false;
var suspendOvers = false;
function clearOverRegistry(){
	/* safari is flaky when it comes to onmouseout
	so we have to keep track of them and do cleanups*/
	if(suspendOvers) return; /*this one suspends all hover activity including clearing the registry*/
	for(i = 0; i < OverRegistry.length; i++){
		var elem = OverRegistry[i];
		var cn = Element.classNames(elem);
		cn.remove("Over");
	}
	OverRegistry.clear();
}

function AddOver(el, options)
{
	if (!el)
		return;

	if(window.dragInProgress != undefined)
	{
		if(window.dragInProgress) return; /* so we dont get flashes all over the place when we drag */
		if(window.suspendOvers) return; /*this one suspends all hover activity including clearing the registry*/
	}
	var className = (options && options.className || "Over");
	$(el).addClassName(className);
	OverRegistry.push(el);
	if(options && options.onComplete){
		options.onComplete(el, options);
	}

}
function RemoveOver(el, options){
	if(window.dragInProgress != undefined)
	{
		if(window.dragInProgress) return; /* so we dont get flashes all over the place when we drag */
		if(window.suspendOvers) return; /*this one suspends all hover activity including clearing the registry*/
	}
	var className = (options && options.className || "Over");
	$(el).removeClassName(className);

	clearOverRegistry();
	if(options && options.onComplete){
		options.onComplete(el, options);
	}
}
/**
* this returns a closure for the add/remove over functions. this way helps reduce memory leak exposure.
*/
function getOverClosure(type, opt_options)
{
	return function(evt)
	{
		evt = evt || window.event;
		if(evt)
		{
			//you can pass the element you want to use in the options instead of using auto detection (if they element has children do this).
			var el = (opt_options && opt_options.element) || Event.element(evt);
			if(window[type])
			{
				window[type](el, opt_options);
			}
		}
	};
}
function AddOverHelper(el)
{
	if(!el.overAdded)
	{
		el.overAdded = true;
		Event.observe(el, 'mouseover', function()
		{
			AddOver(el);
		});
		Event.observe(el, 'mouseout', function()
		{
			RemoveOver(el);
		});
	}
}

var translationTip = {
	originalText:'',
	suggestionText:'',
	section:'',
	item:'',
	userLang:'',
	userID:'',
	span:'',
	event:'',
	keepTip:false,
	off:function()
	{
		if ($('translationTip'))
		{
			setTimeout(translationTip.removeTip, 750);
		}
	},
	on:function(el, ev, section, item, lang, userID)
	{
		if ($('translationTip'))
			return;
		this.span = el;
		this.event = ev;
		this.section = section;
		this.item = item;
		this.userLang = lang;
		this.userID = userID;
		setTimeout(translationTip.addTip, 750);
	},
	keepAlive:function(value)
	{
		this.keepTip = value;

		if (value == false)
			this.off();
	},
	removeTip:function(override) {
		if ((!this.keepTip && $('translationTip') && !$('suggestionText').value) || override)
		{
			$('translationTip').remove();
		}
	},
	addTip:function() {
		var el = this.span;
		var coordinates = Element.positionedOffset(el);
		var event = this.event;
		if (!event) event = window.event;
		var mouseCoordinates = getMousePosition(event);
		this.originalText = el.innerHTML;
		var x = mouseCoordinates[0];
		var y = mouseCoordinates[1];
		var stripped = this.originalText.replace(/(<([^>]+)>)/ig,"");

		var translationTip = QBuilder('div',{id:'translationTip', onmouseover:'translationTip.keepAlive(true)', onmouseout:'translationTip.keepAlive(false)', style:'left:'+x+'px; top:'+y+'px;'},[
			QBuilder('div',{className:'header'},[
				QBuilder('h3', {},[getMessage('SiteWide','SuggestTranslation')])
			]),
			QBuilder('div',{className:'content'},[
				QBuilder('div',{id:'translationTipContent'},[
					QBuilder('div',{},[getMessage('SiteWide','CurrentText')]),
					QBuilder('div',{},[this.originalText])
				]),
				QBuilder('div',{},[
					getMessage('SiteWide','BetterSuggestion')
				]),
				QBuilder('input',{type:'text', id:'suggestionText'},[

				])
			]),
			QBuilder('div',{className:'footer'},[
				QBuilder('div',{className:'translationTipButton', id:'submitTranslation', onclick:'translationTip.submitSuggestion()'},[getMessage('SiteWide', 'Submit')]),
				QBuilder('div',{className:'translationTipButton', onclick:'translationTip.removeTip(true)'},[getMessage('SiteWide', 'Close')]),
				QBuilder('div',{className:'clear'},[])
			])
		]);

		$('body').appendChild(translationTip);
	},
	submitSuggestion:function() {
		if ($('submitTranslation') && $('submitTranslation').hasClassName('disabled'))
			return;

		$('submitTranslation').addClassName('disabled');
		if ($('suggestionText') && $('suggestionText').value)
			this.suggestionText = $('suggestionText').value;
		else
		{
			$('translationTipContent').innerHTML = getMessage('SiteWide','NoSuggestion');
			this.off();
			return;
		}

		var url = 'http://reporting.qualtrics.com/projects/translations.php?userID='+this.userID+'&suggestion='+this.suggestionText+'&sectionTag='+this.section+'&messageTag='+this.item+'&language='+this.userLang;

		new Ajax.Request(url, {
			params: {
			userID: this.userID,
			translation: this.suggestionText,
			sectionTag: this.section,
			messageTag: this.item,
			language: this.userLang
			},
			onSuccess: function() {
				$('translationTipContent').innerHTML = getMessage('SiteWide','TranslationReceived');
				this.off();
			},
			onFailure: function() {
				$('translationTipContent').innerHTML = getMessage('SiteWide','TranslationNotReceived');
				this.off();
			}
		});
	}
};
//cookie help class
Cookie = {
	createCookie: function(name,value,days) {
		if (days) {
			var date = new Date();
			date.setTime(date.getTime()+(days*24*60*60*1000));
			var expires = "; expires="+date.toGMTString();
		}
		else
			expires = "";
		document.cookie = name+"="+value+expires+"; path=/";
	},

	readCookie: function(name) {
		var nameEQ = name + "=";
		var ca = document.cookie.split(';');
		for(var i=0;i < ca.length;i++) {
			var c = ca[i];
			while (c.charAt(0)==' ') c = c.substring(1,c.length);
			if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
		}
		return null;
	},

	readCookieNames: function() {
		var cookies = [];
		var ca = document.cookie.split(';');
		ca.each(function(item){
			var index = item.indexOf('=');
			cookies.push(item.substring(0,index));
		});

		return cookies;
	},

	eraseCookie: function(name) {
		Cookie.createCookie(name,"",-1);
	},

	acceptsCookies: function() {
		if (typeof navigator.cookieEnabled == 'boolean') {
			return navigator.cookieEnabled;
		}
		Cookie.createCookie('_test', '1');
		var val = Cookie.readCookie('_test');
		Cookie.eraseCookie('_test');
		return val == '1';
  	}
};

// Prevents enter form submitting the form
function stopEnterSubmit(evt)
{
	if (evt.keyCode == Event.KEY_RETURN)
	{
		Event.stop(evt);
		return false;
	}
}
// lets the user specify the submit button used when enter is pressed. Useful for forms with multiple buttons.
function pressSubmitButtonOnEnter(evt,id)
{
	if (evt.keyCode == Event.KEY_RETURN)
	{
		Event.stop(evt);
		$(id).click();
		return false;
	}
}

//equivalent of php's number_format function
function number_format(number, decimals, dec_point, thousands_sep, pad_right)
{
	//Quick layer to pretty print the decimals to a certain place ONLY if there exists a decimal!
	if (!decimals || decimals > 0)
	{
		var decimalPos = String(number).indexOf(".");
		if (decimalPos === -1 && !pad_right)
		{
			decimals = 0;	//No decimal place, so do not add extra zeros
		}
		else
		{
			var numOfCharactersAfterDecimal = String(number).substring(decimalPos+1).length;

			if (decimals)
			{
				decimals = pad_right ? decimals : Math.min(numOfCharactersAfterDecimal, decimals);
			}
			else
			{
				decimals = numOfCharactersAfterDecimal;
			}
		}
	}

	// http://kevin.vanzonneveld.net
	var n = number;
	var c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
	var d = dec_point == undefined ? "." : dec_point;
	var t = thousands_sep == undefined ? "," : thousands_sep;
	var s = n < 0 ? "-" : "";
	var i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "";
	var j = (j = i.length) > 3 ? j % 3 : 0;

	var finalNum = s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
	return finalNum;
}

function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '') ;
}

// -- THIS FUNCTION UPDATES THE TOTAL COLUMN FOR A CONSTANT SUM QUESTION
function UpdateCSTotal(CSQuestion, DesiredSum)
{
	//grab all of the choices displayed in this question
	var displayOrderEl = $("QR~"+CSQuestion+"~DisplayOrder");
	var displayedChoices = (displayOrderEl) ? displayOrderEl.value.split('|') : [];

	var TotalCount = 0;

	for (var i=0; i < displayedChoices.length; i++)
	{
		var CurrentChoice = "QR~" + CSQuestion + "~" + displayedChoices[i];
		var choiceEl = $(CurrentChoice);
		if (choiceEl)
		{
			var num = Number(choiceEl.value.replace(/,/g, ''));
			if (!isNaN(num))
			{
				TotalCount += num;
			}
		}
	}

	if( TotalCount == DesiredSum || DesiredSum == -1)
		$(CSQuestion + "_Total").style.color = "";
	else
		$(CSQuestion + "_Total").style.color = "red";

	//Format with thousands separator
	TotalCount = number_format(TotalCount);

	$(CSQuestion + "_Total").value = TotalCount;
}

// -- THIS FUNCTION UPDATES THE TOTAL COLUMN FOR A MATRIX CONSTANT SUM QUESTION
function UpdateMatrixCSTotal(Question, choiceId, desiredSum)
{
	if (!desiredSum)
		desiredSum = -1;
	var questionId = Question;
	if(questionId.indexOf('~') != -1)
	{
		//transposed passes along values differently for some reason
		choiceId = questionId.substring(questionId.indexOf('~')+1);
		questionId = questionId.substring(0, questionId.indexOf('~'));
	}

	//grab all of the choices displayed in this question
	var displayOrderEl = $("QR~"+questionId+"~AnswerDisplayOrder");
	var displayedAnswers = (displayOrderEl) ? displayOrderEl.value.split('|') : [];

	var TotalCount = 0;

 	for (var i=0; i < displayedAnswers.length; i++)
 	{
	  	var CurrentAnswer = "QR~" + questionId + "~" + choiceId + "~" + displayedAnswers[i];
		var answerEl = $(CurrentAnswer);
 		if (answerEl)
 		{
		 	TotalCount += Number(answerEl.value.replace(/,/g, ''));
 		}
 	}

 	var OutputCell = questionId + "~" + choiceId + "_Total";

 	if( TotalCount == desiredSum || desiredSum == -1)
 		$(OutputCell).style.color = "";
 	else
 		$(OutputCell).style.color = "red";

 	//Format with thousands separator
 	TotalCount = number_format(TotalCount);

 	$(OutputCell).value = TotalCount;
}
// -- THIS FUNCTION UPDATES THE TOTAL COLUMN FOR A MATRIX CONSTANT SUM QUESTION - VERTICAL
function UpdateMatrixCSTotalVert(Question, answerId, desiredSum)
{
	if (!desiredSum)
		desiredSum = -1;
	var questionId = Question;
	if(questionId.indexOf('~') != -1)
	{
		//transposed passes along values differently for some reason
		answerId = questionId.substring(questionId.indexOf('~')+1);
		questionId = questionId.substring(0, questionId.indexOf('~'));
	}

	//grab all of the choices displayed in this question
	var displayOrderEl = $("QR~"+questionId+"~DisplayOrder");
	var displayedChoices = (displayOrderEl) ? displayOrderEl.value.split('|') : [];

	var TotalCount = 0;

 	for (var i=0; i < displayedChoices.length; i++)
 	{
	  	var CurrentAnswer = "QR~" + questionId + "~" + displayedChoices[i] + "~" + answerId;
		var answerEl = $(CurrentAnswer);
 		if (answerEl)
 		{
		 	TotalCount += Number(answerEl.value.replace(/,/g, ''));
 		}
 	}

 	var OutputCell = questionId + "~" + answerId + "_Total";

 	if( TotalCount == desiredSum || desiredSum == -1)
 		$(OutputCell).style.color = "";
 	else
 		$(OutputCell).style.color = "red";

 	//Format with thousands separator
 	TotalCount = number_format(TotalCount);

 	$(OutputCell).value = TotalCount;
}

// -- THIS FUNCTION UPDATES THE TOTAL COLUMN FOR A CONSTANT SUM CONJOINT QUESTION
function updateConjointTotal(prefix, total_levels)
{
	var conjoint_level = 1;
	var total_count = 0;

	var features = $('featuresShown').value.split(',');

	for (var i=0; i < features.length; i++)
	{
		conjoint_level = features[i];
	  	level_element = prefix + "~" + conjoint_level + "~UCS";
	  	if($(level_element))
	 		total_count += Number($(level_element).value);

	 	conjoint_level++;
	}

 	var output_element = prefix + "~Total";

 	if(total_count == 100)
 		document.Page.elements[output_element].style.color = "";
 	else
 		document.Page.elements[output_element].style.color = "red";

 	document.Page.elements[output_element].value = total_count;
}


function SBChangeOrder(selectionID, offset)
{
	offset = Number(offset);
	var element = $(selectionID);

	if ((offset != -1 && offset != 1) || element == null)
		return;

	var index = element.selectedIndex;
	if (index == -1 || index+offset < 0 || index+offset >= element.options.length)
		return;

	var optionA = new Option(element.options[index].text, element.options[index].value, 0, 1);
	optionA.nomove = element.options[index].nomove;
	var optionB = new Option(element.options[index+offset].text, element.options[index+offset].value);
	optionB.nomove = element.options[index+offset].nomove;
	element.options[index] = optionB;
	element.options[index+offset] = optionA;
	element.focus();
}

// -- Takes the selected element and appends it to the new selection box
function moveItemToSelectionBox(oldSelectionBoxID, newSelectionBoxID, deleteOption) {
	var old_element = $(oldSelectionBoxID);
	var new_element = $(newSelectionBoxID);

	if(old_element == null || new_element == null)
	{
		return;
	}
	var old_element_length = old_element.options.length;
	for (var index = 0; index < old_element_length; index++)
	{
		if (old_element.options[index].selected)
		{
			var option = old_element.options[index];
			option = new Option(option.text,option.value);
			option.referer = oldSelectionBoxID;
			if(deleteOption)
			{
				old_element.options[index--] = null;
				old_element_length = old_element.options.length;
			}
			new_element.options.add(option);
		}
	}
	old_element.focus();
}

// -- Takes the selected element and appends it to the new selection box
function deleteItemFromSelectionBox(selectionBoxID)
{
	var element = $(selectionBoxID);
	if(element == null)
	{
		return;
	}

	var index = element.selectedIndex;
	if (index == -1)
		return;

	var newSelected = index - 1;

	var element_length = element.options.length;
	for (index = 0; index < element_length; index++)
	{
		if (element.options[index].selected)
		{
			element.options[index--] = null;
			element_length = element.options.length;

			if (index < 0)
				index = 0;
		}
	}
	if (newSelected >= 0)
		element.options[newSelected].selected = true;
	else
		element.options[0].selected = true;

	element.focus();
}

function updateDrillDown(selectPrefix, answerMap, answers, depth, maxDepth, value)
{
	//check to see if there is a valid answer map
	var hasAnswerMap = false;
	for(var test in answerMap)
	{
		hasAnswerMap = true;
		break;
	}
	if(!hasAnswerMap || depth > maxDepth)
	{
		return;
	}
	var questionId = selectPrefix.split('~')[0];
	//grab all the drill down choices in the order that they are rendered
	var choices = $$("[posttag=" + questionId + "] .drillDownSelectDropDown");
	//index 0 needs to be null to initialize the drill down 
	choices.unshift(null);
	var selectedAnswer = parseValue(value);
	var currentSelect = choices[depth];
	var nextSelect = choices[depth + 1];

	//for the onload event we will take the current select box and actually select the answer
	if (currentSelect && selectedAnswer)
	{
		var selectValue = "QR~"+choices[depth].id+"~"+selectedAnswer;
		currentSelect.value = selectValue;
		var options = currentSelect.select('option');
		options.each(function(option) {
			if (option.value == selectValue)
			{
				option.setAttribute('selected', 'selected');
			}
		});
	}

	if (nextSelect)
	{
		nextSelect.disabled = true;
		nextSelect.options.length = 0;

		if (selectedAnswer || depth == 0)
		{

			var valuePrefix = nextSelect.name + '~';
			var newAnswers = createDDAnswers(answerMap, answers, selectedAnswer, depth);

			var i = 0;
			nextSelect.options[i++] = new Option('', '');

			for (var answerID in newAnswers)
			{
				nextSelect.options[i++] = new Option(newAnswers[answerID], valuePrefix + answerID);
			}

			if (!Element.hasClassName(nextSelect, 'disabled'))
			{
				nextSelect.disabled = false;
			}
		}

		for (i = depth + 2; i <= maxDepth; i++)
		{
			if (choices[i] != null) {
				var select = choices[i];
				select.options.length = 0;
				select.disabled = true;
			}
		}
	}
}

function parseValue(value)
{
	if (value == false || value.indexOf('~') == -1)
		return value;

	var startIndex = value.lastIndexOf('~') + 1;
	var endIndex = value.length;
	return value.substring(startIndex, endIndex);
}

function createDDAnswers(answerMap, DDanswers, selectedAnswer, depth)
{
	var answerArray = getAnswerArray(answerMap, selectedAnswer, depth);
	var answers = new Object();

	for (var answerID in answerArray)
	{
		answers[answerID] = DDanswers[answerID].substring(DDanswers[answerID].lastIndexOf('~ ') + 1);
	}

	return answers;
}

function getAnswerArray(answerMap, selectedAnswer, depth)
{
	if (answerMap == '')
		return false;

	if (depth == 0)
		return answerMap;

	for (var answerID in answerMap)
	{
		if (answerID == selectedAnswer)
			return answerMap[answerID];

		var answerArray = getAnswerArray(answerMap[answerID], selectedAnswer);
		if (answerArray != false)
			return answerArray;
	}

	return false;
}

function validateNumber(event)
{

	var keyCode = event.keyCode;

	if (keyCode==8 || keyCode==9 || keyCode==35 || keyCode==36 || keyCode==37 || keyCode==39 || keyCode==46)
		return true;

	if (keyCode==0)
		keyCode = event.which;

	//allow a decimal point
	if(keyCode == 46)
		return true;

	//allow a negative sign
	if(keyCode == 45)
		return true;

 	//Modified ranges, don't know if it's due to a browser change, but this works now in FF 2.0 and IE 7 -JB
 	if (keyCode>=48 && keyCode<=57 || keyCode<=97 && keyCode>=122)
		return true;

	return false;
}

/**
 * Used for the none of the above option
 * Checks to see if any of the boxed need to be unchecked
 * @param {string} postTag The tag to get to the question (QR~QID13)
 * @param {string} choiceId If it is a matrix question this will be the choice of the matrix
 * @param {string} notAChoice The id of the element that triggers all of the other ones to clear
 * @param {string} thisID The id of the element that clicked on it
 */
function noneOfTheAboveCheck(postTag, choiceId, notAChoice, thisID)
{
	if (choiceId == "")
		var items = document.Page.elements[postTag+"~DisplayOrder"].value.split('|');
	else
	{
		items = document.Page.elements[postTag+"~AnswerDisplayOrder"].value.split('|');
		postTag = postTag+"~"+choiceId;
	}

	if (thisID == notAChoice)
	{
		var thisCheckBox = $(postTag + "~" + thisID);
		if (thisCheckBox.checked)
		{
		 	for (var i=0; i < items.length; i++)
		 	{
				var checkBox = $(postTag + "~" + items[i]);

				if (thisID == items[i] || !checkBox)
					continue;

				checkBox.checked = false;
			}
		}
	}
	else
	{
		var notAChoiceCheckBox = $(postTag + "~" + notAChoice);
		notAChoiceCheckBox.checked = false;
	}
}
function exclusiveAnswerCheck(postTag, group, elementId)
{
	try
	{
		if ($(postTag+"~AnswerDisplayOrder"))
			var displayedChoices = $F(postTag+"~AnswerDisplayOrder").split('|');
		else if ($(postTag+"~DisplayOrder"))
			displayedChoices = $F(postTag+"~DisplayOrder").split('|');
		else
			return;
	}
	catch(e)
	{
		console.log(e);
	}

	var isExclusive = $(group + "~" + elementId).getAttribute('exclusive');

 	for (var i=0; i < displayedChoices.length; i++)
 	{
		var checkBox = $(group + "~" + displayedChoices[i]);
		var id = displayedChoices[i];
		if (isExclusive == 1)
		{
			if (elementId == id || !checkBox)
				continue;

			checkBox.checked = false;
		}
		else
		{
			if (checkBox && checkBox.getAttribute('exclusive') == 1)
				checkBox.checked = false;
		}
 	}
}

function exclusiveChoiceCheck(postTag, group, choiceId, elementId)
{
	try
	{
		if ($(postTag+"~DisplayOrder"))
			var displayedChoices = $F(postTag+"~DisplayOrder").split('|');
		else
			return;
	}
	catch(e)
	{
		console.log(e);
	}

	var isExclusive = $(group + "~" + elementId).getAttribute('choiceexclusive');

 	for (var i=0; i < displayedChoices.length; i++)
 	{
		var checkBox = $(postTag + "~" + displayedChoices[i] + '~' + elementId);
		var id = displayedChoices[i];
		if (isExclusive == 1)
		{
			if (choiceId == id || !checkBox)
			{
				continue;
			}
			checkBox.checked = false;
		}
		else
		{
			if (checkBox && checkBox.getAttribute('choiceexclusive') == 1)
				checkBox.checked = false;
		}
 	}

}
// Used for Radio Button Rank Order question.
function rankOrderRadioCheck(colId, selectedRow, numRows)
{
	for (var row = 0; row < numRows; row++)
	{
		if (row == selectedRow)
			continue;

		var radio = $(colId + "~" + row);

		if (radio.checked == true)
			radio.checked = false;
	}
}

//gets the time as an array of hours minutes and seconds - Used for Timing question
function getTimeArray(d)
{
	d = Number(d);
	return {
		h:Math.floor(d / 3600),
		m:Math.floor(d % 3600 / 60),
		s:Math.floor(d % 3600 % 60)
	};
}
/*
 * Given a timer id, we start the timer!
 */
function startTimer(tId)
{
	$(tId + 'Timer').timer = setInterval((function(){
		var t = $(tId + 'Timer');
		var i = parseInt(t.getAttribute('time'));

		var e = i - parseInt(t.getAttribute('endTime'));
		//we are done!
		if(e == 0)
		{
			clearInterval(t.timer);
			return;
		}

		var j = i - e / Math.abs(e);

		t.setAttribute('time',j);
		$('TimerClock' + tId + 'Time').setValue(j);

		i = getTimeArray(i);
		j = getTimeArray(j);

		flipNumber(i.s, j.s, tId+'S');

		if(i.m != j.m)
			flipNumber(i.m, j.m, tId + 'M');

		if(i.h != j.h)
			flipNumber(i.h, j.h, tId + 'H');

	}).bind(null, tId), 1000);
}
//Used in the timing question, it changes the number
function flipNumber(i, j, hms)
{
	var flip = function(i, j, n)
	{
		$('TimerClock' + n).setValue(j);

		if(!(Qualtrics.Browser.WebKit || Qualtrics.Browser.Firefox))
		{
			$(n).down('.Number').update(j);
			return;
		}
		var field = QBuilder('fieldset', {},[
			QBuilder('span',{className:'Change B'},j+''),
			QBuilder('span',{className:'Change TF'}, i+''),
			QBuilder('span',{className:'Change TB'}, j+'')
		]);

		$(n).appendChild(field);

	   	(function(n){n.className += ' Flip'}).delay(.05,field);

		setTimeout(
			(function(n, j){
				$(n).down('.Number').update(j);
				$(n).down('.Flip').hide(); //chrome flips out when we remove it when in an iframe, so for now we'll just hide it untill we can figure out a better solution
			}).curry(n, j),
			800
		);
	};

	if(i % 10 != j % 10)
	{
		flip(i % 10, j % 10, hms+'2');
	}

	i = Math.max(Math.floor(i/10),0);
	j = Math.max(Math.floor(j/10),0);
	if(i != j)
	{
		flip(i, j, hms+'1');
	}

}
/**
* This Function Creates and Inserts a Slider
* this is refactored legacy code, to support just sticking it at the end of the page with document.write
*/
function InsertSlider(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue)
{
	var html = generateSliderDOM(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue);
	var SliderParentId = 'SSParent~'+SliderName;
	$(SliderParentId).appendChild(html);
	createSlider.defer(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue);
}
function generateSliderDOM(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue)
{
	if (SliderValue !== undefined && SliderValue !== null && SliderValue !== '' && SliderValue >= min && SliderValue <= max)
		DefaultValue = SliderValue;

	var SliderNM = SliderName;
	var SliderImage = SliderName + "_Image";

	var sliderPath = '/WRQualtricsShared/SlidingScales/'+GraphicDirectory+'/';

	var ssImages = QBuilder('div',{className:'SSImage'});
	for(var i=min; i<=max; i++)
	{
		var display = (i==DefaultValue)?'block':'none';
		var img = QBuilder('img',{src:sliderPath+i+'.gif',id:'Image_' + SliderName+'@'+i});
		$(img).setStyle({display:display});

		$(ssImages).appendChild(img);
	}
	var track = QBuilder('a',{className:'SSTrack',id:'DV_'+SliderName},[
		QBuilder('span',{className:'handle', id:'H_'+SliderName})
	]);

	var ret = QBuilder('div');
	if (Direction == 'vertical')
	{
		ret.appendChild(
			QBuilder('table',{className:'SSDisplay '+Direction+'bar'},[
				QBuilder('tbody',{},[
					QBuilder('tr',{},[
						QBuilder('td',{},[ssImages]),
						QBuilder('td',{},[track])
					])
				])
			])
		);
	}
	else
	{
		ret.appendChild(
			QBuilder('table',{className:'SSDisplay '+Direction+'bar'},[
				QBuilder('tbody',{},[
					QBuilder('tr',{},[
						QBuilder('td',{},[ssImages])
					]),
					QBuilder('tr',{},[
						QBuilder('td',{},[track])
					])
				])
			])
		);
	}

	var opts = {'type':'hidden', id:SliderName, 'name':SliderName};

	//if we have a value, insert it
	if (SliderValue !== undefined && SliderValue !== null && SliderValue !== '' && SliderValue >= min && SliderValue <= max)
		opts['value'] = SliderValue;

	//need to use Builder.node for the input because IE6 & 7 vomit when you give QBuilder an input tag
	ret.appendChild(Builder.node('input',opts));
	return ret;
}
/**
* createSlider makes the slider work.
* MUST BE CALLED AFTER THE SLIDER DOM ELEMENTS ARE READY TO USE
*/
function createSlider(SliderName, Direction, min, max, DefaultValue, GraphicDirectory, SliderValue)
{


	var slider = 'DV_' + SliderName;
	var handle = 'H_'+SliderName;
	var range = $R(parseInt(min),parseInt(max));
	var activated = false;

	if (SliderValue !== undefined && SliderValue !== null && SliderValue !== '' && SliderValue >= min && SliderValue <= max)
	{
		DefaultValue = SliderValue;
		activated = true;
		$(slider).addClassName('activated');
	}

	var defValue = DefaultValue;
	if(Direction == 'vertical')
	{
		DefaultValue = range.end - DefaultValue + parseInt(min);
	}


	var mySlider = new Control.Slider(handle, slider, {
		range:range,
		values:$A(range),
		axis:Direction,
		sliderValue:DefaultValue,
		onSlide:function(value)
		{
			//0 may be a value wich will evaluate to false
			if(!this.value && this.value != 0)
			{
				this.value = defValue;
			}

			if(this.axis == 'vertical')
				value = this.range.end - value + this.range.start;
			if($('Image_' + SliderName+'@'+this.value))
				$('Image_' + SliderName+'@'+this.value).setStyle({display:'none'});

			if($('Image_' + SliderName+'@'+value))
				$('Image_' + SliderName+'@'+value).setStyle({display:'block'});

			this.value = value;
		},
		onChange: function(value) {
			if(!activated)
			{
				activated = true;
				$(slider).addClassName('activated');
			}

			if(this.axis == 'vertical')
				value = this.range.end - value + this.range.start;

			$(SliderName).value = value;
		}
	});

}
//you can pass in a form id or the form itself
function submitForm(formID)
{
	var form = $(formID);
	if (form)
	{
		Event.fire(form, 'submit');

		if (form.onsubmit)
			form.onsubmit();
		if (form.submit)
			form.submit();

		return true;
	}
}

function submitFormJumpTo(formID, jumpTo)
{
	$(formID).action = jumpTo;
	submitForm(formID);
}
/** returns the mouse position relative to the document.
 *@param e The event.
 * Returns an array with the values.
 */
function getMousePosition(e)
{
	if (e.pageX && e.pageY)
	{
		posx = e.pageX;
		posy = e.pageY;
	}
	else if (e.clientX && e.clientY)
	{
		posx = e.clientX + window.scrollInfo[0];
		posy = e.clientY + window.scrollInfo[1];
	}

	return [posx, posy];
}

function setPosition(obj, newX, newY)
{
	$(obj).setStyle({top:newY + 'px',left:newX + 'px'});
}

function findPosX(obj)
{
	var curleft = 0;
	if (obj.offsetParent)
	{
		while (obj.offsetParent)
		{
			curleft += obj.offsetLeft;
			obj = obj.offsetParent;
		}
	}
	else if (obj.x)
		curleft += obj.x;
	return curleft;
}

function findPosY(obj, opt_UseScrollOffset)
{
	var curtop = 0;
	if (obj.offsetParent)
	{
		while (obj.offsetParent)
		{
			curtop += obj.offsetTop;
			if (opt_UseScrollOffset)
			{
				curtop -= obj.scrollTop;
			}
			obj = obj.offsetParent;
		}
	}
	else if (obj.y)
		curtop += obj.y;
	return curtop;
}

function autoCheck(id, text)
{
	//try to get the element
	var el = $(id);

	if (el == null)
		return;
	if (el && el.id != id) //ie feature that returns an element based on name not id
		return;

	var type = el.getAttribute('type');
	if (type == 'checkbox' || type == 'radio')
	{
		if (text == '' || text == null)
			el.checked = false;
		else
			el.checked = true;
	}
	if ($(el).onclick)
		$(el).onclick();

	if (Qualtrics.syncLabelsAndInputs)
	{
		Qualtrics.syncLabelsAndInputs(false);
	}
}

//The question classes use the following methods in the survey engine...
var SEonSubmit = {
	add: function(onSubmitFunction)
	{
		Event.observe('Page', 'submit', onSubmitFunction);
	}
};

var SEonClick = {
	add: function(onClickFunction)
	{
		Event.observe('Page', 'click', onClickFunction);
	}
};

var SEonMouseDown = {
	add: function(onMouseDownFunction)
	{
		//mousedowns get blocked by some questions types but mouseups are available.
		//this is used by the timing question only and it says click so mouseup is a little more accurate than down anyway
		Event.observe('Page', 'mouseup', onMouseDownFunction);
		Event.observe('Page', 'touchend', onMouseDownFunction);
	}
};


/* here is a good onload example */
var IeFixFlashFixOnload = function(){
	/* fixed the IE Flash activation thing by taking out all the objects and reinserting them
	theObjects = document.getElementsByTagName("object");
	for (var i = 0; i < theObjects.length; i++) {
		theObjects[i].outerHTML = theObjects[i].outerHTML;
	}
	*/
};
function refreshPage()
{
	/* extended by sections DEPRECATED */
}
/**
* SlideToggle(el dom node , options array) toggles the element passed in to display block or none with an animation
*
* option.onExit() will fire last nomatter what
* option.onFinish() will fire after it did any state change
* option.onContract() will fire after it contracted
* option.onExpand() will fire after it expanded
* option.ExpandOnly=true will only expand
* option.ContractOnly=true will only contract
**/
function SlideToggle(el, options)
{

	if(el.inAction != true)
	{
		el.inAction = true; //prevent double clicks from screwing it up
		if(options && options.onStart)
		{
			options.onStart();
		}
		if(Element.getStyle(el, 'display') == 'block')
		{
			if(options && options.ExpandOnly == true)
			{
				el.inAction = false;
				if(options && options.onExit)
				{
					options.onExit();
				}
				return;
			}
			/* contract*/
			if(options && options.toggleArrow)
			{

				ArrowToggle(options.toggleArrow, {ContractOnly:true});
			}

			new Effect.BlindUp(el,
			{
				duration:options.duration || 0.15,
				afterFinish:function()
				{
					el.inAction = false;
					if(refreshPage)
					{
						refreshPage(); //deprecated
					}
					if(options && options.onContract)
					{
						options.onContract();
					}
					if(options && options.onFinish)
					{
						options.onFinish();
					}
					if(options && options.onExit)
					{
						options.onExit();
					}
				}
			});
		}
		else
		{
			if(options && options.ContractOnly == true)
			{
				el.inAction = false;
				if(options && options.onExit)
				{
					options.onExit();
				}
				return;
			}
			/* expand */
			if(options && options.toggleArrow)
			{

				ArrowToggle(options.toggleArrow, {ExpandOnly:true});
			}
			if(options && options.beforeExpand){
				options.beforeExpand();
			}
			new Effect.BlindDown(el,
			{
				duration:options.duration || 0.15,
				afterFinish:function()
				{
					el.inAction = false;
					if(refreshPage)
					{
						refreshPage(); //deprecated
					}
					if(options && options.onExpand)
					{
						options.onExpand();

					}
					if(options && options.onFinish)
					{
						options.onFinish();

					}
					if(options && options.onExit)
					{
						options.onExit();
					}
				}
			});
		}

	}
}
function ArrowToggle(TitleDiv, options){
	if(options && options.ContractOnly){
		$(TitleDiv).addClassName("Collapsed");
		return;
	}
	if(options && options.ExpandOnly){
		$(TitleDiv).removeClassName("Collapsed");
		return;
	}
	if(Element.hasClassName(TitleDiv,'Collapsed')){
		$(TitleDiv).removeClassName("Collapsed");
	}else{
		$(TitleDiv).addClassName("Collapsed");
	}
}
function HelpToggle()
{
	SlideToggle($('HelpContent'),
	{
		onContract:function()
		{
			Element.setStyle($('HelpButton'), {borderBottom:'1px solid #FCD570'});
			$('GapCloser').hide();
		},
		beforeExpand:function()
		{
			Element.setStyle($('HelpButton'), {borderBottom:'none'});
			$('GapCloser').show();
		}
	});
}

/**
 * This function is used in the resizedWindow() function below to resize the contents to the appropriate size.
 * This is used for popup windows.
 * @param HtmlElement element The element we will resize to fit the space.
 * @param HtmlElement container The container that is holding the element.  If not specified it uses the entire
 *  document.
 */
function fillVerticalSpace(element, container)
{
	try
	{
		if (element)
		{
			//some checks to see what we are trying to filling
			if (!container || container.tagName == 'body')
				fillBody = true;
			else
				fillBody = false;
			var newHeight = 0;

		// DEFAULT HEIGHT ----------------------------------------------------------------------------------
			var headerAndFooterHeight = 0;	//Default Header & Footer Height if the header and footer can't be found
		// --------------- ----------------------------------------------------------------------------------
			var mainContentDiv = $('mainContentDiv');
			if (mainContentDiv)
			{
				if (fillBody)
				{
					headerAndFooterHeight += Position.cumulativeOffset(mainContentDiv)[1];
				}
				else if ($('popupMainHeaderDiv'))
				{
					headerAndFooterHeight += Position.cumulativeOffset(mainContentDiv)[1] - Position.cumulativeOffset($('popupMainHeaderDiv'))[1];
				}
			}

			var topOfFooterDiv = $('topOfFooter');
			var botOfFooterDiv = $('bottomOfFooter');
			var footerDiv = $('popupMainFooterDiv');
			if (topOfFooterDiv && botOfFooterDiv)
			{
				var footerHeight = Position.cumulativeOffset(botOfFooterDiv)[1] - Position.cumulativeOffset(topOfFooterDiv)[1];
				headerAndFooterHeight += footerHeight;
			}
			else if (footerDiv)
			{
				footerHeight = footerDiv.offsetHeight;
				headerAndFooterHeight += footerHeight;
			}
			if (fillBody)
			{
				if (window.innerHeight)
				{
					newHeight = window.innerHeight - headerAndFooterHeight;
				}
				else
				{
					newHeight = document.documentElement.clientHeight - headerAndFooterHeight;
				}
			}
			else
			{
				newHeight = $(container).offsetHeight - headerAndFooterHeight;
			}
			element.style.height = newHeight+'px';
		}
	}
	catch(e)
	{
		console.error(e);
	}
}

// This function is called in most popup windows; rights popups, confirmations, etc.
// ideal for ones that have lots of content and require scrolling
function resizedWindow()
{
	fillVerticalSpace($('mainContentDiv'));
}
/**
* This will kill an element and not cause a memory leak in IE
*/
function removeElement(element) {
	if (!element)
		return;

	var garbageBin = $('IELeakGarbageBin');

	if (!garbageBin)
	{
		garbageBin = QBuilder('DIV');
		garbageBin.id = 'IELeakGarbageBin';
		garbageBin.style.display = 'none';
		document.body.appendChild(garbageBin);
	}

	// move the element to the garbage bin
	garbageBin.appendChild(element);
	garbageBin.innerHTML = '';
}

function getMessage(msg)
{
	return '#'+msg;
}

//this is where all new globals need to go
var QualtricsTools =
{
	/**
	* QualtricsTools.createNewId
	*/
	createNewId:function(prefix)
	{
		var number;

		try {
			if((typeof(Uint32Array) !== 'undefined') && window.crypto && window.crypto.getRandomValues) {
				var numbers = new Uint32Array(1);
	  			window.crypto.getRandomValues(numbers);

	  			var numberString = numbers[0].toString(); //will be 0 - 10 numbers long, but left-most zeros are removed since it's an integer
	  			var padding = '00000000'; //8 chars of padding to gurantee random number is at least 8 numbers long

	  			var paddedNumber = padding + numberString;

	  			number = paddedNumber.substring(paddedNumber.length - 8, paddedNumber.length);
			}
		} finally {
			if(!number) {
				number = Math.round(Math.random()*100000000);
			}
		}

		return prefix+'_'+number;
	},

	/*
	* Note: this is not a real guid, it just mimmics a real one. This should NOT be used to store unique sitewide ids
	* use it sparingly as it is expensive!
	*/
	createFauxGUID:function(prefix)
	{
		var S = function() {
			return "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(Math.random()*59));
		};

		return prefix+'_'+S()+S()+S()+S()+S()+S()+S()+S()+S()+S()+S()+S()+S()+S()+S();
	},
	/*
	 *Used to clear selected text that you don't want selected
	 */
	clearSelection:function()
	{
		if (window.getSelection)
		{
			if (window.getSelection().empty) // Chrome
			{
				window.getSelection().empty();
			}
			else if (window.getSelection().removeAllRanges) // Firefox
			{
				window.getSelection().removeAllRanges();
			}
			else if (document.selection) // IE?
			{
				document.selection.empty();
			}
		}
	},
	/**
	* QualtricsTools.focusInput
	* does a better job at focusing in ie6
	* @param {HTMLInputNode | HTMLTextareaNode} - the node you want to focus
	*/
	focusInput:function(el, opt_pos)
	{
		if(opt_pos == undefined)
		{
			$(el).focus();
			return;
		}
		//prototype doesnt do ie very well
		if(el && el.createTextRange)
		{
			var range = el.createTextRange();
			if(range){
				range.collapse(true);
				range.moveStart('character', opt_pos);
				range.moveEnd('character', opt_pos);
				try{
					range.select();
				}catch(e){}
			}
		}
		else if(el)
		{
			if($(el).focus)
			{
				$(el).focus();
				//try to put the focus at the end
				if(el.setSelectionRange)
				{
					try{
						/* this causes random firefox js errors and i dont know why
						TODO: figure out what the error is caused by, it only happens when you edit the x axis of a matrix*/
						el.setSelectionRange(opt_pos,opt_pos);
					}catch(e)
					{

					}
				}
			}
		}
	},

	/**
	* QualtricsTools.getPageSize
	* get page size
	*/
	getPageSize:function()
	{
		//var cached = Qualtrics.Cache.get('PageSize');
		//if (cached !== null)
		//	return cached;
		var xScroll, yScroll;

		if (window.innerHeight && window.scrollMaxY) {
			xScroll = document.body.scrollWidth;
			yScroll = window.innerHeight + window.scrollMaxY;
		} else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
			xScroll = document.body.scrollWidth;
			yScroll = document.body.scrollHeight;
		} else { // Explorer Mac...would also work in Explorer 6 Strict, Mozilla and Safari
			xScroll = document.body.offsetWidth;
			yScroll = document.body.offsetHeight;
		}

		var windowWidth, windowHeight;
		if (self.innerHeight) {	// all except Explorer
			windowWidth = self.innerWidth;
			windowHeight = self.innerHeight;
		} else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
			windowWidth = document.documentElement.clientWidth;
			windowHeight = document.documentElement.clientHeight;
		} else if (document.body) { // other Explorers
			windowWidth = document.body.clientWidth;
			windowHeight = document.body.clientHeight;
		}
		// for small pages with total height less then height of the viewport
		if(yScroll < windowHeight){
			pageHeight = windowHeight;
		} else {
			pageHeight = yScroll;
		}

		// for small pages with total width less then width of the viewport
		if(xScroll < windowWidth){
			pageWidth = windowWidth;
		} else {
			pageWidth = xScroll;
		}
		var arrayPageSize = {pageWidth:pageWidth, pageHeight:pageHeight, windowWidth:windowWidth, windowHeight:windowHeight, 0:pageWidth,1:pageHeight,2:windowWidth,3:windowHeight};
		//Qualtrics.Cache.set('PageSize',arrayPageSize);
		return arrayPageSize;
	},
	getScrollInfo:function()
	{
		if(document.viewport.getScrollOffsets)
		{
			var scrollOffsets = document.viewport.getScrollOffsets();
			return [scrollOffsets.left,scrollOffsets.top];
		}
		return [0,0];
	},
	/**
	* QualtricsTools.getInstanceHelper
	* a lot of objects need to find instances of themselves by the id.
	* so this function just returns the function that does that so we dont have to duplicate it all over the place.
	* @param {Array} registry - the list of objects to search.
	* @param {String} idString - the name of the id attribute to search on.
	* @return {Object|undefined} - the found object instance.
	*/
	getInstanceHelper:function(registry, idString)
	{
		return function(id)
		{
			if (registry.push)
			{
				//registry is an array
				for(var i = 0, len = registry.length; i < len; ++i)
				{
					if(registry[i][idString] == id)
					{
						return registry[i];
					}
				}
			}
			else
			{
				//registry is an object, assume that the key is the id
				if(registry[id])
				{
					return registry[id];
				}
			}
			return undefined;
		};
	},
	/*
	 * Creates a protected intance registry that can do some cool stuff
	 * instead of having a getInstance on every class, you can just create a registry on a base class, then register all of your instances with that
	 * There is a convenient deregister function that will remove the item from the registry, which you should call when the item is destroyed
	 */
	createInstanceRegistry:function()
	{
		var _reg = {};
		return {
			/*
			 * Assigns an id to obj, and places it in the registry
			 * @param {Object} obj - the object to register
			 * @param {String} prefix - the prefix to use to register the object with
			 */
			register:function(obj, prefix)
			{
				obj.id = obj.id || QualtricsTools.createNewId(prefix);
				_reg[obj.id] = obj;
			},
			/*
			 * Removes a registered object from the registry
			 * @param {Object} obj - the object to deregister
			 */
			deregister:function(obj)
			{
				_reg[obj.id] = null;
				delete _reg[obj.id];
			},
			/*
			 * deletes all items out of the registry
			 * could potentially just set _reg = {}, though I'm not sure about the memory implicaions
			 */
			clearRegistry:function()
			{
				for(var i in _reg)
				{
					_reg[i] = null;
					delete _reg[i];
				}
			},
			/*
			 * Returns an instance of the object
			 */
			getInstance:function(id)
			{
				return _reg[id];
			},
			/*
			 *  Will return all instances that match search
			 */
			getInstancesLike:function(search)
			{
				var ret = [];
				for (var i in _reg)
				{
					if (i.indexOf(search) !== -1)
					{
						ret.push(_reg[i]);
					}
				}
				return ret;
			},
			/*
			 * runs a callback on each function in the registry
			 */
			executeOnAll:function(func)
			{
				for (var i in _reg)
				{
					if (typeof _reg[i][func] == 'function')
						_reg[i][func]();
				}
			}
		};
	},
	sortByKey:function(array, key)
	{
		return array.sort(function(a, b) {
			var x = a[key];var y = b[key];
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		});
	},
	/**
	* QualtricsTools.fastDown finds an child node with the specified class name.
	* NOTE: this is NOT AN COMPLETE SEARCH, it only goes down direct levels, meaning it searches every FIRST CHILD.
	* if the thing you are searching for needs to branch from a sibling this will be VERY SLOW in IE.
	* @param Node startNode - the node to start from.
	* @param String className - the class name you are searching for
	* @param Int maxDepth - the number of levels to search before giving up
	*/
	fastDown:function(startNode, className, maxDepth)
	{
		//if the element matches what they passed then just return it
		if($(startNode).hasClassName(className))
		{
			return startNode;
		}
		var parentNode = startNode;
		var lastRealNode = null;
		if(maxDepth == undefined)
		{
			maxDepth = 10;
		}
		for(var i = 0; i < maxDepth; ++i)
		{
			if(!parentNode.firstChild)
			{
				break;
			}
			var child = parentNode.firstChild;
			if(child && child.nodeType == 3 && child.nextSibling)
			{
				//we got a text node. so lets try 1 sibling accross (this is useful for bypassing newlines in handwritten html)
				child = child.nextSibling;
			}
			if(child)
			{
				if(child.nodeType == 1)
				{

					if($(child).hasClassName(className))
					{
						return child;
					}
					//check 1 sibling across, this helps not go to xpath in a lot of cases.
					else if(child.nextSibling && child.nextSibling.nodeType == 1 && $(child.nextSibling).hasClassName(className))
					{
						return child.nextSibling;
					}
					//search the child
					parentNode = child;
				}

			}
		}
		if(!className) return child; //if there is no class criteria we just return the bottom most child.

		//this is super slow on ie so we dont want to do this
		return $(startNode).down('.'+className);//the innermost object with the actual text
	},
	/**
	* fastUp finds an ancestor node with the specified class name.
	* @param Node startNode - the node to start from.
	* @param String className - the class name you are searching for
	* @param Int maxDepth - the number of levels to search before giving up
	*/
	fastUp:function(startNode, className, maxDepth)
	{
		if (!$(startNode))
			return null;
		//if the element matches what they passed then just return it
		if($(startNode).hasClassName && $(startNode).hasClassName(className))
		{
			return startNode;
		}
		var thisNode = startNode;
		if(maxDepth == undefined)
		{
			maxDepth = 10;
		}
		for(var i = 0; i < maxDepth; ++i)
		{
			var parent = thisNode.parentNode;
			if(parent)
			{
				if(parent.nodeType == 1)
				{
					if($(parent).hasClassName && $(parent).hasClassName(className))
					{
						return parent;
					}
					thisNode = parent;
				}
			}
		}
		if ($(startNode).up)
			return $(startNode).up('.'+className);
		else
			return null;
	},
	/**
	 * An object that can get information about the browser.
	 * NOTE: this is used for the browser question type to report browser info to the user
	 * it should not be used for code branching because it will return things like Safari instead of webkit.
	 */
	BrowserInfo:
	{
		/** A cache of the browser's information so we don't repeat work. */
		cachedBrowserInfo: null,

		// Flash Player Version Detection - Rev 1.6
		// Detect Client Browser type
		// Copyright(c) 2005-2006 Adobe Macromedia Software, LLC. All rights reserved.
		// Taken from AC_OETags.js - http://www.adobe.com/products/flashplayer/download/detection_kit/
		Flash:
		{
			isIE: (navigator.appVersion.indexOf("MSIE") != -1) ? true : false,
			isWin: (navigator.appVersion.toLowerCase().indexOf("win") != -1) ? true : false,
			isOpera: (navigator.userAgent.indexOf("Opera") != -1) ? true : false,
			ControlVersion: function()
			{
				var version;
				var axo;
				var e;

				// NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry

				try {
					// version will be set for 7.X or greater players
					axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
					version = axo.GetVariable("$version");
				} catch (e) {
				}

				if (!version)
				{
					try {
						// version will be set for 6.X players only
						axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");

						// installed player is some revision of 6.0
						// GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
						// so we have to be careful.

						// default to the first public version
						version = "WIN 6,0,21,0";

						// throws if AllowScripAccess does not exist (introduced in 6.0r47)
						axo.AllowScriptAccess = "always";

						// safe to call for 6.0r47 or greater
						version = axo.GetVariable("$version");

					} catch (e) {
					}
				}

				if (!version)
				{
					try {
						// version will be set for 4.X or 5.X player
						axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
						version = axo.GetVariable("$version");
					} catch (e) {
					}
				}

				if (!version)
				{
					try {
						// version will be set for 3.X player
						axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
						version = "WIN 3,0,18,0";
					} catch (e) {
					}
				}

				if (!version)
				{
					try {
						// version will be set for 2.X player
						axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
						version = "WIN 2,0,0,11";
					} catch (e) {
						version = -1;
					}
				}

				return version;
			},
			// JavaScript helper required to detect Flash Player PlugIn version information
			GetSwfVer: function(){
				// NS/Opera version >= 3 check for Flash plugin in plugin array
				var flashVer = -1;

				if (navigator.plugins != null && navigator.plugins.length > 0) {
					if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
						var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
						var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
						var descArray = flashDescription.split(" ");
						var tempArrayMajor = descArray[2].split(".");
						var versionMajor = tempArrayMajor[0];
						var versionMinor = tempArrayMajor[1];
						var versionRevision = descArray[3];
						if (versionRevision == "") {
							versionRevision = descArray[4];
						}
						if (versionRevision[0] == "d") {
							versionRevision = versionRevision.substring(1);
						} else if (versionRevision[0] == "r") {
							versionRevision = versionRevision.substring(1);
							if (versionRevision.indexOf("d") > 0) {
								versionRevision = versionRevision.substring(0, versionRevision.indexOf("d"));
							}
						}
						flashVer = versionMajor + "." + versionMinor + "." + versionRevision;
					}
				}
				// MSN/WebTV 2.6 supports Flash 4
				else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.6") != -1) flashVer = 4;
				// WebTV 2.5 supports Flash 3
				else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.5") != -1) flashVer = 3;
				// older WebTV supports Flash 2
				else if (navigator.userAgent.toLowerCase().indexOf("webtv") != -1) flashVer = 2;
				else if ( this.isIE && this.isWin && !this.isOpera ) {
					flashVer = this.ControlVersion();
				}
				return flashVer;
			}
		},
		/** Parses the user agent string and gets the information about the browser */
		_parseUserAgent: function(userAgent)
		{
			var agentString = userAgent || (typeof navigator !== 'undefined' ? navigator.userAgent : '');
			var browserInfo = {
			  ua: agentString,
			  browser: ''
			};

			var rvPattern = /rv:([\d+\.]+)/;
			var uaPattern = /(([^\/\s]*)\/([^\s;]*))/;
			var pattern;
			var ua = agentString;
			var matches = true; //we always want to try once...
			while (matches)
			{
			  matches = uaPattern.exec(ua);
			  if (matches)
			  {
				ua = RegExp.rightContext;

				//see if we have a valid browser
				if (matches[2] && matches[2].toLowerCase)
				{
				  switch (matches[2].toLowerCase())
				  {
					case 'chrome':
					  browserInfo.browser = matches[2];
					  browserInfo.version = matches[3];
					  if (ua.toLowerCase().indexOf('edge') === -1)
					  { //edge claims it is chrome
						matches = false; //chrome claims it is safari so preterminate
					  }
					  break;
					case 'trident':
					  if (parseFloat(matches[3]) >= 7)
					  {
						//microsoft made ie 11 use rv:#.# format - in non compatibility mode
						var versionMatches = rvPattern.exec(ua);
						if (versionMatches) {
						  browserInfo.browser = 'MSIE';
						  browserInfo.version = versionMatches[1];
						  matches = false; //preterminate because ie11 wants to be a lot of things
						}
					  }
					  break;
					case 'edge':
					case 'firefox':
					case 'netscape':
					case 'safari':
					case 'camino':
					case 'mosaic':
					case 'galeon':
					case 'opera':
					case 'mozilla':
					case 'konqueror':
					case 'applewebkit':
					case 'nintendobrowser':
						browserInfo.browser = matches[2];
						browserInfo.version = matches[3];
				  }
				}
			  }
			}

			if (browserInfo.browser == 'Mozilla')
			{
				//check to see if we have a "compatible browser"
				// Mozilla compatible (MSIE, konqueror, etc)
				if (browserInfo.browser == 'Mozilla' && agentString.indexOf('(compatible;') != -1)
				{
					pattern = /\(compatible; ([^ ]*)[ \/]([^;]*).*/;
					matches = pattern.exec(agentString);
					if (matches)
					{
						browserInfo.browser = matches[1];
						browserInfo.version = matches[2];
					}
				}
			}

			// handles the default case in the switch statement below. Intentionally a closure that has browserInfo enclosed.
			function handleDefaultOS()
			{
				//grab it after the U;
				pattern = /U;\s*([^;\)]*)/;
				matches = pattern.exec(agentString);

				if (matches)
				{
				  browserInfo.os = matches[1];
				}
				else
				{
					// Grab the parenthesized bit
					pattern = /\(([^)]*)\)/;
					matches = pattern.exec(agentString);
					if (matches)
					{
						matches = matches[1].split(';');
						if (matches[0][0] == 'X')
						{
							// Linux X11 UserAgent string for FF4+ goes (X11; Linux i686; rv:spoo). Obviously we want the "Linux" part
							browserInfo.os = matches[1];
						}
						else if (matches[0] == 'Mobile' && matches[1])
						{
							// Windows Phone 8.1 ua: (Mobile; Windows Phone 8.1;...)
							browserInfo.os = matches[1];
						}
						else if (matches[0] == 'Linux' && matches[1] && matches[1].indexOf('Android') !== -1)
						{
							// Android phones ua: (Linux; Android 4.4.2;...)
							browserInfo.os = matches[1];
						}
						else
						{
							browserInfo.os = matches[0];
						}
					}
				}

				if (browserInfo.os) {
					browserInfo.os = browserInfo.os.trim();
				}
			}

			handleDefaultOS();

			if (browserInfo.os == 'iPad' || browserInfo.os == 'iPhone') {
				browserInfo.browser = 'Safari';
				browserInfo.version = 'Unknown';
			}

			//try to grab the operating system and do a check for the iphone
			switch (browserInfo.browser.toLowerCase())
			{
				case 'msie':
					//after msie XX; (second 3rd paramter)
					pattern = /\(compatible;[^;]*;\s*([^;\)]*)/;
					matches = pattern.exec(agentString);
					if (matches)
					{
						browserInfo.os = matches[1];
					}
					else
					{
						handleDefaultOS();
					}
					break;
				case 'opera':
				  //the first value after the (
				  pattern = /\(([^;\)]*)/;
				  matches = pattern.exec(agentString);
				  browserInfo.os = matches[1];
				  break;
				case 'konqueror':
				  //after konqueror
				  pattern = /Konqueror[^;]*;\s*([^;\)]*)/;
				  matches = pattern.exec(agentString);
				  browserInfo.os = matches[1];
				  break;
				//the most common, after the U;
				case 'safari':

					// Chrome for iPhone does not have a "Version" tag, it is hidden else where in the user agent
					// Try to get the verison from the version tag
					pattern = /Version\/([^ ]*)/;
					matches = pattern.exec(agentString);
					if (matches && matches[1])
					{
					  // If we don't have the version we look elsewhere
					  matches = pattern.exec(agentString);
					  browserInfo.version = matches && matches[1];
					}
					else
					{
						pattern = /CriOS\/([^ ]*)/;
						matches = pattern.exec(agentString);
						if (matches && matches[1])
						{
							// If we don't have the version we look elsewhere
							matches = pattern.exec(agentString);
							browserInfo.version = matches && matches[1];
							//make the browser say Chrome
							browserInfo.browser = 'Chrome';
						}
					}

					if (agentString.indexOf('iPhone') != -1)
					{
						//make the browser say iPhone
						browserInfo.browser += ' iPhone';
					}
					if (agentString.indexOf('iPad') != -1)
					{
						//make the browser say iPad
						browserInfo.browser += ' iPad';
					}

					//not an iphone do the normal behavior
					/* falls through */
				case 'firefox':
				/* falls through */
				default:
					handleDefaultOS();
					break;
			}

			if (browserInfo.os)
			{
				browserInfo.os = browserInfo.os.replace(/^\s+|\s+$/g, ''); // equivalent to String.trim(), but compatible with IE8
			}

			//get the screen resolution
			browserInfo.resolution = {x: screen.width , y: screen.height};
			//get if it supports java
			browserInfo.java = navigator.javaEnabled() ? 1 : 0;
			//get the flash version
			browserInfo.flashVersion = this.Flash.GetSwfVer();
			//replace , with . (ie gives commas) and remove WIN
			if (browserInfo.flashVersion && browserInfo.flashVersion.replace)
			{
				browserInfo.flashVersion = browserInfo.flashVersion.replace(/,/g,'.');
				browserInfo.flashVersion = browserInfo.flashVersion.replace(/WIN /g,'');
			}

			return browserInfo;
		},
		/** Returns the browser's information */
		getBrowserInfo: function()
		{
			if (!this.cachedBrowserInfo)
				this.cachedBrowserInfo = this._parseUserAgent();
			return this.cachedBrowserInfo;
		},
		/**
		 * We make a high accuracy request and then try a medium accuracy call incase they have separate permissions
		 * Cross browser code modified from https://github.com/estebanav/javascript-mobile-desktop-geolocation
		 */
		getCurrentPosition: function(callback)
		{

			//enableHighAccuracy	Boolean		false			true might be slower
			//timeout				long		(no default)	in milliseconds
			//maximumAge			long		0				in milliseconds

			var timeout = 10000;
			var maximumAge = 60000;

			var highAccuracyOpts = {
				enableHighAccuracy: true,
				timeout: timeout,
				maximumAge: maximumAge
			};

			var mediumAccuracyOpts = {
				enableHighAccuracy: false,
				timeout: timeout,
				maximumAge: maximumAge
			};

			var mediumAccuracySuccess = function(pos) {
				var returnData = {
					accuracy: pos.coords.accuracy || -1,
					latitude: pos.coords.latitude,
					longitude: pos.coords.longitude
				};

				this.getBrowserInfo();
				this.cachedBrowserInfo.locationaccuracy = returnData.accuracy;
				this.cachedBrowserInfo.latitude = returnData.latitude;
				this.cachedBrowserInfo.longitude = returnDataos.longitude;

				if (callback)
					callback(returnData);
			}.bind(this);

			var mediumAccuracyError = function(pos) {
				this.getBrowserInfo();
				this.cachedBrowserInfo.locationerror = pos.code;

				if (callback)
					callback({error: pos.code});
			}.bind(this);

			var highAccuracySuccess = function(pos) {

				var returnData = {
					accuracy: pos.coords.accuracy || -1,
					latitude: pos.coords.latitude,
					longitude: pos.coords.longitude
				};

				this.getBrowserInfo();
				this.cachedBrowserInfo.locationaccuracy = returnData.accuracy;
				this.cachedBrowserInfo.latitude = returnData.latitude;
				this.cachedBrowserInfo.longitude = returnData.longitude;

				if (callback)
					callback(returnData);

			}.bind(this);

			var highAccuracyError = function(pos) {
				// fallback to a medium accuracy call
				this.geoPosition.getCurrentPosition(mediumAccuracySuccess, mediumAccuracyError, mediumAccuracyOpts);
			}.bind(this);

			// Make the highaccuracy call
			if (!this.geoPosition.getCurrentPosition(highAccuracySuccess, highAccuracyError, highAccuracyOpts))
			{
				// geolocation was not allowed
				this.getBrowserInfo();
				this.cachedBrowserInfo.locationerror = 1;
				callback({locationerror: 1});
			}

		},
		geoPosition:function()
		{

			var pub = {};
			var provider=null;
			var u="undefined";
			var getCurrentPosition;

			pub.getCurrentPosition = function(success, error, opts)
			{
			  try
			  {
				var hasGeolocation = typeof(navigator.geolocation)!=u;

				if( !hasGeolocation )
				{
				  if(!confirm('Qualtrics wants to use your location.\nDo you want to allow it?')())
				  {
					return false;
				  }
				}

				if ((typeof(geoPositionSimulator)!=u) && (geoPositionSimulator.length > 0))
				{
				  provider=geoPositionSimulator;
				}
				else if (typeof(bondi)!=u && typeof(bondi.geolocation)!=u)
				{
				  provider=bondi.geolocation;
				}
				else if (hasGeolocation)
				{
				  provider=navigator.geolocation;
				  getCurrentPosition = function(success, error, opts)
				  {
					function _success(p)
					{
					  //for mozilla geode,it returns the coordinates slightly differently
					  var params;
					  if(typeof(p.latitude)!=u)
					  {
						params = {
						  timestamp: p.timestamp,
						  coords: {
							latitude:  p.latitude,
							longitude: p.longitude
						  }
						};
					  }
					  else
					  {
						  params = p;
					  }
					  success( params );
					}
					provider.getCurrentPosition(_success,error,opts);
				  };
				}
				else if(typeof(window.blackberry)!=u && blackberry.location.GPSSupported)
				{
					// set to autonomous mode
					if(typeof(blackberry.location.setAidMode)==u)
					{
						return false;
					}
					blackberry.location.setAidMode(2);
					//override default method implementation
					getCurrentPosition = function(success, error, opts)
					{
						var bb = {
							success: 0,
							error: 0,
							blackberryTimeoutId : -1
						};
						function handleBlackBerryLocationTimeout()
						{
							if(bb.blackberryTimeoutId!=-1)
							{
								bb.error({
									message: "Timeout error",
									code: 3
								});
							}
						}
						//passing over callbacks as parameter didn't work consistently
						//in the onLocationUpdate method, thats why they have to be set outside
						bb.success = success;
						bb.error = error;
						//function needs to be a string according to
						//http://www.tonybunce.com/2008/05/08/Blackberry-Browser-Amp-GPS.aspx
						if(opts['timeout'])
						{
							bb.blackberryTimeoutId = setTimeout(handleBlackBerryLocationTimeout, opts['timeout']);
						}
						else
						{
							//default timeout when none is given to prevent a hanging script
							bb.blackberryTimeoutId = setTimeout(handleBlackBerryLocationTimeout, 60000);
						}
						blackberry.location.onLocationUpdate(function ()
						{
							clearTimeout(bb.blackberryTimeoutId);
							bb.blackberryTimeoutId=-1;
							if (bb.success && bb.error)
							{
								if(blackberry.location.latitude==0 && blackberry.location.longitude==0)
								{
									//http://dev.w3.org/geo/api/spec-source.html#position_unavailable_error
									//POSITION_UNAVAILABLE (numeric value 2)
									bb.error({message:"Position unavailable", code:2});
								}
								else
								{
								  var timestamp=null;
								  //only available with 4.6 and later
								  //http://na.blackberry.com/eng/deliverables/8861/blackberry_location_568404_11.jsp
								  if (blackberry.location.timestamp)
								  {
									  timestamp = new Date( blackberry.location.timestamp );
								  }
								  bb.success({
										timestamp:timestamp,
										coords: {
											latitude:  blackberry.location.latitude,
											longitude: blackberry.location.longitude
										}
								  });
								}
								//since blackberry.location.removeLocationUpdate();
								//is not working as described http://na.blackberry.com/eng/deliverables/8861/blackberry_location_removeLocationUpdate_568409_11.jsp
								//the callback are set to null to indicate that the job is done

								bb.success = null;
								bb.error = null;
						  }
						});
						blackberry.location.refreshLocation();
					};
					provider = blackberry.location;

				}
				else if (typeof(Mojo) !=u && typeof(Mojo.Service.Request)!="Mojo.Service.Request")
				{
					provider = true;
					getCurrentPosition = function(success, error, opts)
					{
					  parameters = {};
					  if( opts )
					  {
						 //http://developer.palm.com/index.php?option=com_content&view=article&id=1673#GPS-getCurrentPosition
						 if (opts.enableHighAccuracy && opts.enableHighAccuracy == true)
						 {
							parameters.accuracy = 1;
						 }
						 if (opts.maximumAge)
						 {
							parameters.maximumAge = opts.maximumAge;
						 }
						 if (opts.responseTime)
						 {
							if( pts.responseTime < 5)
							{
							  parameters.responseTime = 1;
							}
							else if (opts.responseTime < 20)
							{
							  parameters.responseTime = 2;
							}
							else
							{
							  parameters.timeout = 3;
							}
						 }
					  }

					  r = new Mojo.Service.Request( 'palm://com.palm.location' , {
						method:"getCurrentPosition",
						  parameters:parameters,
						  onSuccess: function( p )
						  {
							success( {timestamp: p.timestamp,
							   coords: {
								latitude:  p.latitude,
								longitude: p.longitude,
								heading:   p.heading
							  }
							});
						  },
						  onFailure: function( e )
						  {
							if (e.errorCode==1)
							{
							  error({
								code: 3,
								message: "Timeout"
							  });
							}
							else if (e.errorCode==2)
							{
							  error({
								code: 2,
								message: "Position unavailable"
							  });
							}
							else
							{
							  error({
								code: 0,
								message: "Unknown Error: webOS-code" + errorCode
							  });
							}
						  }
					  });
					};
				}
				else if (typeof(device)!=u && typeof(device.getServiceObject)!=u)
				{
				  provider=device.getServiceObject("Service.Location", "ILocation");

				  //override default method implementation
				  getCurrentPosition = function(success, error, opts)
				  {
					function callback(transId, eventCode, result)
					{
					  if (eventCode == 4)
					  {
						error({message:"Position unavailable", code:2});
					  }
					  else
					  {
						//no timestamp of location given?
						success( {
						  timestamp:null,
						  coords: {
							latitude:   result.ReturnValue.Latitude,
							longitude:  result.ReturnValue.Longitude,
							altitude:   result.ReturnValue.Altitude,
							heading:	result.ReturnValue.Heading}
						  });
					  }
					}
					//location criteria

					var criteria = new Object();
					criteria.LocationInformationClass = "BasicLocationInformation";
					//make the call
					provider.ILocation.GetLocation(criteria,callback);
				  };
				}
				else  {
				  provider = false;
				}

				if (provider && getCurrentPosition)
				{
				  getCurrentPosition(success, error, opts);
				  return true;
				} else {
				  // geolocation is not avaliable
				  return false;
				}

			  }
			  catch (e)
			  {
				if( typeof(console) != u ) console.log(e);
				return false;
			  }
			  return  provider!=null;
			};
			return pub;
		}()
	},
	/**
	 * QualtricsTools.cumulativeScrollOffset
	 * just like the prototype Element.cumulativeScrollOffset
	 * except it doesnt include the page scroll values
	 * I find this to be more useful.
	 *
	 * @param {Node} element
	 * @return {Array} [x, y]
	 */
	cumulativeScrollOffset:function(element)
	{
		var scrollElement = element;
		var scrollOffset = [0,0];
		do {
			if(scrollElement.nodeName !== 'HTML' && scrollElement.nodeName !== 'BODY')
			{
		  		scrollOffset[0] += scrollElement.scrollLeft || 0;
		  		scrollOffset[1] += scrollElement.scrollTop  || 0;
	  		}
			scrollElement = scrollElement.parentNode;
		} while (scrollElement);
		return scrollOffset;
	},
	/**
	 * Checks to see if an element is fixed position, or if any of it's ancestors are fixed position
	 * @param {Node} element
	 * @returns {Boolean}
	 */
	isFixed:function(element)
	{
		try
		{
			var position = $(element).getStyle('position');
		}
		catch (e)
		{
			// Fix IE8's issues
			position = element.style.position;
		}

		try
		{
			var offsetParent = element.offsetParent;
		}
		catch (e)
		{
			// Yet another one of IE8's problems. IE8 dies when you attempt to access offsetParent
			offsetParent = document.body;
		}

		return (!!element) && (element.style && position == 'fixed' || offsetParent && QualtricsTools.isFixed(offsetParent));
	},
	/*
	 * will add an element to the hidden helper so you can do cool stuff with it
	 * Like get the size before you actually append it to something
	 * Or make a sortable before the sortable is even returned :)
	 */
	addToHiddenHelper:function(element)
	{
		var hidden = $('QHiddenHelper');
		if(!hidden)
		{
			hidden = QBuilder('div',{id:'QHiddenHelper'});
			document.body.appendChild(hidden);
		}
		//append our container to the document
		hidden.appendChild($(element));
	},
	getSurveySelectMenu:function(opt_filter, opt_action)
	{
		opt_filter = (opt_filter === "") ? undefined : opt_filter;
		if (!opt_action)
		{
			opt_action = 'URLTools.post(setActiveSurvey, $surveyId)';
		}
		var items = [];

		if(Qualtrics.folders && opt_filter === undefined && !Object.isArray(Qualtrics.folders['SurveyFolders']))
		{
			// Reorder the folders by name so they show up in order within the menu
			folderOrdering = [];
			for(var folderId in Qualtrics.folders['SurveyFolders'])
			{
				folderOrdering.push({'id':folderId, 'name':Qualtrics.folders['SurveyFolders'][folderId]});
			}
			folderOrdering.sort(function(a, b) {
				var lowerA = a['name'].toLowerCase();
				var lowerB = b['name'].toLowerCase();
				if(lowerA < lowerB) return -1;
				if(lowerA == lowerB) return 0;
				if(lowerA > lowerB) return 1;
			});

			for(var i = 0; i < folderOrdering.length; ++i)
			{
				var folderId = folderOrdering[i]['id'];

				var subMenuItems = [];

				for(var surveyId in Qualtrics.folders['Surveys'])
				{
					if(typeof Qualtrics.folders['Surveys'][surveyId] == 'function')
					{
						continue;
					}
					//loop through all the surveys
					var containingFolderId = Qualtrics.folders['Surveys'][surveyId];
					if(folderId == containingFolderId && Qualtrics.surveys[surveyId]) // Make sure we have perms to edit this survey
					{
						//replace $surveyID with current surveyID
						var current_action = opt_action.replace('$surveyId', surveyId);

						//if the container folder is the current folder then add it as a submenu item
						subMenuItems.push({
							label:Qualtrics.surveys[surveyId],
							action:current_action,
							className:'Survey',
							defer:true
						});
					}
				}
				var item = {
					label:Qualtrics.folders['SurveyFolders'][folderId],
					className:'Folder',
					submenu:{
						items:subMenuItems
					}
				};
				items.push(item);
			}
			items.push({separator:true});
		}

		for(surveyId in Qualtrics.surveys)
		{
			if (!Qualtrics.surveys.hasOwnProperty(surveyId))
			{
				//If Qualtrics.surveys is empty, it will iterate through __proto__ which is appended
				// by js prototype.  Filter these out with this if check.
				continue;
			}

			var inFolder = Qualtrics.folders && Qualtrics.folders['Surveys'] && Qualtrics.folders['Surveys'][surveyId];
			var showMenu = !inFolder;
			if(opt_filter !== undefined)
			{
				//if we are filtering we forget about folders all together
				showMenu = (Qualtrics.surveys[surveyId].toLowerCase().indexOf(opt_filter.toLowerCase()) != -1);
			}
			if(showMenu)
			{
				//replace $surveyID with current surveyID
				var current_action = opt_action.replace('$surveyId', surveyId);

				item = {
					label:Qualtrics.surveys[surveyId],
					action:current_action,
					className:'Survey',
					defer:true
				};
				items.push(item);
			}
		}
		var searchValue = opt_filter || getMessage('EditSection','SearchExistingSurveys')+"...";
		var surveySelectMenuDef = {
			items:items,
			searchText:searchValue,
			search:'QualtricsTools.getSurveySelectMenu($search, '+opt_action+')'
		};
		return surveySelectMenuDef;
	},
	surveySelectKeyDownHandler:function(el, evt, callback)
	{
		if (Qualtrics.Navigation.subSection == 'Blocks')
		{
			if (evt && evt.shiftKey && (evt.ctrlKey || evt.metaKey))
			{
				if (evt.preventDefault)
					evt.preventDefault();

				return QModules.loadModule('supportmode.js');
			}
		}
		Qualtrics.Menu.showMenu(callback, el, null, evt);
	},
	/**
	 *  color conversion helpers
	 *  ---'hex string' refers to colors in the format '#DF93AF'
	 *  ---'dec' refers to ints or hex numeric values
	 */
	decToHexString:function(dec, includeHash)
	{
		if(typeof dec == 'string' && dec.substr(0,1) == '#') //double check to make sure it's not already hex
		{
			return dec;
		}

		var hex = dec.toString(16);
		hex = QualtricsTools.leftPadString(hex, '0', 6);
		return (includeHash === false ?'':'#')+hex.toUpperCase();
	},
	hexStringToDec:function(hex)
	{
		return parseInt(QualtricsTools.stripHash(hex),16);
	},
	hexStringToRgb:function(hex)
	{
		hex = QualtricsTools.stripHash(hex);
		var splitHex = hex.match(/.{1,2}/g);
		var rgb = [];
		for (var i = 0; i < splitHex.length; i++)
		{
			rgb.push(parseInt(splitHex[i],16));
		}
		return rgb;
	},
	//takes an array of rgb values
	rgbToHexString:function(rgb, includeHash)
	{
		var hex = (includeHash === false) ? '' : '#';
		for (var i = 0; i < rgb.length; i++)
		{
			var val = Math.round(rgb[i]);
			if (val < 0)
				val = 0;
			else if (val > 255)
				val = 255;
			val = QualtricsTools.leftPadString(val.toString(16), '0', 2);
			hex += val.toUpperCase();
		}
		return hex;
	},
	hexStringToHsv:function(hex)
	{
		var rgb = QualtricsTools.hexStringToRgb(hex);
		return QualtricsTools.rgbToHsv(rgb);
	},
	hsvToHexString:function(hsv, includeHash)
	{
		var rgb = QualtricsTools.hsvToRgb(hsv);
		return QualtricsTools.rgbToHexString(rgb, includeHash);
	},
	hsvToRgb:function(hsv)
	{
		var rgb = [0,0,0];
		if (hsv[2] != 0)
		{
			var i = Math.floor(hsv[0] * 6);
			var f = (hsv[0] * 6) - i;
			var p = hsv[2] * (1 - hsv[1]);
			var q = hsv[2] * (1 - (hsv[1] * f));
			var t = hsv[2] * (1 - (hsv[1] * (1 - f)));

			switch(i)
			{
				case 1:
					rgb[0] = q;
					rgb[1] = hsv[2];
					rgb[2] = p;
					break;
				case 2:
					rgb[0] = p;
					rgb[1] = hsv[2];
					rgb[2] = t;
					break;
				case 3:
					rgb[0] = p;
					rgb[1] = q;
					rgb[2] = hsv[2];
					break;
				case 4:
					rgb[0] = t;
					rgb[1] = p;
					rgb[2] = hsv[2];
					break;
				case 5:
					rgb[0] = hsv[2];
					rgb[1] = p;
					rgb[2] = q;
					break;
				case 6: //fall through
				case 0:
					rgb[0] = hsv[2];
					rgb[1] = t;
					rgb[2] = p;
					break;
			}
		}

		//hsv is in percent, so convert to 256 by multiplying by 256!
		for (var index = 0; index < rgb.length; index++)
		{
			rgb[index] *= 256;
		}

		return rgb;
	},
	rgbToHsv:function(rgb)
	{
		var max = rgb.max();
		var min = rgb.min();

		var hsv = [0,0,(max/256)];

		if (min != max)
		{
			var delta = max - min;
			hsv[1] = delta / max;
			if (rgb[0] == max)
			{
				hsv[0] = (rgb[1] - rgb[2]) / delta;
			}
			else if (rgb[1] == max)
			{
				hsv[0] = 2 + ((rgb[2] - rgb[0]) / delta);
			}
			else
			{
				hsv[0] = 4 + ((rgb[0] - rgb[1]) / delta);
			}

			hsv[0] /= 6;

			if (hsv[0] < 0)
			{
				hsv[0] += 1;
			}
			if (hsv[0] > 1)
			{
				hsv[0] -= 1;
			}
		}

		return hsv;
	},
	/**
	 * darkens a hex color
	 * @param {String} hex - a hex color with or without the #
	 * @param {Number} amount is a scale from 0 to 1
	 **/
	darkenColor:function(hex, amount)
	{
		var rgb = QualtricsTools.hexStringToRgb(hex);
		var hsv = QualtricsTools.rgbToHsv(rgb);
		var hueAdjustment = 0;
		//bump the hue if its into the yellow, this has the effect of making it more orange.
		if(hsv[0] < 0.15)
		{
			hueAdjustment = (hsv[0] / 2);
			hsv[0] -= hueAdjustment;
		}
		//lower the value
		var valueFactor = amount;

		hsv[2] = (hsv[2] - valueFactor) + hueAdjustment; //if we do hue adjustments we need less value adjustments
		if(hsv[2] < 0){
			hsv[2] = 0;
		}

		rgb = QualtricsTools.hsvToRgb(hsv);
		return QualtricsTools.rgbToHexString(rgb, true);
	},
	/**
	 * lightens a hex color
	 * @param {String} hex - a hex color with or without the #
	 * @param {Number} amount is a scale from 0 to 1
	 **/
	lightenColor:function(hex, amount)
	{
		var rgb = QualtricsTools.hexStringToRgb(hex);
		var hsv = QualtricsTools.rgbToHsv(rgb);
		var hueAdjustment = 0;
		//bump the hue if its into the yellow, this has the effect of making it more orange.
		if(hsv[0] < 0.15)
		{
			hueAdjustment = (hsv[0] / 2);
			hsv[0] -= hueAdjustment;
		}
		//lower the value
		var valueFactor = Number(amount);

		hsv[2] = (hsv[2] + valueFactor) + hueAdjustment; //if we do hue adjustments we need less value adjustments
		if(hsv[2] > 1){
			hsv[2] = 1;
		}

		rgb = QualtricsTools.hsvToRgb(hsv);
		return QualtricsTools.rgbToHexString(rgb, true);
	},
	fadeColor:function(hex, amount)
	{
		var rgb = QualtricsTools.hexStringToRgb(hex);
		var hsv = QualtricsTools.rgbToHsv(rgb);
		var hueAdjustment = 0;
		//bump the hue if its into the yellow, this has the effect of making it more orange.
		if(hsv[0] < 0.15)
		{
			hueAdjustment = (hsv[0] / 2);
			hsv[0] -= hueAdjustment;
		}
		//lower the saturation
		var saturationFactor = 1-amount;

		hsv[1] = (hsv[1] - (saturationFactor));
		if(hsv[1] < 0){
			hsv[1] = 0;
		}
		var valueFactor = (Number(amount));
		//the value needs to go up

		hsv[2] = (hsv[2] + (valueFactor)); //if we do hue adjustments we need less value adjustments

		if(hsv[2] > 1){
			hsv[2] = 1;
		}

		rgb = QualtricsTools.hsvToRgb(hsv);

		return QualtricsTools.rgbToHexString(rgb, true);
	},
	stripHash:function(hex)
	{
		return (hex.substr(0,1) == '#') ? hex = hex.substr(1) : hex;
	},
	leftPadString:function(string, pad, length)
	{
		while(string.length < length)
		{
			string = pad + string;
		}
		return string;
	},
	//returns a color that would look good on another color
	getColorComplement:function(color)
	{
		if (typeof color == 'number')
		{
			color = QualtricsTools.decToHexString(color, true);
		}

		var hasHash = (color.substr(0,1) == '#');

		var hsv = QualtricsTools.hexStringToHsv(color);

		if (hsv[2] == 0)
		{
			hsv[2] = 0.999;
		}
		else if (hsv[2] < 0.3)
		{
			hsv[2] *= 1.8;
		}
		else
		{
			hsv[2] *= 0.2;
		}

		return QualtricsTools.hsvToHexString(hsv, hasHash);
	},
	getQueryVariable:function(URL, paramToFind)
	{
		var questionMark = URL.split('?');
		if (questionMark.length != 2)
			return null;

		var vars = questionMark[1].split('&');
		for (var i = 0; i < vars.length; i++)
		{
			var pair = vars[i].split('=');
			if (decodeURIComponent(pair[0]) === paramToFind)
				return decodeURIComponent(pair[1]);
		}
		return null;
	},
	isArray:function(v, opt_andNotEmpty)
	{
		return v && Object.prototype.toString.call(v) === "[object Array]" && (!opt_andNotEmpty || v.length);
	},
	isObject:function(v, opt_andNotEmpty)
	{
		return v && Object.prototype.toString.call(v) === "[object Object]" && (!opt_andNotEmpty || Object.keys(v).length);
	},
	arraySum:function(arrayOfNumbers)
	{
		if (!QualtricsTools.isArray(arrayOfNumbers)) return false;
		if (!arrayOfNumbers.length) return 0;
		if (arrayOfNumbers.length == 1) return arrayOfNumbers[0];

		var len = arrayOfNumbers.length, sum = 0;
		for (var i = 0; i < len; ++i)
		{
			sum += arrayOfNumbers[i];
		}
		return sum;
	},
	arrayMean:function(arrayOfNumbers)
	{
		if (!QualtricsTools.isArray(arrayOfNumbers)) return false;
		if (!arrayOfNumbers.length) return 0;
		if (arrayOfNumbers.length == 1) return arrayOfNumbers[0];

		return QualtricsTools.arraySum(arrayOfNumbers) / arrayOfNumbers.length;
	},
	arrayMedian:function(arrayOfNumbers)
	{
		if (!QualtricsTools.isArray(arrayOfNumbers)) return false;
		if (!arrayOfNumbers.length) return 0;
		if (arrayOfNumbers.length == 1) return arrayOfNumbers[0];

		var arr = $(arrayOfNumbers).clone().sort(function(a,b){return a-b});
		var medIndex = (arr.length - 1) / 2;
		var flr = Math.floor(medIndex);

		return (medIndex === flr) ? arr[flr] : (arr[flr]+arr[flr+1])/2;
	},
	arrayVariance:function(arrayOfNumbers)
	{
		if (!QualtricsTools.isArray(arrayOfNumbers)) return false;
		if (!arrayOfNumbers.length || arrayOfNumbers.length == 1) return 0;

		var mean = QualtricsTools.arrayMean(arrayOfNumbers);
		var i = arrayOfNumbers.length, v = 0;
		while (i--) { v += Math.pow((arrayOfNumbers[i]-mean),2); }
		return v / arrayOfNumbers.length;
	},
	arrayStdDev:function(arrayOfNumbers)
	{
		if (!QualtricsTools.isArray(arrayOfNumbers)) return false;
		if (!arrayOfNumbers.length || arrayOfNumbers.length == 1) return 0;

		return Math.sqrt(QualtricsTools.arrayVariance(arrayOfNumbers));
	},
	/**
	 * Merges any number of arrays, ensuring unique entries.
	 * The order of the resulting array will be maintained according to the order
	 * of arrays passed as arguments
	 *
	 * NOTE: this uses $({array}).indexOf to compare uniqueness of array entries
	 * @return  {Array} the merged array with unique
	 */
	arrayMerge:function(/* any number of arrays as args */)
	{
		var arrays = Array.prototype.slice.call(arguments);
		var a = [];

		for(var i = 0, len = arrays.length; i < len; ++i)
		{
			var array = arrays[i];
			for (var j = 0, jlen = array.length; j < jlen; ++j)
			{
				if($(a).indexOf(array[j]) === -1)
				{
					a.push(array[j]);
				}
			}
		}
		return a;
	},

	/**
	 * QualtricsTools.filterForDisplay
	 * Attempts to filter strings so that javascript is not immediately run and there is no bad behavior
	 */
	filterForDisplay: function(value)
	{
		if (typeof value == 'string')
		{
			var text = value;

			// Removes script tags
			text = text.stripScripts();

			// Take out meta tags
			text = text.replace(/<meta\s[^>]*>/g, '');

			// Remove javascript attributes from any html tag
			text = this.removeInlineJavascript(text, 'onclick');
			text = this.removeInlineJavascript(text, 'onload');
			text = this.removeInlineJavascript(text, 'onerror');

			return text;
		}
		else
		{
			return value;
		}
	},

	removeInlineJavascript: function(text, attribute)
	{
		var regexWithQuotes = new RegExp('(<\\w+[^>]*' + attribute + '\\s*=\\s*)("|\')((?:[^\\2\\\\]|\\\\.)*?)\\2([^>]*>)', 'gi');
		var regexWithOutQuotes = new RegExp('(<\\w+[^>]*' + attribute + '\\s*=\\s*)[^\\s>]+([^>]*>)', 'gi');
		return text.replace(regexWithQuotes, '$1$2$2$4').replace(regexWithOutQuotes, '$1""$2');
	}
};
/**
* alias to getPageSize. dont use this its for legacy code.
*/
window.getPageSize = QualtricsTools.getPageSize;

function deleteChildren(node)
{
	if(node)
	{
		if (!Qualtrics.Browser.IE)
		{
			node.innerHTML = "";
		}
		else
		{

			for(var x = node.childNodes.length - 1; x >= 0; --x)
			{
				var childNode = node.childNodes[x];
				if(childNode.onmouseover)
				{
					childNode.onmouseover = null;
				}
				if(childNode.onmouseout)
				{
					childNode.onmouseout = null;
				}
				if(childNode.onmousedown)
				{
					childNode.onmousedown = null;
				}
				if(childNode.onclick)
				{
					childNode.onclick = null;
				}
				if(childNode.hasChildNodes()){
					deleteChildren(childNode);
				}

				node.removeChild(childNode);
				if(childNode.outerHTML){
					childNode.outerHTML = '';
				}

				childNode=null;
			}
			node=null;
		}
	}
}



//this should be in qualtricsSETools.js ? NO because questions are in the control panel too.
var QualtricsSETools = {
	highlightOn:false,
	killHighlight:false,
	highlightRegistry:[],
	unHighlightAll:function()
	{
		for(var i=0,len=QualtricsSETools.highlightRegistry.length; i<len; ++i)
		{
			var questionNode = QualtricsSETools.highlightRegistry[i];
			$(questionNode).removeClassName('Highlight');
			questionNode = null;
		}
		QualtricsSETools.highlightRegistry = [];
	},
	highlightHandler:function(evt)
	{
		QualtricsSETools.unHighlightAll();
		if (QualtricsSETools.highlightOn == true)
		{
			var clickedEl = Event.element(evt);
			var questionNode = QualtricsTools.fastUp(clickedEl,'QuestionOuter');

			if(questionNode)
			{
				QualtricsSETools.highlightRegistry.push(questionNode);
				$(questionNode).addClassName('Highlight');
			}
			questionNode = null;
			clickedEl = null;
		}
	},
	//use like this: QualtricsSETools.questionHighlighter();
	questionHighlighter:function()
	{
		if(!this.highlightOn)
		{
			Event.observe(document, 'mousedown', QualtricsSETools.highlightHandler);
			if(!this.killHighlight)
				this.highlightOn = true;
		}
	},
	killHighlighter:function() // For some reason IE demands this sacrifice, or it'll never let you diable highlights
	{
		this.killHighlight = true;
	},
	scrollToDiv:function(id)
	{
		new Effect.ScrollTo(id, {
			afterFinish: function(){
				try {
					var p = $(id);
					found = false;
					while (!found)
					{
						p = $(p.nextSibling);
						if (p == null)
							found = true;
						else if (p.hasClassName && p.hasClassName('QuestionOuter'))
							found = true;
					}

					if (p)
					{
						new Effect.Highlight(p);
					}
				}
				catch(e)
				{
					console.error(e);
				}
			}
		});
	},
	/** Replaces the simple buttons with more advanced buttons that can be styled better */
	replaceButtons: function()
	{
		var next = $('NextButton');
		var save = $('SaveButton');
		var prev = $('PreviousButton');
		var jump = $('JumpButton');
		var parentNode = next ? next.parentNode : (prev ? prev.parentNode : null);

		if (parentNode)
		{
			var innerHTML = "<input type=hidden id='buttonPressed' name='' value='1' />";

			if (next)
			{
				/* CANNOT BE SIMPLIFIED TO run document.Page.submit(); -- If so, SEonSubmit WILL NOT RUN! -JB 2009-11 */
				innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button>" +
						"<div tabindex='0' id='NextButton' role='button' aria-labelledby='NextLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'NextButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'NextButton'); };  \">"
						+"<label id='NextLabel' class='offScreen'>Next</label><span class='ButtonLeft'></span><span class='ButtonText' id='NextButtonText'>"+next.value+"</span><span class='ButtonRight'></span></div>";
			}
			if (save)
			{
				innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button>" +
						"<div tabindex='0' id='SaveButton' role='button' aria-labelledby='SaveLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'SavePageButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'SavePageButton'); };  \">"
						+"<label id='SaveLabel' class='offScreen'>Save</label><span class='ButtonLeft'></span><span class='ButtonText' id='SaveButtonText'>"+save.value+"</span><span class='ButtonRight'></span></div>";
			}
			if (prev)
			{
				innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button>" +
						"<div tabindex='0' id='PreviousButton' role='button' aria-labelledby='PreviousLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'PreviousButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'PreviousButton');};  \">"
						+"<label id='PreviousLabel' class='offScreen' >Previous</label><span class='ButtonLeft'></span><span class='ButtonText' id='PreviousButtonText'>"+prev.value+"</span><span class='ButtonRight'></span></div>";
			}
			if (jump)
			{
				innerHTML += "<button style=\"display: none;\" id=\"submitPageFeauBTN\" type=\"submit\"></button>" +
						"<div tabindex='0' class='"+jump.className+"' id='JumpButton' role='button' aria-labelledby='JumpLabel' onkeypress=\"if(!this.disabled){Qualtrics.SurveyEngine.navEnter(arguments[0],this, 'JumpButton'); };  \" onclick=\"if(!this.disabled){Qualtrics.SurveyEngine.navClick(this, 'JumpButton'); };  \">"
						+"<label id='JumpLabel' class='offScreen'>Table of Contents</label><span class='ButtonLeft'></span><span class='ButtonText' id='JumpButtonText'>"+jump.value+"</span><span class='ButtonRight'></span></div>";
				//Add hidden jumpindex button
				innerHTML += "<input type='hidden' value='' name='JumpIndex' id='JumpIndex'>";
			}

			parentNode.innerHTML = innerHTML;
			//parentNode.appendChild(QBuilder('input', {type: 'hidden', id: 'buttonPressed', name:'', value:'1'}));

			return;

			if (next)
			{
				parentNode.removeChild(next);
				var newNext = QBuilder('button', {type: 'submit', id: 'NextButton'}, [
						QBuilder('span', {className: 'ButtonLeft'}),
						QBuilder('span', {className: 'ButtonText'}, [next.value]),
						QBuilder('span', {className: 'ButtonRight'})]);
				parentNode.appendChild(newNext);

				newNext.onclick = function()
					{
						$('buttonPressed').name='NextButton';
					};
			}

			if (prev)
			{
				parentNode.removeChild(prev);
				var newPrev = QBuilder('button', {type: 'submit', id: 'PreviousButton'}, [
						QBuilder('span', {className: 'ButtonLeft'}),
						QBuilder('span', {className: 'ButtonText'}, [prev.value]),
						QBuilder('span', {className: 'ButtonRight'})]);
				parentNode.appendChild(newPrev);
				newPrev.onclick = function()
					{
						$('buttonPressed').name='PreviousButton';
					};
			}
		}
	}
};
//class used to display and record heat map clicks
var QHeatMap = Class.create({

	clickedPoint: null,
	clickCounter: 1,
	clickHistory: 1,
	maxClicks: 1,
	id: null,
	showRegions: false,
	_imgWidth: null,
	_imgHeight: null,
	initialize:function(id, opt_maxClicks, opt_showRegions, opt_regions)
	{
		this.id = id;
		var that = this;
		if (opt_maxClicks)
			this.maxClicks = opt_maxClicks;
		this.showRegions = opt_showRegions || false;
		this.regions = opt_regions;
		this.clickdownFunction = this.clickdown.bind(this);
		this.clickupFunction = this.clickup.bind(this);
		Event.observe($(this.id+"_Container"), 'mousedown', that.clickdownFunction);
		Event.observe($(this.id+"_Container"), 'mouseup', that.clickupFunction);
		this.imageContainer = $(this.id+"_Container");
		this.image = $(this.id);
		var imageLoaded = false;
		// We need to get the actual size of the image to correctly save the data points,
		// and there are times where the div containing the image is different than the actual image size
		var tempImage = new Image();
		tempImage.src = this.image.src;
		var tempImageLoaded = false;

		var imageLoadedCallback = function() {
			if (imageLoaded && tempImageLoaded) {
				this.imageLoaded();
			}
		}.bind(this);

		if (this.image.complete)
		{
			imageLoaded = true;
			imageLoadedCallback();
		}
		else
		{
			this.image.onload = function()
			{
				imageLoaded = true;
				imageLoadedCallback();
			};
		}
		if (tempImage.complete)
		{
			tempImageLoaded = true;
			this._imgWidth = tempImage.width;
			this._imgHeight = tempImage.height;
			imageLoadedCallback();
		}
		else
		{
			tempImage.onload = function()
			{
				tempImageLoaded = true;
				this._imgWidth = tempImage.width;
				this._imgHeight = tempImage.height;
				imageLoadedCallback();
			}.bind(this);
		}

	},
	imageLoaded:function()
	{
		//// draw crosshairs and points when navigating back and forth within the survey
		// legacy data
		try
		{
			if($F(this.id+'_ClickY') && $F(this.id+'_ClickX'))
			{
				this.presetPoint($F(this.id+'_ClickX'),$F(this.id+'_ClickY'));
			}
		}
		catch (e)
		{
		}

		// new data
		try
		{
			for (var click = 1; click <= this.maxClicks; click++)
			{
				if ($F(this.id+'_Click_'+click))
				{
					var xy = $F(this.id+'_Click_'+click).split(",");
					this.presetPoint(xy[0], xy[1]);
				}
			}
		}
		catch (e)
		{
		}

		// render the regions for view results popup.
		if (this.showRegions)
		{
			this.renderRegions();
		}
	},
	renderRegions: function() {
		var options = {
			selectable: false,
			enableDescriptions: false,
			style: {}
		};

		var regionContainer = $(this.id + '_Regions');

		regionContainer.setStyle({
			width: $(this.image).getWidth() + 'px',
			height: $(this.image).getHeight() + 'px'
		});

		QModules.loadModule("QRegion.js");

		var ret = new Qualtrics.RegionEditor(
			$(this.id + '_Regions'),
			null,
			this.regions,
			options
		);

		if (!window.Raphael || !Raphael.type)
			ret.element.setStyle({display: 'block'});
		ret.render();
	},
	clickdown:function(event)
	{
		//if (!event) event = window.event;
		Event.stop(event);

	},
	drawCrossHair:function()
	{
		var height = $(this.image).offsetHeight;
		var width = $(this.image).offsetWidth;
		var horiz = QBuilder('div',{id:this.id+'_chh_'+this.clickCounter,className:'chh'},' ');
		var vert = QBuilder('div',{id:this.id+'_chv_'+this.clickCounter,className:'chv'},' ');
		$(horiz).setStyle({
			width:width+'px',
			top:'0px',
			left:'0px',
			opacity:0.6

		});
		$(vert).setStyle({
			height:height+'px',
			top:'0px',
			left:'0px',
			opacity:0.6
		});
		$(this.imageContainer).appendChild(horiz);
		$(this.imageContainer).appendChild(vert);
	},
	setPoint:function(event)
	{
		if (!event) event = window.event;
		//offset must come before layer: offset isn't defined in firefox,
		//so firefox will grab layer, and everyone else will grab offset
		var pointerX = event.offsetX || event.layerX;
		var pointerY = event.offsetY || event.layerY;
		var element = Event.element(event);
		// if the user clicks on the one of the crosshairs, update the x or y coordinate as the possition of the crosshair
		if (element.id.startsWith(this.id+'_chh'))
		{
			pointerY = element.offsetTop;
		}
		if (element.id.startsWith(this.id+'_chv'))
		{
			pointerX = element.offsetLeft;
		}
		var pointID = this.id+"_Point_"+this.clickCounter;
		var realX = pointerX;
		var realY = pointerY;
		this.clickedPoint = this.generatePoint(pointID,realX,realY);
		this.imageContainer.appendChild(this.clickedPoint);
		return [realX,realY];

	},
	generatePoint:function(id,x,y)
	{
		if (!$(id))
		{
			var point = QBuilder('div',{id:id, className:'point'});
			this.imageContainer.appendChild(point);
		}
		else
		{
			point = $(id);
		}
		point.setStyle({
			top:y-2+'px',
			left:x-2+'px'
		});
		point.setAttribute('x',x);
		point.setAttribute('y',y);
		return point;
	},
	presetPoint:function(x,y)
	{
		var pointID = this.id+"_Point_"+this.clickCounter;
		// Scale points to their rendered size
		var xy = this.translateCoordinates(x, y);
		var realX = xy.x;
		var realY = xy.y;
		this.clickedPoint = this.generatePoint(pointID,realX,realY);

		var loc = [realX,realY];

		if (!$(this.id+'_chh_'+this.clickCounter))
		{
			this.drawCrossHair();
		}
		new Effect.Morph(this.id+'_chh_'+this.clickCounter,{transition:this.EaseFrom,duration:0.5,style:{top:loc[1]+'px'}});
		new Effect.Morph(this.id+'_chv_'+this.clickCounter,{transition:this.EaseFrom,duration:0.5,style:{left:loc[0]+'px'}});
		this.recordClick();
		// increment the click counter
		this.clickCounter = (this.clickCounter % this.maxClicks) + 1;
		this.clickedPoint = null;

	},
	clickup:function(event)
	{
		if (!event) event = window.event;
		var element = Event.element(event);
		if (this.isValidClick(element))
		{
			var loc = this.setPoint(event);

			if (!$(this.id+'_chh_'+this.clickCounter))
			{
				this.drawCrossHair();
			}
			new Effect.Morph(this.id+'_chh_'+this.clickCounter,{transition:this.EaseFrom,duration:0.5,style:{top:loc[1]+'px'}});
			new Effect.Morph(this.id+'_chv_'+this.clickCounter,{transition:this.EaseFrom,duration:0.5,style:{left:loc[0]+'px'}});
			this.recordClick();
			// increment the click counter
			this.clickCounter = (this.clickCounter % this.maxClicks) + 1;
			this.clickedPoint = null;
		}
	},
	isValidClick:function(element)
	{
		var isValid = false;
		// If original dimensions are not set yet, ignore clicks
		if (element == this.image && this._imgWidth && this._imgHeight)
			isValid = true;
		else if (element.id.indexOf('chh') !== -1 || element.id.indexOf('chv') !== -1)
			isValid = true;
		return isValid;
	},
	EaseFrom:function(pos) {
		return Math.pow(pos,2);
	},
	translateCoordinates: function(x, y, getOriginal)
	{
		var op = function(a, b) { return a * b; };
		if (getOriginal) {
			op = function(a, b) { return a / b; };
		}
		x = Math.round(op(x, this._getRatioX()));
		y = Math.round(op(y, this._getRatioY()));

		return {x: x, y: y};
	},

	/**
	 * Get original image width. If the definition is bad and does not have the original,
	 * then the displayed width is assumed the original
	 */
	_getImgWidth: function() {
		if (!this._imgWidth) {
			return this.image.getWidth();
		}
		return this._imgWidth;
	},

	/**
	 * Get original image height. If the definition is bad and does not have the original,
	 * then the displayed height is assumed the original
	 */
	_getImgHeight: function() {
		if (!this._imgHeight) {
			return this.image.getHeight();
		}
		return this._imgHeight;
	},

	_getRatioX: function() {
		return this.image.getWidth() / this._getImgWidth();
	},

	_getRatioY: function() {
		return this.image.getHeight() / this._getImgHeight();
	},
	recordClick:function()
	{
		if(this.clickedPoint)
		{
			var x = this.clickedPoint.getAttribute('x');
			var y = this.clickedPoint.getAttribute('y');
			// Scale clicked point to match original dimensions
			var xy = this.translateCoordinates(x, y, true);
			x = xy.x;
			y = xy.y;
			try
			{
				// old data
				var clickData = $(this.id+'_Click_'+this.clickCounter);
				clickData.value = x + "," + y;
			}
			catch (e)
			{
				// new data
				var clickX = $(this.id+'_ClickX');
				var clickY = $(this.id+'_ClickY');
				clickX.value = x;
				clickY.value = y;
			}
		}
	}
});

/** This is only used for legacy, rectangular regions. See QHotSpot2 for the modern stuff. */
var QHotSpot = {
	selectRegion:function(selector, postTagChoiceId)
	{

		if (selector == 'OnOff')	//Simple toggle On / Off
		{
			if ($(postTagChoiceId).value == 1)
			{
				$(postTagChoiceId).value = 2;

				$(postTagChoiceId+'-Region').addClassName('Like');
			}
			else
			{
				$(postTagChoiceId).value = 1;

				$(postTagChoiceId+'-Region').removeClassName('Like');
			}
		}
		else if (selector == 'LikeDislike')	//More complex toggle Like / Dislike / Off
		{
			$(postTagChoiceId+'-Region').removeClassName('Like');
			$(postTagChoiceId+'-Region').removeClassName('Dislike');

			if ($(postTagChoiceId).value == 1)
			{
				$(postTagChoiceId).value = 2;
			}
			else if ($(postTagChoiceId).value == 2)
			{
				$(postTagChoiceId).value = 3;

				$(postTagChoiceId+'-Region').addClassName('Like');
			}
			else
			{
				$(postTagChoiceId).value = 1;

				$(postTagChoiceId+'-Region').addClassName('Dislike');
			}
		}
		else
		{
			console.log("WARNING: HotSpot.tpl::Unknown selector: '+selector+'");
		}
	},
	autoSizeRegions:function(imgId)
	{
		var img = $(imgId);
		if(img)
		{
			//get the HotSpotContainer
			var hotSpotContainer = img.parentNode;
			if(hotSpotContainer && hotSpotContainer.getAttribute('hotspotwidth'))
			{
				var originalDimensions = [hotSpotContainer.getAttribute('hotspotwidth'), hotSpotContainer.getAttribute('hotspotheight')];
				var currentDimensions = [img.offsetWidth, img.offsetHeight];
				var ratio = [currentDimensions[0]/originalDimensions[0],currentDimensions[1]/originalDimensions[1]];
				if(ratio[0] != 1 || ratio[1] != 1)
				{
					//the image has been resized! probably with css.
					//we need to adust each regions position and size to match the adjusted image size
					var children = $(hotSpotContainer).childElements();
					var regions = [];
					for(var i=0,len=children.length; i<len; ++i)
					{
						if(children[i].nodeName == 'A')
						{
							regions.push(children[i]);
							QHotSpot.adjustRegion(children[i], ratio);
						}
					}
				}
			}
		}
	},
	adjustRegion:function(regionNode, ratio)
	{
		$(regionNode).setStyle({left:regionNode.offsetLeft*ratio[0]+'px', top:regionNode.offsetTop*ratio[1]+'px'});
		var innerInner = $(regionNode).down('.RegionInnerInner');
		if(innerInner)
		{
			$(innerInner).setStyle({width:innerInner.offsetWidth*ratio[0]+'px', height:innerInner.offsetHeight*ratio[1]+'px'});
		}
	}
};
/** Polygon regions. */
var QHotSpot2 = {
	createRegionEditor: function(holderEl, regions, postTag, selector, visibility, size)
	{
		var options = {
			selectable: true,
			enableDescriptions: false,
			onSelect: QHotSpot2.selectRegion,
			style: {}
		};

		if (selector == "OnOff")
		{
			options.selectionStates = [
				{fill: 'rgb(0, 0, 0)', 'fill-opacity': 0, iconSrc: null},
				{fill: 'rgb(0%, 100%, 0%)', 'fill-opacity': .3, iconSrc: null}
			];
		}
		else
		{
			options.selectionStates = [
				{fill: 'rgb(100%, 0%, 0%)', 'fill-opacity': .3, iconSrc: "/WRQualtricsShared/Graphics/icons/x_trans.png"},
				{fill: 'rgb(0, 0, 0)', 'fill-opacity': 0, iconSrc: null},
				{fill: 'rgb(0%, 100%, 0%)', 'fill-opacity': .3, iconSrc: "/WRQualtricsShared/Graphics/icons/check_trans.png"}
			];
		}

		if (visibility == "HiddenUntilHover" || !visibility)
		{
			options.style.shape = {
				stroke: "none",
				'stroke-opacity': 0,//stupid IE needs this. Apperently stroke "none" means "show it anyway"
				'stroke-width': .75,
				fill: "none"
			};
			options.style.shapeHover = {
				stroke: "#000",
				'stroke-opacity': 1,
				'stroke-width': 1.5
			};
			options.style.shapeGlowOpacity = 0;
		}

		QModules.loadModule("QRegion.js");

		var ret = new Qualtrics.RegionEditor(
			holderEl,
			null,
			regions,
			options
		);
		ret.postTag = postTag;

		if (!window.Raphael || !Raphael.type)
			ret.element.setStyle({display: 'block'});
		ret.render();

		//Resize and make regions visible on load (in case image is not the correct size)
		var image = $("HotSpot_" + postTag + "_Image");
		if (image.complete)
		{
			QHotSpot2.renderRegion.defer(postTag, size);
		}
		else
		{
			Event.observe(image, 'load', QHotSpot2.renderRegion.curry(postTag, size));
		}

		//Add default/existing selections
		this.readSelectionsFromInputs(ret);

		return ret;
	},
	/** Reads the input fields for the regions and updates the display to reflect the selection. */
	readSelectionsFromInputs: function(editor)
	{
		var regions = editor.getRegions();
		for (var regionId = 0; regionId < regions.length; ++regionId)
		{
			var v = +$("QR~" + editor.postTag + "~" + regions[regionId].ChoiceID).value;
			editor.selectRegion(regionId, v - 1);
		}
	},
	renderRegion: function(postTag, originalSize)
	{
		//make sure the SVG holder is the right size
		var re = window.regionEditors[postTag];
		var img = $("HotSpot_" + postTag + "_Image");
		var layout = new Element.Layout(img);
		re.element.setStyle(layout.toCSS());

		//In case the image is a different size than we expected (such as being shrunk by CSS)
		//rescale the elements in the region.
		re.rescaleRegions(originalSize, {w: layout.get('width'), h: layout.get('height')});

		//Re-render the regions
		re.render();

		re.element.setStyle({display: 'block'});
	},
	selectRegion:function(editor, regionId)
	{
		var choiceId = editor.getRegionProperty(regionId, "ChoiceID");
		$("QR~" + editor.postTag + "~" + choiceId).value = editor.selectedRegions[regionId] + 1;
	}
};

/*
 * The following functions are ansilary to the Flash Charts
 */
if (Qualtrics.ofcData == undefined)
	Qualtrics.ofcData = {};

if (Qualtrics.ofcImages == undefined)
	Qualtrics.ofcImages = {};

Qualtrics.ofcGetData = function(id)
{
	return Qualtrics.ofcData[id];
};

//fires an event when the flash is ready
function ofc_ready(chart_id)
{
	Element.fire(document,"OFC:ofc_ready_"+chart_id[0]);
}

function ofc_stoped_animating(chart_id)
{
	Element.fire(document, "Event:ofc_stoped_animating_"+chart_id[0]);
}

/**
 * JSON-encodes and stores an item in HTML5 localStorage
 * @param {string} key - The string key to store the item under
 * @param {mixed} item - The item to be stored
 * @returns {Boolean} - Whether HTML5 LocalStorage is supported or not
 */
function html5Store(key, item)
{
	if ('localStorage' in window && window.localStorage !== null)
	{
		window.localStorage[key] = Object.toJSON(item);
		return true;
	}
	return false;
}

/**
 *
 * @param {string} key - The string key from whence to retrieve the item
 * @param {string} opt_default - Optional: If HTML5 Storage is unavailable or the key isn't found, return this default
 * @returns mixed - Either the thing you're looking for (or an empty string if HTML5 is not supported) converted to (type).
 */
function html5Retrieve(key, opt_default)
{
	var item = opt_default;
	if ('localStorage' in window && window.localStorage !== null && key in window.localStorage)
		item = Qualtrics.parseJSON(window.localStorage[key], true);

	return item;
}

function saveFlashImages(options)
{
	if (!options)
		options = {};

	if (Object.keys(Qualtrics.ofcImages).size() <= 0)
	{
		if( options && options.onComplete)
			options.onComplete();
	}
}


//OH: I put this here because I didn't know where else to put it
function changePagePosition(foreward, pageCount)
{
	if(!Qualtrics.currentReportPage)
	{
		Qualtrics.currentReportPage = 0;
	}

	var curPage = Qualtrics.currentReportPage;

	$('page'+curPage).toggleClassName('visible');

	if(foreward)
	{
		curPage = (curPage < pageCount-1)?curPage+1:0;
	}
	else
	{
		curPage = (curPage > 0)?curPage-1:pageCount-1;
	}

	$('page'+curPage).toggleClassName('visible');

	$('pageNumberDisplay').update(curPage+1);

	Qualtrics.currentReportPage = curPage;
}

function addReportNavigator(pageCount)
{
	return QBuilder('div',{id:'ReportNavigator'},[QBuilder('div',{},[
		QBuilder('a',{className:'qbutton', clickcallback:'changePagePosition',p1:false,p2:pageCount},[
			QBuilder('span',{className:'icon previous'})
		]),
		QBuilder('span',{id:'pageNumberDisplay'},1),
		QBuilder('a',{className:'qbutton', clickcallback:'changePagePosition',p1:true,p2:pageCount},[
			QBuilder('span',{className:'icon next'})
		])
	])]);
}

FileUploader = {
	prevFileID:'', // Have we already uploaded a file with this ID? We may need to overwrite a thumbnail
	buildFileUploadIFrame:function(qID, maxSize)
	{
		var iframe = Builder.node('iframe',{
			id:'FileUploader',
			scrolling:'no',
			name:'FileUploader',
			frameBorder:0,
			src:'/WRQualtricsShared/blank.html'
		});

		$(iframe).setStyle({
			width:'0px',
			height:'0px'
		});
		var fileField = QBuilder('input',{id:'fileField',type:'file',size:'48',name:'fileField',autocomplete:'off',qid:qID});
		var form = QBuilder('form',{id:'fileUploadForm',enctype:'multipart/form-data',method:'post',action:URLTools.getAjaxURL('uploadRFile'),target:'FileUploader'},[
			QBuilder('div',{className:'inputContainer'},[
				QBuilder('div',{className:'fileInputContainer',id:'fileInputContainer'},[
					QBuilder('input',{type:'hidden',value:maxSize,name:'MAX_FILE_SIZE'}),
					QBuilder('input',{type:'hidden',value:$('SurveyID').value,name:'SurveyID'}),
					QBuilder('input',{type:'hidden',value:$('SessionID').value,name:'SessionID'}),
					fileField
				])
			]),
			QBuilder('input',{type:'hidden',id:'QID',name:'QID',value:qID})
		]);
		var frameDiv = QBuilder('div',{},[form, iframe]); // This hack brought to you by the number 7 and the letters "IE"
		$('fIFrame~'+qID).contentWindow.document.write(frameDiv.innerHTML); // For some reason, it's racist against appending children to an iframe
		$('fIFrame~'+qID).contentWindow.document.body.style.background = 'transparent';
		new Form.Element.Observer($('fIFrame~'+qID).contentWindow.document.getElementById('fileField'), 0.2, FileUploader.clearOldAndSubmit);
	},
	clearOldAndSubmit:function(el,value)
	{
		var qid = el.getAttribute('qid');
		if ($('fileInfo~'+qid))
			$('fileInfo~'+qid).remove();
		$('Filename~'+qid).value = '';
		$('TmpFilepath~'+qid).value = '';
		$('FileType~'+qid).value = '';
		$('Size~'+qid).value = '';
		$('loadingImage~'+qid).show();
		$('loadingError~'+qid).hide();
		$('fileInfoCont~'+qid).hide();
		if (value != '')
		{
			$('fIFrame~'+qid).contentWindow.document.getElementById('fileUploadForm').submit();
			// This little hack helps prevent Safari from hanging because of a stupid OSX bug that's been open for years
			if (/AppleWebKit|MSIE/.test(navigator.userAgent)) {
				new Ajax.Request("/WRQualtricsShared/blank.html", {asynchronous:false});
			}
		}
	},
	fail:function(qid, errorMsg)
	{
		$('fileInfoCont~'+qid).hide();
		if ($('fileInfo~'+qid))
			$('fileInfo~'+qid).remove();
		if (errorMsg)
			$('loadingError~'+qid).innerHTML = errorMsg;
		$('loadingImage~'+qid).hide();
		$('loadingError~'+qid).show();
		$('Filename~'+qid).value = '';
		$('TmpFilepath~'+qid).value = '';
		$('FileType~'+qid).value = '';
		$('Size~'+qid).value = '';
	},
	uploadOnload:function(qID, fileData)
	{
		if (fileData.errors && fileData.errors != '')
		{
			this.fail(qID, fileData.errors);
			return;
		}
		$('loadingImage~'+qID).hide();
		$('loadingError~'+qID).hide();
		$('Filename~'+qID).value = fileData.origFilename;
		$('TmpFilepath~'+qID).value = fileData.fullpath;
		$('FileType~'+qID).value = fileData.type;
		$('Size~'+qID).value = fileData.size;
		$('fileInfoCont~'+qID).show();
		$('FILE~'+qID).value = fileData.fileId || $('FILE~'+qID).value;

		var fileURL = '/WRQualtricsControlPanel/File.php?F=' + (fileData.fileId || fileData.fullpath) + '&filePreview=true&PrevID=' + this.prevFileID;

		var filePreview = QBuilder('tr', {id:'filePreviewRow~'+qID}, [
			QBuilder('td', {className:'right'}, [
				QBuilder('img', {id:'imagePreviewRow~'+qID, src:fileURL,
					className:'filePreview', onerror:'$(this).hide();'})
			])
		]);
		var nameInfo = QBuilder('tr',{id:'filenameInfoRow~'+qID},[
			QBuilder('td',{className:'right'},fileData.origFilename)
		]);
		var size = fileData.size;
		var sizeTag = 'B';
		if (size > 1024)
		{
			size /= 1024;
			sizeTag = 'KB';
		}
		if (size > 1024)
		{
			size /= 1024;
			sizeTag = 'MB';
		}
		var sizeInfo = QBuilder('tr',{id:'sizeInfoRow~'+qID},[
			QBuilder('td',{className:'right'},(Math.round(size*10)/10)+sizeTag)
		]);
		var typeInfo = QBuilder('tr',{id:'typeInfoRow~'+qID},[
			QBuilder('td',{className:'right'},fileData.type)
		]);
		var fileInfo = QBuilder('table',{className:'fileInfo',id:'fileInfo~'+qID},[
			QBuilder('tbody',{},[
				filePreview,
				nameInfo,
				sizeInfo,
				typeInfo
			])
		]);
		$('fileInfoCont~'+qID).appendChild(fileInfo);
	}
};

Qualtrics.objToHideButton = function(o, header)
{
	if (!header)
		header = '';

	var showButton = QBuilder('input',{
		type: 'button',
		value: 'show'
	});
	var hideButton = QBuilder('input',{
		type: 'button',
		value: 'hide'
	});

	var obj = QBuilder('div',{},[QBuilder('pre',{},Qualtrics.objToString(o))]);
	var inner = QBuilder('div',{},[header,obj,hideButton]);
	$(inner).hide();

	Event.observe(hideButton,'click',function(){
		$(inner).hide();
		showButton.value = 'show';
	});
	Event.observe(showButton,'click',function(){
		if (showButton.value == 'show')
		{
			showButton.value = 'hide';
			$(inner).show();
		}
		else
		{
			showButton.value = 'show';
			$(inner).hide();
		}
	});

	var container = QBuilder('div',{},[showButton,inner]);
	return container;
};
Qualtrics.objToString = function(obj,tab)
{
	tab = tab || 0;
	var ret = '';
	if (Object.isArray(obj))
		obj = obj.toObject();
	for (var id in obj)
	{
		ret += '\t'.times(tab);
		ret += (id + ' => ');
		if (typeof obj[id] == 'object')
		{
			ret += '\n';
			ret += Qualtrics.objToString(obj[id],tab+1);
		}
		else
		{
			ret += String(obj[id]);
		}
		ret += '\n';
	}
	return ret;
};

/** slightly modified version of is_numeric that also accepts a comma in the thousands place */
function isNumeric(input)
{
	input = input.replace(/,/g,'');	//Remove any and all commas

	//return !isNaN(parseFloat(input)) && isFinite(input);	//Optional implementation
	return (input - 0) == input && input.length > 0;
}

/**
 * Takes a noun and pluralizes it. Add exceptions as needed.
 */
Qualtrics.pluralize = function(string)
{
	var len = string.length;
	var lastChar = string[len-1];
	if (lastChar == 'y')
	{
		return string.substr(0, len-1) + 'ies';
	}

	return string + 's';
};

Qualtrics.noop = function() {};

Qualtrics.isFeatureEnabled = function(feature, callback)
{
	new Ajax.CachedRequest(URLTools.getAjaxURL('FeatureIsEnabled'), {
		parameters: {Feature: feature},
		onSuccess: function(resp){
			var results = resp.responseText.evalJSON();
			callback(results.enabled);
		}
	});
};

// @file QMetrics.js

/**
 * QMetrics:
 *
 * Dependencies:
 * 		Prototypejs
 * 		QualtricsTools
 *
 * This object is used as a way to record benchmarks for a given pageload.
 */

window.QMetrics = (function(){

	var _pageLoadedTimestamp = null;
	var _pageTimes = null;

	var _numbers = {};
	var _timers = {};
	var _strings = {};

	Event.observe(window, 'load', function(){
		_pageLoadedTimestamp = new Date().getTime(); //will be updated later if we have more accuracy available
		_capturePageTimes(window);
	});

	function _capturePageTimes(w)
	{
		_pageTimes = {};
		if (Qualtrics.__naive_page_start)
		{
			_timers['FirstScriptTagToLoad'] = {
				times:[_pageLoadedTimestamp - Qualtrics.__naive_page_start],
				uniqueEvent: true
			};
		}

		var p = w.performance || w.msPerformance || w.webkitPerformance || w.mozPerformance;
		if (p && p.timing)
		{
			_pageLoadedTimestamp = p.timing.loadEventStart; //this is more accurate. let's use this.

			_timers['NavTimeToLoaded'] = {
				times:[_pageLoadedTimestamp - (p.timing.navigationStart || p.timing.fetchStart)],
				uniqueEvent: true
			};
			_timers['RequestStartToLoaded'] = {
				times:[_pageLoadedTimestamp - p.timing.requestStart],
				uniqueEvent: true
			};
		}
	}

	function _getTimer(key)
	{
		if (!_timers[key])
		{
			_timers[key] = {
				times:[]
			};
		}

		return _timers[key];
	}

	function _getTimerStats(key, opt_appendToObject)
	{
		var t = _getTimer(key);
		var timesArray = t.times;
		var stats = opt_appendToObject || {};
		if (t.uniqueEvent)
		{
			stats[key] = timesArray.shift();
		}
		else if (timesArray.length)
		{
			stats[key+'_mean'] = QualtricsTools.arrayMean(timesArray);
			stats[key+'_count'] = timesArray.length;
			stats[key+'_min'] = timesArray.min();
			stats[key+'_max'] = timesArray.max();
			stats[key+'_total'] = QualtricsTools.arraySum(timesArray);
			stats[key+'_median'] = QualtricsTools.arrayMedian(timesArray);
			if (timesArray.length > 1)
			{
				stats[key+'_stdDev'] = QualtricsTools.arrayStdDev(timesArray);
			}
		}
		return stats;
	}

	function _getDurationStats(opt_includeTotalPageTime)
	{
		var durations = {};
		for (var k in _timers)
		{
			_getTimerStats(k, durations);
		}

		if (opt_includeTotalPageTime)
			durations.TimeOnPage = new Date().getTime() - _pageLoadedTimestamp;

		return durations;
	}

	function _incCounter(key, inc)
	{
		if (inc == undefined) inc = 1;

		if (!_numbers[key])
			_numbers[key] = 0;

		_numbers[key] += inc;
	}

	function _hasData()
	{
		return QualtricsTools.isObject(_timers, true) || QualtricsTools.isObject(_numbers, true) || QualtricsTools.isObject(_strings, true);
	}

	function _reset()
	{
		_numbers = {};
		_timers = {};
		_strings = {};
	}

	function _sendData(key, opt_onUnload)
	{
		if (!key || !_hasData() || !$('T'))
			return;

		var paramData = {
			Key:key,
			Data:Object.toJSON({
				Durations:_getDurationStats(opt_onUnload),
				Numbers:_numbers,
				Strings:_strings
			})
		};

		//if it's on page unload, an ajax request won't make it thru in time. Let's use an image beacon instead.
		if (opt_onUnload)
		{
			paramData['T'] = $F('T');
			var img = new Image();
			paramData['_End'] = 1;
			img.src = URLTools.getAjaxURL('LogQMetrics', null, paramData);
			_reset();
		}
		else
		{
			paramData['_End'] = 1;
			new Ajax.Request(URLTools.getAjaxURL('LogQMetrics'),{
				method:'POST',
				parameters:paramData,
				onComplete:function(transport){
					_reset();
				}
			});
		}
	}

	return {
		/**
		 * Starts a timer, stores it under the specified key
		 *
		 * @param   {string}  key           the unique key to refer to this timer
		 * @param   {boolean} opt_onlyOnce  If true, subsequent calls using this key will be discarded
		 */
		startTimer:function(key, opt_onlyOnce)
		{
			var t = _getTimer(key);
			if (opt_onlyOnce)
			{
				if (t.uniqueEvent)
					return; //already added, don't duplicate

				t.uniqueEvent = true;
			}

			t.started = new Date();
			return t.started;
		},
		/**
		 * Stops a timer
		 * @param   {string}  key         the timer's id
		 * @param   {boolean} opt_cancel  if true, the time won't be recorded
		 */
		stopTimer:function(key, opt_cancel)
		{
			var duration = 0;
			var t = _getTimer(key);
			if (t.started)
			{
				var end = new Date();
				var delta = end - t.started;
				delete t.started;
				if (!opt_cancel)
				{
					t.times.push(delta);
					duration = delta;
				}
			}
			return duration;
		},
		/**
		 * Adds a timed event to the registry, using the page's load time
		 * as the start time, and the current time as its end time.
		 *
		 * @param   {string}  key           The timer's id
		 * @param   {boolean} opt_onlyOnce  If true, subsequent calls using this key will be discarded
		 */
		markTimeSincePageLoad:function(key, opt_onlyOnce)
		{
			var n = new Date().getTime();

			var t = _getTimer(key);
			if (opt_onlyOnce)
			{
				if (t.uniqueEvent)
					return; //don't overwrite it
				t.uniqueEvent = true;
			}

			var duration = n - _pageLoadedTimestamp;
			t.times.push(duration);
			return duration;
		},
		/**
		 * Increments a numeric counter. If a counter with the given key hasn't been initialized yet, this will
		 * 	initialize it and set it to 1
		 *
		 * @param   {string}  key  the counter's unique id
		 */
		incrementCounter:function(key)
		{
			_incCounter(key);
			return _numbers[key];
		},
		/**
		 * Logs information about a timer, string, or counter to the console.
		 * If no key is specified, logs info about ALL timers, strings, and counters
		 *
		 * @param   {string}  key  The timer/counter/string key for which to log
		 * @return  {object}       Object containing all the data being logged
		 */
		consoleDump:function(key)
		{
			var data;
			if (key != null)
			{
				if (_numbers[key] !== undefined)
				{
					data = _numbers[key];
				}
				else if (_strings[key] !== undefined)
				{
					data = _strings[key];
				}
				else
				{
					data = _getTimerStats(key);
				}
			}
			else
			{
				data = {
					Timers:_timers,
					Counters:_numbers,
					Strings:_strings,
					PageLoadTimestamp:_pageLoadedTimestamp
				};
			}

			console.dir(data);
			return data;
		},
		/**
		 * Resets the timer, string, or counter with the given key
		 * @param   {string}  key  the id key for the stat to be reset
		 */
		resetStat:function(key)
		{
			if (key == null)
				return;

			var data = this.consoleDump(key);
			delete _numbers[key];
			delete _timers[key];
			delete _strings[key];
			return data;
		},
		/**
		 * Records a string value for a given key. If called multiple times with the same key,
		 * only the latest value passed is kept
		 *
		 * @param   {string}  key    the identifier for the string being logged
		 * @param   {string}  value  the string value
		 */
		logString:function(key, value)
		{
			if (!key || !value)
				return;

			_strings[key] = value;
		},
		/**
		 * Records multiple key:value pairs of strings
		 * @param   {object}  stringsObj  key:value pairs of string data
		 */
		logStrings:function(stringsObj)
		{
			if (!QualtricsTools.isObject(stringsObj, true))
				return;

			for (var k in stringsObj)
			{
				this.logString(k, stringsObj[k]);
			}
		},
		/**
		 * Logs a numeric value for a given key. Subsequent calls to this with the same key
		 * will merely increment the previous value of this key by the amount passed in.
		 *
		 * @param   {string}  key    the id key for the numeric value
		 * @param   {[type]}  value  the numeric value
		 */
		logNumber:function(key, value)
		{
			_incCounter(key, value);
		},
		/**
		 * Logs multiple numeric values with given keys. See logNumber().
		 * @param   {object}  numbersObj  key:value pairs with numeric values
		 */
		logNumbers:function(numbersObj)
		{
			if (!QualtricsTools.isObject(numbersObj, true))
				return;

			for (var k in numbersObj)
			{
				this.logNumber(k, numbersObj[k]);
			}
		},
		/**
		 * Logs a pre-timed event.
		 * @param   {string}  key    id key for this timer
		 * @param   {number}  value  duration (MUST BE IN MILLISECONDS) for the event
		 */
		logDuration:function(key, value)
		{
			var t = _getTimer(key);
			t.times.push(value);
		},
		/**
		 * Logs multiple key:value pairs for pre-timed events
		 * @param   {object}  durationsObj  key:value pairs with duration values
		 */
		logDurations:function(durationsObj)
		{
			if (!QualtricsTools.isObject(durationsObj, true))
				return;

			for (var k in durationsObj)
			{
				this.logDuration(k, durationsObj[k]);
			}
		},
		/**
		 * QMetrics.logMetrics:
		 *
		 * A shortcut function for logging multiple strings, numbers, and durations. see other functions on this object.
		 * See the php version for better documentation, as this mimicks that
		 *
		 * @param   {object}  strings       An object of key:value pairs of string values to log
		 * @param   {object}  numbers       An object of key:value pairs of numeric values to log, can be incremented using incrementCounter()
		 * @param   {object}  durations     An object of key:value pairs of durations (MUST be in Milliseconds) to log.
		 */
		logMetrics:function(strings, numbers, durations)
		{
			this.logStrings(strings);
			this.logNumbers(numbers);
			this.logDurations(durations);
		},
		/**
		 * QMetrics.sendToServer:
		 *
		 * sends any gathered metrics to the server for logging
		 *
		 * @param   {string}  metricIdentifier   the key under which the gathered metrics will be logged
		 * @param   {boolean}  opt_onUnload      if set, this will also record total time on page
		 */
		sendToServer:function(metricIdentifier, opt_onUnload)
		{
			_sendData(metricIdentifier, opt_onUnload);
		}
	};
})();

/**
* QModules lets you load in pieces of javascript on the fly.
* this helps with bloat.
* you should use QModules instead of putting whatever javascript you are planning on adding to QualtricsCPTools.
* just throw your code inside WRQualtricsShared/JavaScript/Modules/mynewmodule.js and call QModules.loadModule('mynewmodule.js')
* NOTE: the module will not be asynchronous by default (they will block the main thread), but if you add an onComplete function to your options then it will run in the background.
*/
var QModules =
{
	/** the base modules path */
	moduleBasePath: '/WRQualtricsShared/JavaScript/Modules/',

	/** the base path for any javascript that is not a module */
	basePath: '/',

	loadedModules:{},

	/** 'eval' - Evaluates module
	 *  'script' - Places module code inside script tag
	 *  'head' - Places a script tag into the head of the page and waits for it to load
	 */
	loadType: 'script',

	/**
	 * QModules.loadModule
	 * @param {String} path - can be just 'mymodule.js' in the Modules dir, or can be a full path to anything. eg. '/WRQualtricsShared/JavaScript/Modules/mymodule.js'
	 * @param {function} options.onComplete - the function to call when the script has been loaded.
	 * @param {function} options.asynchronous - if it loads the script asynchronously
	 */
	loadModule:function(path, options)
	{
		var defaultOptions =
			{
				method: 'get', //must be get so it can be cached, posts prevent caching
				asynchronous: false,
				modulePath: path //this is so we can get the path inside our oncomplete without any additional closures.
			};
		if(options && options.onComplete)
		{
			defaultOptions.asynchronous = true;
			options.customOnComplete = options.onComplete;
			options.onComplete = null; //we cant have this overridden.
		}
		if (QModules.loadType == 'script' || QModules.loadType == 'head')
		{
			defaultOptions.evalJS = false; //we will do this ourselves so we get the window scope. commented out cause QModules.exec doesnt work in IE6 yet
		}
		defaultOptions.evalJS = false;//we want to do our own eval anyway cause we can do it faster.
		options = Object.extend(defaultOptions, options);
		options.onComplete = QModules.onModuleLoad; //you can't override this but the onComplete will run a customOnComplete

		var parsedPath = options.noParse && path || QModules.parsePath(path);

		if(!QModules.loadedModules[path])
		{
			if(options.killCache)
			{
				var prefix = '?';
				if(parsedPath.indexOf('?') != -1)
				{
					prefix = '&';
				}
				parsedPath += prefix+'CacheKiller='+Math.random();
			}

			if ((QModules.loadType == 'head' || options.loadType == 'head') && (options.customOnComplete || options.asynchronous))
			{
				//console.log("head loading script: "+parsedPath);
				var script = QBuilder('script', {src: parsedPath});

				//ganked from jQuery -- https://github.com/jquery/jquery/blob/master/src/ajax/script.js
				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort )
				{
					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) )
					{
						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort )
						{
							QModules.moduledLoaded(options);
						}
					}
				};

				document.head.appendChild(script);
			}
			else
			{
				var requestObj = new Ajax.Request(parsedPath, options);
			}
		}
		else if(options.customOnComplete)
		{
			options.customOnComplete.defer();
		}
	},
	onModuleLoad:function(transport)
	{
		//safari sometimes returns a 412 (Precondition failed) error. I have no idea why.
		//if we get a 412 back then try one more time with the cacheKiller string
		if(transport.status == 412 && !transport.request.options.killCache)
		{
			transport.request.options.killCache = true;
			QModules.loadModule(transport.request.options.modulePath, transport.request.options);
			return;
		}


		//The following has IE6 problems it looks like. so its been commented out. its used in conjuntion with evalJS:false above.
		if (QModules.loadType == 'script' || QModules.loadType == 'head')
		{
			try
			{
				//run the code in the global scope
				QModules.exec(transport.responseText);
			}
			catch(e)
			{
				QES_Error('Error loading script module: '+e);
			}
		}
		else if(transport.request.options.evalJS === false)
		{
			try
			{
				//run the module code
				new Function(transport.responseText)();
			}
			catch(e)
			{
				QES_Error('Error running module: '+e);
			}
		}

		if(transport.status == 200)
		{
			QModules.moduledLoaded(transport.request.options);
		}
	},

	/** Called after the module is completely loaded and evaluated */
	moduledLoaded: function(options)
	{

		if(options.modulePath)
		{
			QModules.loadedModules[options.modulePath] = 'loaded';
		}

		if(options.customOnComplete)
		{
			try
			{
				options.customOnComplete();
			}
			catch(e)
			{
				console.error(e);
			}
		}
	},
	/**
	 * Dynamically Loads a stylesheet from Qualtrics/Product/StyleSheets/
	 */
	loadStylesheet:function(path, options)
	{
		options = options || {};

		var fullPath = '/WRQualtricsShared/Stylesheet.php?';
		if(path.indexOf('/') == -1)
		{
			fullPath += 'p=ControlPanel&s='+path;
		}
		else //we assume there are no query parameters on the path, cause it should be a .css file
		{
			fullPath += 'sf=' + encodeURIComponent(path.split('?')[0]);
		}
		fullPath = QModules.getVersionedFile(fullPath, true);

		//check if we are making a blocking request
		if (options.blocking && !QModules.loadedModules[fullPath])
		{
			QModules.loadedModules[fullPath] = 'loaded';
			//ajax in the css
			new Ajax.Request(fullPath, {
				method: 'get', //so the browser caches it
				asynchronous: false, //this is what blocking means
				onComplete: QModules.onStylesheetLoad
			});

			return;
		}

		(function(){
			if(!QModules.loadedModules[fullPath]) //dont load the stylesheet twice.
			{
				QModules.loadedModules[fullPath] = 'loaded';
				//append the link
				var link = QBuilder('link',{rel:'stylesheet', type:'text/css', href:fullPath});
				document.getElementsByTagName("head")[0].appendChild(link);
			}
			if (options.onLoad && options.triggerClass)
			{
				var triggerElement = QBuilder('span',{className:options.triggerClass});
				$(triggerElement).hide();
				document.body.appendChild(triggerElement);
				new PeriodicalExecuter(function(pe){
					var color = $(triggerElement).getStyle('color');
					if (color == '#abcdef' || color == 'rgb(171, 205, 239)')
					{
						pe.stop();
						options.onLoad(path, options.triggerClass);
					}
				},.2);

			}
		}).defer(); //defering this helps ie6 for some reason
	},
	onStylesheetLoad:function(transport)
	{
		QModules.loadedModules[transport.request.url] = 'loaded';

		//append the link
		var style = QBuilder('style',{type:'text/css'});
		//IE <= 8 and older browsers
		if (style.styleSheet)
		{
			style.styleSheet.cssText = transport.responseText;
		}
		else
		{
			style.appendChild(document.createTextNode(transport.responseText));
		}

		document.getElementsByTagName("head")[0].appendChild(style);
	},
	/**
	 * exec is experimental and doesnt work in ie6
	 */
	exec: function(code)
	{
	    if((code+='').blank())
	    	return;

	    var script,scriptId;
	    var head = $$('head').first() || $(document.documentElement);

	    if(document.loaded)
	    {
			try
			{
				script = new Element('script', {type:'text/javascript'});
				try
				{
					//appendChild(), not insert(), must be used to trigger error
					script.appendChild( document.createTextNode(code) );
				}
				catch (e)
				{
					//the appendChild doesn't work in IE, so use this method instead...silently ignore the error
					script.text = code;
				}
				head.insert(script);
			}
			catch(e)
			{
				console.error(e);
			}
	    }
	    else
	    {
	    	//firefox 2.0.0.2/camino 1.0.4 don't execute inserted scripts synchronously when dom not loaded
	    	scriptId = '__prototype_exec_script';
	    	document.write('<script id="'+scriptId+'" type="text/javascript">'+ code +'<\/script>');
	    	script = $(scriptId);
	    }
	    script.remove();
 	},

	loadExternalModule: function(path, callback)
	{
		var head = $$('head').first() || $(document.documentElement);
		var script = new Element('script', {type:'text/javascript', src:path});

		if (callback)
		{
			if (script.onreadystatechange !== undefined)
			{
				// IE8 and below need to execute the callback differently
				script.onreadystatechange = function() {
					if (this.readyState == 'loaded' || this.readyState == 'complete')
					{
						callback();
					}
				};
			}
			else
			{
				Event.observe(script, 'load', callback);
			}
		}

		head.insert(script);
	},

	/** returns true if loaded false if it isn't.
	 * @return {bool} true if it has been included
	 */
	isLoaded: function(path)
	{
		if(!QModules.loadedModules[path])
			return false;
		else
			return true;
	},

	/**
	 * If you preloaded a module using other means, call this function to let QModules know not
	 * to try loading it again.
	 *
	 * @param array modules array of paths to mark as loaded
	 */
	markModulesLoaded: function(modules)
	{
		for (var i = 0, len = modules.length; i < len; ++i)
		{
			QModules.loadedModules[modules[i]] = 'loaded';
		}
	},

	parsePath:function(path)
	{
		path = QModules.getVersionedFile(path);
		if(path.indexOf('http') === 0)
		{
			QModules.loadType = "script";
			return path;
		}
		if(path.indexOf('./') == 0)
		{
			path = QModules.moduleBasePath+path.substr(2);
		}
		else if(path.search('/') == -1)
		{
			path = QModules.moduleBasePath+path;
		}
		else if(path.indexOf('/') !== 0)
		{
			path = QModules.basePath+path;
		}
		return path;
	},
	/**
	 * QModules.unload
	 * if you manually clear out your module to clear up memory
	 * then you will need to unload the module so it gets loaded again when requested.
	 * SurveyFlow does this.
	 */
	unload:function(path)
	{
		if(QModules.loadedModules[path])
		{
			delete QModules.loadedModules[path];
		}
		//console.dir(QModules.loadedModules)
	},
	/** Returns the file versioned appropriately.
	 * @param {string} file The file to be versioned.
	 * @param {Boolean} forceParamVersioning - if true will not put the version in the filename but just at a url get param with the version
	 * @return {string} the versioned file.
	 */
	getVersionedFile: function(file, forceParamVersioning)
	{
		if(typeof qVersion != 'undefined')
		{
			var matches = file.match(/(.*)\.(js|css|jpg|gif|png)$/i);
			
			if (!qVersion) {
				qVersion = 0;
			}
			
			if (matches && !forceParamVersioning)
			{
				//return something like javascript.1234.js
				return matches[1]+"."+qVersion+"."+matches[2];
			}
			else
			{

				//returns javascript.js?v=1234
				var prefix = '?';
				if(file.indexOf('?') != -1)
				{
					prefix = '&';
				}
				return file + prefix+'v='+qVersion;
			}
		}
		else
			return file;
	}
};

//this is the thing that handles all the clickcallbacks
Qualtrics.Event = {
	currentZoom:1,
	/**
	* Qualtrics.Event.preventEvents
	* prevent any baseDistributer events from running for a period of time.
	* this is used by dragscroll so you cant click buttons at the end of a drag.
	* @param {Number} duration- the amount of time in milliseconds before events are allowed again.
	*/
	preventEvents:function(duration)
	{
		Qualtrics.Event.preventingEvents = true;
		setTimeout(Qualtrics.Event.stopPreventingEvents, duration || 100);
	},
	stopPreventingEvents:function()
	{
		Qualtrics.Event.preventingEvents = false;
	},
	addBubbleUp:function(domNode, stopOnCallback)
	{
		if(stopOnCallback)
			return this.addBubbleUpRecursive(domNode);

		var descendants = $(domNode).descendants();
		for(var i=0,len=descendants.length; i<len; ++i)
		{
			descendants[i].setAttribute('bubbleup', true);
		}
		return domNode;
	},
	/*
	 * Like add bubbleup but stops on clickcallback and downcallback
	 */
	addBubbleUpRecursive:function(domNode)
	{
		var cur = $(domNode.firstChild);
		while(cur)
		{
			//Not a text node, and doesn't have callback
			if(cur.nodeType != 3 && !cur.hasAttribute('clickcallback') && !cur.hasAttribute('downcallback'))
			{
				cur.setAttribute('bubbleup', true);
				this.addBubbleUpRecursive(cur); //recurse
			}
			cur = $(cur.nextSibling);
		}
		return domNode;
	},
	preventingEvents:false,
	/**
	 * Helper for passing real functions that act as dotsyntax callbacks into third-party libraries.
	 *
	 * Any arguments passed to this function when called are available as $arg0, $arg1, $arg2, etc.
	 * Additionally all the arguments are available as $args and "this" is available as "$this".
	 *
	 * @param string command to run when invoked
	 * @return a function that executes the given dot syntax command when invoked, but itself references only
	 * a minimal amount of memory.
	 */
	dotCallback: function(command)
	{
		return function()
		{
			var parameterMap = {};
			parameterMap['$this'] = this;
			parameterMap['$args'] = arguments;
			for (var i = 0; i < arguments.length; ++i)
				parameterMap["$arg" + i] = arguments[i];
			Qualtrics.Event.executeDotSyntax(command, null, null, null, parameterMap);
		};
	},
	/**
	* Qualtrics.Event.baseDistributerReader:
	* this reads whatever type of callback you want and executes the callback if it finds one.
	* it also checks the parent of a bunch of inline element tags.
	* @param {Event} evt - the event
	* @param {Node} el - the thing that triggered the event
	* @param {String} callbackType - the attribute that will define the callback, .eg. clickcallback, upcallback, downcallback. or anything else you have a event observer for.
	*/
	baseDistributerReader:function(evt, el, callbackType, opt_rootObject)
	{
		if(window.QualtricsCPTools)
		{
			//they just did something so reset the inactivity timer
			QualtricsCPTools.resetTimeoutTimer();
		}

		var callbackNode = Qualtrics.Event.getCallbackNode(el, callbackType);

		//we didn't have a callback
		if (!callbackNode)
			return;

		var callback = callbackNode.getAttribute(callbackType);
		if(callback)
		{
			el = callbackNode; //I guess everyone is expecting $el to be the callback node, not the node that was clicked. If they want the node that was clicked, they use Event.element() with $evt

			//baseDistributer parses the clickCallback and routes it to where it needs to go.
			Qualtrics.Event.baseDistributer(evt, el, callback, opt_rootObject, callbackNode);
		}

	},
	/*
	 * Returns a node with a specific callback type
	 */
	getCallbackNode:function(el, callbackType)
	{
		//we don't have a valid element, or the element is disabled
		if(!(el || {}).getAttribute || el.getAttribute('disabled') == 'disabled')
			return null;

		//if bubble is null it will bubble automatically on inline elements.
		var bubble = el.getAttribute('bubbleup') || null;

		//if bubble has been specifically set to false then it will not bubble on anything
		if(bubble === 'false')
			bubble = false;

		var callbackNode = null;

		if(el.hasAttribute(callbackType))
		{
			callbackNode = el;
		}
		else if((el.tagName == 'SPAN' ||
			el.tagName == 'EM' ||
			el.tagName == 'IMG' ||
			el.tagName == 'P' ||
			el.tagName == 'B' ||
			el.tagName == 'STRONG'))
		{
			//lets support nested spans and ems
			//unless there is a bubble up that specificly says do not
			if(bubble !== false && el.parentNode)
			{
				bubble = true;
				//we are going to automatically start a bubble on these inline elements.
				//NOTE: the bubbling on nested inline elements will not continue
				//unless the parent has bubbleup
				el = $(el.parentNode);
			}
		}

		if(bubble)
		{
			while(!callbackNode && el)
			{
				if(el.hasAttribute(callbackType))
				{
					callbackNode = el;
				}
				else if((el.hasAttribute('bubbleup') || el.tagName == 'SPAN') && el.getAttribute('bubbleup') !== 'false')
				{
					el = $(el.parentNode);
				}
				else
				{
					el = null;
				}
			}
		}

		return callbackNode;
	},
	/**
	* This is the new baseDistributer that has been rewritten to take advantage of executeDotSyntax which can now do everything that the old basedistributer did AND MORE!
	* Qualtrics.Event.baseDistributer:
	* this is a whole bunch of nonsense that lets me define psuedo events as attributes, instead of creating hundreds of memory leaking slow loading events.
	* if you assign this as a click event then you would be able to use the following:
	* 	click:'nextPage' //defaults to window.nextPage
	* 	click:'Q_Global.nextPage' //lets you defines the parent
	*	click:'Q.LoadReportData' //if the parent class is a singleton then it will use the instance.
	*
	* note that you can use Qualtrics.Event.preventEvents to prevent any events from running for a period of time.
	* @param {Event} - the dom event.
	* @param {DOM Node} clickedEl - the event target.
	* @param {clickCallBack} - the function to be executed (can have a parent class defined with dot syntax)
	* @param {Object} opt_rootObject - this is used for things like evClick in reports where you are calling functions on a specific instance of something.
	* @param {DOM Node} opt_callbackNode - the node in which the callback was found.
	**/
	baseDistributer:function(event, clickedEl, clickCallBack, opt_rootObject, opt_callbackNode)
	{
		if(Qualtrics.Event.preventingEvents) return;
		if(typeof clickCallBack != 'string')
		{
			return;
		}
		//FIND THE PARAMS
		//(DEPRECATED) you can now just pass the params with (somevalue, anotherthing)
		//we need to find all the params on the element, they are defined with p1='somevalue' p2="anotherthing"
		var params = Qualtrics.Event.packageParameters(clickedEl);
		var parameterMap = {
			'$el':clickedEl || (event && Event.element(event)),
			'$evt':event,
			'$val':this.getInputValue(clickedEl),
			'$this':opt_callbackNode
		};
		var instanceId = clickedEl.getAttribute('instanceid');
		if(clickedEl.getAttribute('defer'))
		{
			//IE8 and earlier throw an error if you try to access an event member that is passed through a setTimeout
			//so we need to copy it.

			// But Firefox won't allow methods of native objects (like 'event') to be executed if they're on a copied object
			// and throws an "Illegal operation on WrappedNative prototype object" exception

			// so only copy the event object for IE8 and less
			if (Qualtrics.Browser.IE && Qualtrics.Browser.getVersion() <= 8)
			{
				var copiedEvent = {};
				for(var i in event)
				{
					copiedEvent[i] = event[i];
				}
				parameterMap['$evt'] = copiedEvent;
			}

			Qualtrics.Event.executeDotSyntax.curry(clickCallBack, instanceId, opt_rootObject, null, parameterMap, params).defer();
		}
		else
		{
			Qualtrics.Event.executeDotSyntax(clickCallBack, instanceId, opt_rootObject, null, parameterMap, params);
		}
	},
	getInputValue:function(el)
	{
		if(el)
		{
			if(el.type == 'checkbox')
			{
				return el.checked;
			}
			return el.value;
		}
	},
	packageParameters:function(el)
	{
		var paramIndex = 1;
		var params = [];
		while(paramIndex !== null)
		{
			 var param = el.getAttribute('p'+paramIndex);
			 if(param !== null)
			 {
			 	if (param === 'false')
					param = false;
			 	if (param === 'true')
					param = true;
			 	//there is a param at the index so maybe theres another one also.
			 	params.push(param);
			 	paramIndex++;
			 }
			 else
			 {
			 	//we are out of params.
			 	paramIndex = null;
			 }
		}
		return params;
	},
	/**
	* Qualtrics.Event.parseParam
	* replaces '$el' and '$evt' with the event and target respectively.
	* this is used for the special click callback variables eg (p1:'something', p2:'$el')
	* @param {String} param  - the parameter.
	* @param {Event} evt - the event of the click. will use its target if opt_target is not defined
	* @param {DomNode} opt_target - optional. the thing that was clicked. you only need this if its different than evt.target.
	* @return {String|Event|DomNode} the parsed parameter to be used in the callback.
	*/
	parseParam:function(param, evt, opt_target)
	{
		opt_target = opt_target || (evt && Event.element(evt));
		if(param == '$evt')
		{
			param = evt;
		}
		else if(param == '$el')
		{
			param = opt_target;
		}
		else if(param == '$val')
		{
			if(opt_target.type == 'checkbox')
			{
				param = opt_target.checked;
			}
			else
			{
				param = opt_target.value;
			}
		}
		return param;
	},
	globalClickHandler:function(evt)
	{
		if(!evt){evt = window.event;}
		var el = Event.element(evt);
		if(el.tagName == 'INPUT')
		{
			if(el.getAttribute('autoselect'))
			{
				if(el.value == el.getAttribute('autoselect')) $(el).activate();
			}
			if(el.getAttribute('autoclear'))
			{
				//sets the focus at the start of the input and
				//will remove the prompt text as soon as the user types the first key.
				if(el.value == el.getAttribute('autoclear')){
					 QualtricsTools.focusInput(el, 0);
				}
			}
			else if(el.getAttribute('autohide'))
			{
				//fade a label element as soon as the input is clicked
				if(Qualtrics.Inputs)
					Qualtrics.Inputs.autoHideClick(el);
			}
			else if(el.getAttribute('autoclearonclick'))
			{
				//instantly removes the prompt as soon as they click
				if(el.value == el.getAttribute('autoclearonclick')){
					 el.value = '';
					 $(el).removeClassName('AutoClearMessage');
				}
			}
		}
		if(el.getAttribute && el.getAttribute('distancedragged') && el.getAttribute('distancedragged') > 3)
		{
			//the element has been dragged by a Draggable so we don't count it as a click.
			//see QualtricsScriptaculousExtensions Draggable.prototype.updateDrag
			return;
		}
		Qualtrics.Event.baseDistributerReader(evt, el, 'clickcallback');
	},
	/**
	* Qualtrics.Event.activateOverCallbacks
	* overcallbacks are disabled by default, only enable them in the sections they are used
	**/
	activateOverCallbacks:function()
	{
		Event.observe(document, 'mouseover', Qualtrics.Event.globalOverHandler);
		Event.observe(document, 'mouseout', Qualtrics.Event.globalOutHandler);
	},
	globalOverHandler:function(evt)
	{
		evt = evt || window.event;
		var el = Event.element(evt);
		if(el.getAttribute('infobutton'))
		{
			Qualtrics.Info.showButton(el.getAttribute('infobutton'), evt);
		}
		Qualtrics.Event.baseDistributerReader(evt, el, 'overcallback');
	},
	addGlobalOutCallback:function(callback)
	{
		if(!Qualtrics.Event.globalOutCallbacks)
		{
			Qualtrics.Event.globalOutCallbacks = [];
		}
		Qualtrics.Event.globalOutCallbacks.push(callback);
	},
	globalOutHandler:function(evt)
	{
		evt = evt || window.event;
		var el = Event.element(evt);
		if(Qualtrics.Event.globalOutCallbacks)
		{
			while(Qualtrics.Event.globalOutCallbacks.length)
			{
				Qualtrics.Event.baseDistributer(evt, el, Qualtrics.Event.globalOutCallbacks.pop());
			}
		}
		Qualtrics.Event.baseDistributerReader(evt, el, 'outcallback');
	},
	globalDownHandler:function(evt)
	{
		evt = evt || window.event;
		var el = Event.element(evt);
		Qualtrics.Event.baseDistributerReader(evt, el, 'downcallback');
	},
	globalUpHandler:function(evt)
	{
		evt = evt || window.event;
		var el = Event.element(evt);
		//checking for left click prevents accidental right click menu selections
		if(Event.isLeftClick(evt) || evt.type === 'touchend')
		{
			Qualtrics.Event.baseDistributerReader(evt, el, 'mouseupcallback');
			if(window.customMouseUp)
			{
				window.customMouseUp(evt);
			}
		}
	},
	globalDblClickHandler:function(evt)
	{
		evt = evt || window.event;
		var el = Event.element(evt);
		Qualtrics.Event.baseDistributerReader(evt, el, 'doubleclickcallback');
	},
	globalKeyDownHandler:function(evt)
	{
		if(!evt){evt = window.event}
		var el = Event.element(evt);

		if(el && el.getAttribute)
		{
			//direct the arrow keys and enter to any open menus
			if(Qualtrics.Menu)
			{
				Qualtrics.Menu.handleKeyDown(evt);
			}
			if(el.getAttribute('keyentercallback'))
			{
				if(evt.keyCode == Event.KEY_RETURN)
				{
					Event.stop(evt);
					Qualtrics.Event.baseDistributer(evt, el, el.getAttribute('keyentercallback'));
				}
			}
			if(el.getAttribute('keytabcallback'))
			{
				if(evt.keyCode == Event.KEY_TAB)
				{
					Event.stop(evt);
					Qualtrics.Event.baseDistributer(evt, el, el.getAttribute('keytabcallback'));
				}
			}
			if(el.getAttribute('keydowncallback'))
			{
				Qualtrics.Event.baseDistributerReader(evt ,el, 'keydowncallback');
			}
			if(el.getAttribute('autoclear'))
			{
				//its possible for the user entered text to be the same as the autoclear text (if the autoclear value was 1 for example)
				//so we make sure that data_autoclearuserdata isnt set before removing things
				if(el.value == el.getAttribute('autoclear') && !el.getAttribute('data_autoclearuserdata')){
					 el.value = '';
					 $(el).removeClassName('AutoClearMessage');
					 el.setAttribute('data_autoclearuserdata', 'true');
				}
				else if(!el.getAttribute('data_autoclearuserdata'))
				{
					//they are entering text for the first time.
					//just remove the class and flag without clearing the value data_autoclearuserdata flag
					 $(el).removeClassName('AutoClearMessage');
					 el.setAttribute('data_autoclearuserdata', 'true');
				}
			}
			if(el.getAttribute('autohide'))
			{
				//fade a label element as soon as the input is clicked
				if(Qualtrics.Inputs)
					Qualtrics.Inputs.autoHideKeyDown(el, evt);
			}
			if(el.getAttribute('numericupdown'))
			{
				Qualtrics.Event.numericUpDown(el,evt);
			}
			if(el.getAttribute('validation'))
			{
				if(!Qualtrics.alphaNumericValidation(el, evt))
					return false;
			}

		}

		if(Qualtrics.customKeyDown)
		{
			Qualtrics.customKeyDown(evt);
		}
		//Don't let the browser go back
		if(evt.keyCode == Event.KEY_BACKSPACE && !Qualtrics.Reporting)
		{
			if(el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA' || window.inlineEditor.getInstance() || el.hasAttribute('contenteditable'))
			{


			}
			else
			{
				Event.stop(evt);
			}
		}
		//undo on ctrl/cmd-z
		if(evt.keyCode == 90)
		{
			if(el && el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA')
			{
				//we dont want to undo cause the browser does its own
			}
			else
			{
				if(evt.metaKey || evt.ctrlKey)
				{
					if(evt.shiftKey)
					{
						Qualtrics.History.getInstance().redo();
					}
					else
					{
						Qualtrics.History.getInstance().undo();
					}
				}
			}

		}
		//stop the space bar from scrolling the page when there are windows
		if(evt.keyCode == 32)
		{
			if(el && el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA' || inlineEditor.getInstance())
			{
				//we dont want to prevent the space bar because they are typing.
			}
			else
			{
				if (Q_Window.getWindowCount())
					Event.stop(evt);
			}

		}

		//global ctrl+s handler will call Qualtrics.savePage if defined
		if (Qualtrics.savePage)
		{
			if(evt.keyCode == 83 && (evt.ctrlKey || evt.metaKey))
			{
				Event.stop(evt);
				Qualtrics.savePage(true);
				return false;
			}
		}



	},
	globalKeyUpHandler:function(evt)
	{
		var el = Event.element(evt);

		if(el.getAttribute('autohide'))
		{
			//fade a label element as soon as the input is clicked
			if(Qualtrics.Inputs)
				Qualtrics.Inputs.autoHideKeyUp(el, evt);
		}
		if(el.getAttribute('qautosuggest'))
		{
			QModules.loadModule('QAutoSuggest.js');
			if (el.qAutoSuggest)
			{
				el.qAutoSuggest.handleKeyPress(evt);
			}
			else
			{
				var instanceid = el.getAttribute('instanceid');
				var list = Qualtrics.Event.executeDotSyntax(el.getAttribute('qautosuggest'),instanceid);
				var as = new Qualtrics.AutoSuggest(el,{keycallback:true,list:list});
				as.handleKeyPress(evt);
				el.qAutoSuggest = as;
			}
		}
		if(el.getAttribute('qautocomplete'))
		{
			QModules.loadModule('QAutoComplete.js');

			if (el.qAutoComplete)
			{
				el.qAutoComplete.handleKeyPress(evt);
			}
			else
			{
				instanceid = el.getAttribute('instanceid');
				list = Qualtrics.Event.executeDotSyntax(el.getAttribute('qautocomplete'),instanceid);
				var ac = new QAutoComplete(el,{keycallback:true,list:list});
				ac.handleKeyPress(evt);
				el.qAutoComplete = ac;
			}
		}
		if(el.getAttribute('numericmax') || el.getAttribute('numericmin'))
		{
			Qualtrics.Event.limit(el,evt);
		}
		Qualtrics.Event.baseDistributerReader(evt ,el, 'keyupcallback');
		if(evt.keyCode == Event.KEY_DELETE || evt.keyCode == Event.KEY_BACKSPACE)
		{
			if(el.getAttribute('autoclear'))
			{
				if(el.value == '')
				{
					//the input is empty again so put the autoclear prompt back
					el.value = el.getAttribute('autoclear');
					el.removeAttribute('data_autoclearuserdata');
					$(el).addClassName('AutoClearMessage');
					QualtricsTools.focusInput(el, 0);
				}
			}
		}
		if(el.getAttribute('validation'))
		{
			//make sure nothing snuck in (we allow symbols behind the number keys because of french keyboard layouts)
			Qualtrics.alphaNumbericInputFilter(evt, el);
		}
	},
	/**
	 * Qualtrics.Event.execute:
	 * this will execute a raw function or a dotsyntax expression
	 **/
	execute:function(command,params,opt_scope)
	{
		params = params || [];
		if(typeof command == 'function')
		{
			//just run the function.
			return command.apply(opt_scope, params);
		}
		else if(typeof command == 'string')
		{
			return Qualtrics.Event.executeDotSyntax(command, null, opt_scope, params);
		}
	},
	/**
	* Qualtrics.Event.executeDotSyntax
	* executes javascript functions kind of like eval would.
	* @param {Boolean} opt_forcedParams - you can define parameters if you must. otherwise you can just use parethesis in the command
	* @param {Object} opt_parameterMap - you can define specials strings to be remapped to something else. eg {'$evt':window.event}
	*/
	executeDotSyntax:function(command, opt_instanceId, opt_root, opt_forcedParams, opt_parameterMap, opt_defaultParams, opt_quiet)
	{
		if(command)
		{
			if(command.indexOf(';') != -1)
			{
				//execute multiple commands
				var commands = command.split(';');
				var lastValue = null;
				for(var i=0,len=commands.length; i<len; ++i)
				{
					lastValue = Qualtrics.Event.executeDotSyntax(commands[i].strip(), opt_instanceId, opt_root, opt_forcedParams, opt_parameterMap, opt_defaultParams);
				}
				//returns the return from whatever the last command was.
				return lastValue;
			}
			var pkg = Qualtrics.Event.getDotSyntaxParts(command, opt_instanceId, opt_root, opt_quiet);

			//we didn't get a valid syntax string
			if (!pkg) return;

			var params = pkg[3] || opt_defaultParams || [];
			if(opt_forcedParams && opt_forcedParams.length)
			{
				params = opt_forcedParams;
			}
			opt_parameterMap = opt_parameterMap || {};

			//add some global param maps for passing null, undefined.
			opt_parameterMap['$null'] = null;
			opt_parameterMap['$undefined'] = undefined;
			if(params.length)
			{
				//remap any matching params
				for(var i=0,len=params.length; i<len; ++i)
				{
					var param = params[i];
					if(opt_parameterMap[params[i]] !== undefined)
					{
						//remap the param to whatever is on the right side.
						params[i] = opt_parameterMap[params[i]];
					}
					if(params[i] == '$availableVariables')
					{
						params[i] = opt_parameterMap;
					}
					if (typeof param == 'string' && param.indexOf('.') !== -1)
					{
						var dotSyntaxParts = param.split('.');
						var base = dotSyntaxParts[0];
						var newParam = dotSyntaxParts[1];

						if (opt_parameterMap[base] && opt_parameterMap[base][newParam])
						{
							//console.log('found dot syntax for parameter of ', base, ' inside opt_parameterMap map. Overriding param val to: ',opt_parameterMap[base][newParam]);
							params[i] = opt_parameterMap[base][newParam];
						}
						else if (opt_parameterMap[base])
						{
							params[i] = undefined;
						}
					}
				}
			}
			var returnVal = pkg[0].apply(pkg[1], params);
			return returnVal;

		}
	},
	/**
	* Qualtrics.Event.getDotSyntaxValue
	* this returns a value from a dotsytax string. eg. Properties.Colors.backgroundColor
	* @param {String} command -the dotsyntax string.
	* @param {Object} opt_root - the place to start looking.
	**/
	getDotSyntaxValue:function(command, opt_root)
	{
		var pkg = Qualtrics.Event.getDotSyntaxParts(command, null, opt_root, true);
		if(pkg && pkg.root && pkg.callBack)
		{
			return pkg.root[pkg.callBack];
		}
	},
	/**
	* Qualtrics.Event.callbackHasParams
	*/
	callbackHasParams:function(command)
	{
		if(command.lastIndexOf(')') === command.length-1)
		{
			return true;
		}
		return false;
	},
	/**
	* Qualtrics.Event.getDotSyntaxParts
	* takes a command in dot syntax and returns a real function ready to be executed. it also returns the "this" object, so that
	* you can run the function in the correct scope.
	* you can use pkg.method.apply(pkg.root) or pkg.method.call(pkg.root) with the array it returns.
	*
	* @param {String} command - eg. Qualtrics.Event.getDotSyntaxParts
	*         including parameters:
	*				you can pass in parameters right in the commmand if you want, no quotes: Qualtrics.Event.getDotSyntaxParts(someparam, anotherone)
	*
	*         including instanceIds:
	*         		If the function you need is inside an instance of an object with a static getInstance(instanceId) method. you can include the instanceId delimited by a colon.
	*
	*               Qualtrics.someSpecialClass.someFunction:1234(foo, bar)
	*
	*               translates to Qualtrics.someSpecialClass.getInstance('1234').someFunction('foo', 'bar');
	*
	* @return {Object}
	* [method] {Function} - the method,
	* [root] {Object} - the "this" object,
	* [callBack] {String} - the string of the method name
	* [params] {Array} - any params that were parsed out of the dotsyntax
	*/
	getDotSyntaxParts:function(command, opt_instanceId, opt_alternateRoot, opt_quiet)
	{
		var params, originalCommand = command;
		//first extract any parameters if parenthesis exist.
		if( Qualtrics.Event.callbackHasParams(command))
		{
			var openIndex = command.indexOf('(');
			if(openIndex != -1)
			{
				var paramsString = command.substring(openIndex+1, command.lastIndexOf(')'));
				var str = paramsString;
				if (str)
				{ // Parsing empty parameters is not recommended
					//split the commas unless they are wrapped in parentheses
					//NOTE: this will only escape 1 sub function
					var tokens = [];
					var i = -1;
					do{
						i = str.indexOf(',');
						var openP = str.indexOf('(');
						var closeP = str.indexOf(')');
						if(openP > -1 && openP < i)
						{
							//the comma is inside another set of parentheses so we will
							//skip that comma and move to the next comma after the closing )
							i = str.indexOf(',', closeP);
						}
						if(i>-1)
						{
							tokens.push(str.substring(0, i));
							str = str.substring(i+1);
						}
					}while(i > -1);
					tokens.push(str);
					//end split

					params = tokens;
					 //trim the whitespace from all the params
					params = params.invoke('strip');
					//strip the params out of the command

					//trim the whitespace from all the params,
					//then convert '3','true','false','null','{"a":true}' to it's real values
//					params = tokens.collect(function(s) {
//						s = s.strip();
//						if (s.isJSON()) //numbers, null, true/false and json objects will all convert while keeping $evt and other strings
//							s = Qualtrics.parseJSON(s) || s; //if it still fails, we want to continue running
//						return s;
//					});

				}
				command = command.substring(0, openIndex);
			}
		}

		//then extract any instanceIds, these can be on the end of the command seperated with a colon.
		//eg Qualtrics.someFunction:1234 this will use 1234 as the instanceId
		if(command.indexOf(':') != -1)
		{
			opt_instanceId = command.substring(command.indexOf(':')+1);
			command = command.substring(0, command.indexOf(':'));
		}
		var parts = command.split('.');
		var root = opt_alternateRoot || window;
		var method = null;
		var _this = window;
		var callBack = null;
		for(var i = 0, len=parts.length; i<len; ++i)
		{
			method = root[parts[i]];
			if(parts[i+1])
			{
				if(!method)
				{
					if(!opt_quiet)
					{
						//we can report errors on every part but the last, because the last might
						//depend on an instanceId which we have not yet evaluated.
						console.error('getDotSyntaxParts: Cannot find object: ' + parts[i] + ' in: ' + originalCommand);
					}
					return;
				}
				root = method;
				method = root[parts[i+1]];

			}
			else
			{
				method = root[parts[i]];
				callBack = parts[i];
				_this = root;
			}
		}
		//this will also find instances of classes that have a getInstance() method. so lets check for that now.
		//will work with singletons or you can pass an instanceId.

		if(root.getInstance)
		{
			if(root.getInstance(opt_instanceId) && root.getInstance(opt_instanceId)[callBack] !== undefined)
			{

				method = root.getInstance(opt_instanceId)[callBack];
				_this = root.getInstance(opt_instanceId);
			}
		}
		if(method === undefined)
		{
			if(!opt_quiet)
			{
				//now that we should have a final method.
				console.error('getDotSyntaxParts 2: Cannot find object: ' + callBack + ' in: ' + originalCommand);
			}
			return;

		}
		if(params)
		{
			//convert the string 'null' to a real null
			for(i=0,len=params.length; i<len; ++i)
			{
				if(params[i] == 'null')
				{
					params[i] = null;
				}
			}
		}
		var pkg = {};
		pkg.method = method;
		pkg.callBack = callBack; //this is just to provide the string name of the method (or variable). The inlineEditor variable binding uses this.
		pkg.root = _this;
		pkg.params = params;


		//provide this weird array indexes for old code. (these are deprecated)
		pkg[0] = method;
		pkg[1] = pkg.root;
		pkg[2] = callBack; //this is just to provide the string name of the method (or variable). The inlineEditor variable binding uses this.
		pkg[3] = params;

		return pkg;
	},
	isValidCallback:function(dotSyntax)
	{
		var func;
		try
		{
			var parts = this.getDotSyntaxParts(dotSyntax, undefined, undefined, true);
			func = (typeof parts[0] === 'function');
		}
		catch (e)
		{
			// no op
			func = false;
		}
		return func;
	},
	getClass:function(dotSyntax)
	{
		var parts = dotSyntax.split('.');
		var classObj = window;
		for(var i = 0, len=parts.length; i<len; ++i)
		{
			classObj = classObj[parts[i]];
		}
		return classObj;
	},
	numericUpDown:function(el, evt)
	{
		var val = el.value;
		if (!isNaN(val))
		{
			val*=1;//make sure it's not a string
			switch (evt.keyCode)
			{
				case Event.KEY_DOWN:
					if (val > 0)
						el.value = val - 1;
					Event.stop(evt);
				break;
				case Event.KEY_UP:
					el.value = val + 1;
					Event.stop(evt);
				break;
			}
		}
		if(!Qualtrics.isNumericKey(evt))
		{
			Event.stop(evt);
			return false;
		}


	},
	limit:function(el, evt)
	{
		var max = el.getAttribute('numericmax');
		var min = el.getAttribute('numericmin');
		var val = el.value;
		if (val !== null && isNaN(val))
		{
			return;
		}
		val*=1;
		if (max !== null && !isNaN(max))
		{
			max*=1;
			if (val > max)
			{
				el.value = max;
			}
		}
		if (min !== null && !isNaN(min))
		{
			min*=1;
			if (val < min)
			{
				el.value = min;
			}
		}
	},
	globalResizeHandler:function(evt)
	{
		if(Qualtrics.Event.zoomDetectDelay)
		{
			clearTimeout(Qualtrics.Event.zoomDetectDelay);
		}
		Qualtrics.Event.zoomDetectDelay = setTimeout(Qualtrics.Event.detectZoom, 500);
		//update any open menus
		if (Qualtrics.Menu)
		{
			Qualtrics.Menu.positionMenus(true);
		}
	},
	detectZoom:function()
	{
		if(Qualtrics.Event.zoomDetectDelay)
		{
			Qualtrics.Event.zoomDetectDelay = null;
		}
		if (Qualtrics.DetectZoom)
		{
			var currentZoom = Qualtrics.DetectZoom.zoom();

			if(Qualtrics.Event.currentZoom != currentZoom)
			{
				Qualtrics.Event.currentZoom = currentZoom;
				Qualtrics.Event.onZoomChange();
			}
		}
	},
	onZoomChange:function()
	{
		if(Qualtrics.Event.currentZoom != 1)
		{
			$(document.body).addClassName('IsZoomed');
		}
		else
		{
			$(document.body).removeClassName('IsZoomed');
		}
	},
	load:function()
	{
		if(Qualtrics.onLoad)
		{
			Qualtrics.onLoad();
		}
	},
	/**
	 * Qualtrics.Event.getSelfFunction:
	 * A helper for returning a dotsyntax string refering to functions a class.
	 * Returns a dotsyntax string for refering to functions in the self class.
	 * @param {string} classPath - the path to the class eg. (Qualtrics.Reporting)
	 * @param {string} 1 - the id of the instance. the class must have a static getInstance method.
	 * @param {string} 2 - the functionName
	 * @param {string} 3+ the args to the function
	 * @return {string} a dotsyntax string representing the function the instance id and the arguments.
	 **/
	getSelfFunction:function(classPath, instanceId, args)
	{
		var functionName = args[0];
		var dotSyntaxExpression = classPath+'.'+functionName;
		if(instanceId)
		{
			dotSyntaxExpression += ':'+instanceId;
		}
		if(args[1] !== undefined)
		{
			dotSyntaxExpression += '(';
			for(var i=1, len=args.length; i<len; ++i)
			{
				if(i != 1)
				{
					dotSyntaxExpression +=',';
				}
				dotSyntaxExpression += args[i];
			}
			dotSyntaxExpression +=' )';
		}
		return dotSyntaxExpression;
	}
};


Event.observe(window, 'load',  Qualtrics.Event.load);
Event.observe(document, 'click',  Qualtrics.Event.globalClickHandler);
Event.observe(document, 'dblclick', Qualtrics.Event.globalDblClickHandler);
Event.observe(document, 'touchstart', Qualtrics.Event.globalDownHandler);
Event.observe(document, 'mousedown', Qualtrics.Event.globalDownHandler);
Event.observe(document, 'touchend', Qualtrics.Event.globalUpHandler);
Event.observe(document, 'mouseup', Qualtrics.Event.globalUpHandler);
Event.observe(document, 'keydown', Qualtrics.Event.globalKeyDownHandler);
Event.observe(document, 'keyup', Qualtrics.Event.globalKeyUpHandler);
Event.observe(window,'resize',Qualtrics.Event.globalResizeHandler);
var mousePos = new Array();//the current mouse position
Event.observe(document, 'mousemove', updateMousePos);
function updateMousePos(event, forcedY){

	if(event){

		mousePos[0] = ((event.pageX) || (event.clientX+window.scrollInfo[0]));
		mousePos[1] = ((event.pageY) || (event.clientY+window.scrollInfo[1]));

		if(forcedY)
		{
			mousePos[1] = forcedY;
		}
		if(window.Q_Window)
		{
			var chopped = Q_Window.getChopOffset();
			if(chopped)
			{
				if(chopped[0]) mousePos[0] = mousePos[0]-chopped[0];
				if(chopped[1]) mousePos[1] = mousePos[1]-chopped[1];
			}
		}
		if(window.updateCustomMousePos)
		{
			window.updateCustomMousePos(event);
		}
	}
}


/** QualtricsCPTools.js
 Holds the javascript for the CP specific items.
 */
// --------------------------------------------------------------------------------------
// THIS FILE CONTAINS ALL OF THE JAVASCRIPT PAGE FUNCTIONS USED IN THE QUALTRICS ENGINE
// --------------------------------------------------------------------------------------

function QError(msg)
{
	console.error('QES_Error '+msg);
	console.trace();
}

//The following should all be removed and put into only the sections that need it because none are
//used in all sections.

// * FOR PAGE NAVIGATION ***************************************************************************************

function PageAction(ClientAction, Section, SubSection, SubSubSection, repeatable, dontChangeAction, options, asyncSavePage)
{
	if (Qualtrics.savePage)
	{
		Qualtrics.savePage(asyncSavePage);
		Event.stopObserving(window, 'unload', Qualtrics.savePageOnUnload);
	}

	if (SubSection === undefined)
	{
		SubSection = '';
	}
	if (SubSubSection === undefined)
	{
		SubSubSection = '';
	}

	if (ClientAction == 'ChangePage')
	{
		var pathArray = window.location.pathname;
		var pathname = pathArray.substring(0, pathArray.lastIndexOf("/"));
		var product = URLTools.getProduct();

		if (pathArray == '/' + product || pathArray.indexOf(product + '/') == 1)
			return URLTools.changePage(Section, SubSection, SubSubSection);

		var url = pathname + '?ClientAction=ChangePage&s=' + Section + '&ss=' + SubSection + '&sss=' + SubSubSection;
		if(options)
		{
			url += '&options=' + options;
		}
		window.location = url;
	}
	else
	{
		var page = $('Page');
		page.ClientAction.value = ClientAction;
		page.Section.value = Section;
		page.SubSection.value = SubSection;
		page.SubSubSection.value = SubSubSection;
		if ((typeof(repeatable) == 'string' && repeatable == 'true') || (typeof(repeatable) != 'string' && repeatable))
		{
			page.Repeatable.value = '1';
		}
		if(options && page.PageActionOptions)
		{
			page.PageActionOptions.value = options;
		}
		//reset the action to clear the url bar
		if (!dontChangeAction)
			page.action = '?';

		submitForm(page);
		if(Qualtrics.Browser.IE && Qualtrics.Browser.Version == 6)
		{
			//give ie6 a little kick, fixes bug #44935. this code shouldn't harm anything.
			//I just dont want this garbage being run in good browsers.
			window.href = window.href;
		}

		//Clear action for any subsequent posts
		page.ClientAction.value = '';

		return false;
	}
}

function PageActionGet(ClientAction, Section, SubSection, SubSubSection, repeatable, options)
{
	var page = $('Page');
	page.method = 'GET';
	if ($('T'))
		$('T').remove();

	(function(){
		//fixes bug #50086. IE6 cant change the page sometimes without this defer,
		//like when you tried go to the translate section it would just sit there.
		return PageAction(ClientAction, Section, SubSection, SubSubSection, repeatable, null, options);
	}).defer();
	return;
}

function PageActionJumpTo(ClientAction, Section, SubSection, SubSubSection, jump_to)
{

	var page = $('Page');
	page.ClientAction.value = ClientAction;
	page.Section.value = Section;
	page.SubSection.value = SubSection;
	page.SubSubSection.value = SubSubSection;
	page.action = jump_to;

	submitForm(page);

	return false;
}
function is_int( mixed_var ) {
		// %        note 1: 1.0 is simplified to 1 before it can be accessed by the function.
		// *     example 1: is_int(23)
		// *     returns 1: true
		// *     example 2: is_int('23')
		// *     returns 2: false
		// *     example 3: is_int(23.5)
		// *     returns 3: false
		// *     example 4: is_int(true)
		// *     returns 4: false
		if (typeof mixed_var !== 'number') {
				return false;
		}
		if (parseFloat(mixed_var) != parseInt(mixed_var)) {
				return false;
		}
		return true;
}

/**
 * Compares the passed in lang code to decide if the language
 * is an RTL language
 *
 * @param  String  lang The language code
 *
 * @return {Boolean}      true if the language is RTL
 */
function isRTLLanguage(lang)
{
	return lang === 'HE' ||
		lang === 'AR' ||
		lang === 'FA' ||
		lang === 'UR';
}

function array_merge() {
		// -    depends on: is_int
		// %          note: Relies on is_int because !isNaN accepts floats
		// *     example 1: arr1 = {"color": "red", 0: 2, 1: 4}
		// *     example 1: arr2 = {0: "a", 1: "b", "color": "green", "shape": "trapezoid", 2: 4}
		// *     example 1: array_merge(arr1, arr2)
		// *     returns 1: {"color": "green", 0: 2, 1: 4, 2: "a", 3: "b", "shape": "trapezoid", 4: 4}
		// *     example 2: arr1 = []
		// *     example 2: arr2 = {1: "data"}
		// *     example 2: array_merge(arr1, arr2)
		// *     returns 2: {1: "data"}

		var args = Array.prototype.slice.call(arguments);
		var retObj = {}, k, j = 0, i = 0;
		var retArr;

		for (i=0, retArr=true; i < args.length; i++) {
				if (!(args[i] instanceof Array)) {
						retArr=false;
						break;
				}
		}

		if (retArr) {
				return args;
		}
		var ct = 0;

		for (i=0, ct=0; i < args.length; i++) {
				if (args[i] instanceof Array) {
						for (j=0; j < args[i].length; j++) {
								retObj[ct++] = args[i][j];
						}
				} else {
						for (k in args[i]) {
								if (is_int(k)) {
										retObj[ct++] = args[i][k];
								} else {
										retObj[k] = args[i][k];
								}
						}
				}
		}

		return retObj;
}
function array_merge_recursive (arr1, arr2){
		// -    depends on: array_merge
		// *     example 1: arr1 = {'color': {'favourite': 'read'}, 0: 5}
		// *     example 1: arr2 = {0: 10, 'color': {'favorite': 'green', 0: 'blue'}}
		// *     example 1: array_merge_recursive(arr1, arr2)
		// *     returns 1: {'color': {'favorite': {0: 'red', 1: 'green'}, 0: 'blue'}, 1: 5, 1: 10}

		var idx = '';

		if ((arr1 && (arr1 instanceof Array)) && (arr2 && (arr2 instanceof Array))) {
				for (idx in arr2) {
						arr1.push(arr2[idx]);
				}
		} else if ((arr1 && (arr1 instanceof Object)) && (arr2 && (arr2 instanceof Object))) {
				for (idx in arr2) {
						if (idx in arr1) {
								if (typeof arr1[idx] == 'object' && typeof arr2 == 'object') {
										arr1[idx] = array_merge_recursive(arr1[idx], arr2[idx]);
								} else {
										arr1[idx] = arr2[idx];
								}
						} else {
								arr1[idx] = arr2[idx];
						}
				}
		}

		return arr1;
}


/**
 * Helper object to parse the query string variables from
 * <script> element's src attribute.
 *
 * For example, in test.html:
 *
 *   <script src="test.js?name=value"></script>
 *
 * and in test.js, you can get query as name/value pairs:
 *
 *   var queries = new ScriptQuery('test.js').parse();
 *   for (var name in queries) {
 *     var values = queries[name]; // property is Array instance.
 *     ...
 *   }
 *
 * If you would like to avoid array manipulation.
 * ScriptQuery also provides flatten method, which returns
 * only first value for each properties.
 *
 *   var queries = new ScriptQuery('test.js').flatten();
 *   for (var name in queries) {
 *     alert(queries[name]); // property is simply string
 *   }
 */
var ScriptQuery = function(scriptPath) {
	this.scriptPath = scriptPath;
};
ScriptQuery.prototype = {
	parse: function(url) {
		var result = {};
	if (!url)
		url = this.scriptPath;
		var query = url.split('?')[1];
		if (!query)
			return null;

		var components = query.split('&');

		for (var i = 0; i < components.length; i++) {
			var pair = components[i].split('=');
			var name = pair[0], value = pair[1];

			if (!result[name]) result[name] = [];
			// decode
			if (!value) {
				value = 'true';
			} else {
				try {
					value = decodeURIComponent(value);
				} catch (e) {
					value = unescape(value);
				}
			}

			// MacIE way
			var values = result[name];
			values[values.length] = value;
		}
		return result;
	},
	flatten: function(url) {
		var queries = this.parse(url);
		for (var name in queries) {
			queries[name] = queries[name][0];
		}
		return queries;
	},
	toString: function() {
		return 'ScriptQuery [path=' + this.scriptPath + ']';
	}
};

/** This class contains all of the javascript to close windows*/
var ClosePopupWindows =
{
	/**
	* ClosePopupWindows.closePopUpWindow
	*
	* Closes a popup window. Does nothing with the parent
	*
	**/
	closePopUpWindow: function(opt_windowName)
	{
		//New way of closing window
		if (!window.opener)
		{
			var queries = new ScriptQuery().parse(window.location.href);
			if (opt_windowName || queries && parent.Q_Window.getWindow(queries['WID']))
			{
				Q_Window.closeWindow(opt_windowName || queries['WID']);
			}
			else
			{
				Q_Window.closeWindow();
			}
		}
		else
		{
			window.close();
		}
	},
	/** Takes a url and gets rid of any # that we might have on it and possibly ?. */
	_cleanUrl: function(url, removeQuery)
	{
		if (removeQuery)
		{
			var index = url.lastIndexOf('?');
			if(index != -1)
				url = url.substring(0,index);
		}
		index = url.lastIndexOf('#');
		if(index != -1)
			url = url.substring(0,index);

		return url;
	},
	/** Closes the window and refreshes the parent */
	closeWindowAndRefreshMaster: function()
	{
		if (!window.opener)
		{
			var url = this._cleanUrl(parent.location.href);
			parent.location.href = url;
			//doing it twice seems to help...
			parent.location.href = url;
		}
		else
		{
			url = this._cleanUrl(window.opener.location.href);
			window.opener.location.href = url;
			//doing it twice seems to help...
			window.opener.location.href = url;
		}

		this.closePopUpWindow();
	},
	/** Closes a popup window and refreshes the parent but does it by submitting the page */
	closeWindowAndSubmitMaster: function(clientAction, bookmark)
	{
		if (!bookmark) //if not defined make it a empty string
			bookmark = '';

		try
		{
			if (!window.opener)
			{
				if(parent && parent.document.Page)
				{
					// Clearing out any previous client actions
					if (parent.document.Page.ClientAction)
							parent.document.Page.ClientAction.value = clientAction;
					if(parent.document.Page.onsubmit)
						parent.document.Page.onsubmit();

					parent.document.Page.submit();
				}
			}
			else
			{
				if(window.opener && window.opener.document.Page)
				{
					// Clearing out any previous client actions
						window.opener.document.Page.ClientAction.value = clientAction;
					if(window.opener.document.Page.onsubmit)
						window.opener.document.Page.onsubmit();
					window.opener.document.Page.submit();
				}
			}
		}
		catch (e)
		{
			console.error('closeWindowAndSubmitMaster error:' + e);
		}

		this.closePopUpWindow();
	}
};
// Returns the CK editor object with all of the properties correctly set
// now uses the CK editor instead of the FCK editor
function createFCKEditor(id, width, height, updateOnSubmit, surveyId, instanceReadyFunc, options)
{
	if ($(id))
	{
		var offsetHeight = 112;
		//if you don't specify a width and height, just use the text box's width and height
		if (!width)
		{
			width = $(id).getWidth();
		}
		if (!height)
		{
			height = $(id).offsetHeight-offsetHeight;
		}
	}

	//Setup default function to run when instance is ready of focusing itself
	if (instanceReadyFunc == undefined)
	{
		instanceReadyFunc = function(e) {
			e.editor.focus();
		};
	}
	if(!options)
	{
		options = {};
	}
	var options = Object.extend(options,{
		width:width,
		height:height,
		on:{instanceReady:instanceReadyFunc}
	});

	var firstButton = null;
	switch (surveyId)
	{
		case 'LibMessage' :
			firstButton = 'QSurveyLink';
			break;
		case 'TSInviteOrReminderMessage' :
			firstButton = 'QThreeSixtyLink';
			break;
	}

	var QFileButton = 'QFile';
	if (Qualtrics.System.productName == 'ThreeSixty')
	{
		QFileButton = '';
	}

	if (firstButton != null)
	{
		//use a different toolbar
		options.toolbar = [
			[firstButton, 'QSmartText','QImage', QFileButton,'QVideo','-','SpecialChar','Table','Link','Unlink'],['Undo','Redo'],['JustifyLeft','JustifyCenter','JustifyRight','-','Outdent','Indent','-','NumberedList','BulletedList'],['Source'],
			'/',
			['RemoveFormat'],['Font','FontSize'],['Bold','Italic','Underline','-','Subscript','Superscript'],['BGColor','TextColor']
		];
	}

	var ckid = $(id).id;
	if (CKEDITOR.instances && CKEDITOR.instances[ckid])
	{
		//for some reason an editor already exists with the same name
		CKEDITOR.remove(CKEDITOR.instances[ckid]);
	}
	if(options && !options.language && Qualtrics.User.language)
	{
		options.language = Qualtrics.User.language;
	}
	var editor = CKEDITOR.replace(id, options);
	if (updateOnSubmit) {
			Event.observe('Page', 'submit',
			function() {
				if (editor)
				{
					var data = editor.getData();
					$(id).value = data;
				}
			}
		);
		}
	return editor;
}

function submitAllCheckBoxes(notCheckedValue)
{
	var elements = document.getElementsByTagName("input");

	for(var i=0; i < elements.length; i++)
	{
		if (elements[i].getAttribute("type") == "checkbox")
		{
			if (!elements[i].checked)
			{
				//check to see if we have a not checked value specific to this box
				if (elements[i].getAttribute("notCheckedValue"))
					var elemNotCheckedValue = elements[i].getAttribute("notCheckedValue");
				else
					elemNotCheckedValue = notCheckedValue;

				//check it and make the value be no
				elements[i].style.visibility = 'hidden';
				elements[i].checked = true;
				elements[i].value = elemNotCheckedValue;
			}
		}
	}
}

/** submits a css type button. There must be a hidden element that can be submitted
 * as if it were a button.
 */
function submitButton(element, formID, inputID, inputName, inputValue)
{
	var form = $(formID);
	var input = $(inputID);

	if (input)
	{
		input.setAttribute('name', inputName);
		input.setAttribute('value', inputValue);
	}

	submitForm(formID);
}

function setupCalendarObserver(elementID, buttonElementID, destinationElementID)
{
	var calendarClickObserver = function(event){
		Event.stopObserving($(elementID), 'click', calendarClickObserver);
		Event.stop(event);
		displayCalendar($(destinationElementID), "yyyy-mm-dd", $(buttonElementID), false, null);
		var calendarCloseCheck = function(event){
			if (event && !event.findElement('#calendarDiv')) // Check to see if we've clicked outside the calendar
			{
				closeCalendar();
				Event.stopObserving(document, 'click', calendarCloseCheck);
				if ($(elementID)) // If we're closing a popup window, this sneaky handler still sometimes sticks around
					$(elementID).observe('click', calendarClickObserver);
			}
		};
		Event.observe(document, 'click', calendarCloseCheck);
	};
	$(elementID).observe('click', calendarClickObserver);
}
function qualtricsPopupCalendar(buttonElementID, destinationElementID, xoffset, yoffset)
{
	displayCalendar($(destinationElementID), "yyyy-mm-dd", $(buttonElementID), false, null);
}
function qualtricsPopupCalendarWithTime(buttonElementID, destinationElementID, xoffset, yoffset)
{
	displayCalendar($(destinationElementID), "yyyy-mm-dd hh:ii", $(buttonElementID), true, null);
}
function qualtricsPopupCalendarMonthPicker(buttonElementID, destinationElementID, xoffset, yoffset)
{
	Qualtrics.QMonthPicker.displayCalendar($(destinationElementID), "yyyy-mm", $(buttonElementID), false);
}


function getPositioningExtras(width, height)
{
	if (!Qualtrics.Browser.Gecko || screen.width == null || screen.width == 'undefined' ||
			 screen.availLeft == null || screen.availLeft == 'undefined')
		return '';

	var left = (screen.width - width) / 2;
	if (screen.availLeft > 100 || screen.availLeft < 100)
		left += screen.availLeft;

	var top = (screen.height - height) / 2;
	if (screen.availTop > 50 || screen.availTop < 50)
		top += screen.availTop;

	return "left="+left+",top="+top+",";
}

/*******************

	FullScreen

********************/
var fullscreenCallBack = false;
var fullscreenOnComplete = false;
function assignFullScreen(el){
	el.onmousedown = function(){
		//this label is stupid so goodbye
		if($('FullScreenLabel')){
			new	Effect.Fade($('FullScreenLabel'),{
				duration:0.5,
				afterFinish:function(){
					$('FullScreenLabel').remove();
				}
			});
		}
		el.downFlag = true;
		var cn = Element.classNames(el);
		if(Element.hasClassName(el, 'FullScreenActivated')){
			cn.remove("FullScreenActivated");
		}else{
			cn.add("FullScreenActivated");
		}
	};
	el.onmouseup = function(){
		el.downFlag = false;
	};
	/* el.onmouseout
	*
	*	This is crazy complicated for a really stupid reason
	*	its best not to think about it. basically I want the icon to change when
	*	they mouse down for some feedback
	*	but it doesnt activate unless a full click happens so this function
	*	is to reset the icon if they do a mousedown but dont complete a full click
	*/
	el.onmouseout = function(){
		if(el.downFlag){
			if($(el).hasClassName("FullScreenActivated")){
				$(el).removeClassName( "FullScreenActivated");
			}else{
				$(el).addClassName( "FullScreenActivated");
			}
		}
		el.downFlag = false;
		$(el).removeClassName( "Over");
	};
	el.onclick= function(){
		toggleFullScreen(el);
		clearOverRegistry();
	};
}
function toggleFullScreen(el, options){
	if(!el)
	{
		el = $('FullScreen');
	}
	if(fullscreenCallBack)
	{
		/* if there is a custom fullscreen extended by the pagesection then run it*/
		fullscreenCallBack();
	}
	else
	{
		/* default */
		if(el.isFull)
		{
			if(options && options.fullScreenOnly)
			{
				return;
			}
			$(document.body).removeClassName('Full');
			$('center').setStyle({width:null});
			$('Toolbar').setStyle({width:null,marginRight:'0',left:'0'});
			el.isFull = false;
		}
		else
		{
			$(document.body).addClassName('Full');
			$('center').setStyle({width:'100%'});
			$('Toolbar').setStyle({width:'100%',marginRight:'0',left:'0'});
			el.isFull = true;
		}
		if(options && options.preventOnComplete)
		{
			return;
		}
		if(fullscreenOnComplete){
			/* if there is a custom oncomplete function extended by the pagesection then run it*/
			fullscreenOnComplete();
		}
	}
}

/**
*
* chunk
* takes an array and splits it up into chunks
* @param {Array} a - the array.
* @param {Array} s - the chunk size.
* @return {Array} the new array of chunks.
*/
function chunk(a, s)
{
		for(var x, i = 0, c = -1, l = a.length, n = []; i < l; i++)
				(x = i % s) ? n[c][x] = a[i] : n[++c] = [a[i]];
		return n;
}

function getScrollInfo()
{
	return QualtricsTools.getScrollInfo();
}
function updateScroll()
{
	window.scrollInfo = getScrollInfo();
}
function getPageCenter(offsetObject)
{
	//if you pass in an offsetObject it will adjust to give you the coordinates to center that object with left and top
	var offsetX = 0;
	var offsetY = 0;
	var scrollInfo = getScrollInfo();
	if(offsetObject)
	{
		var width = $(offsetObject).getWidth();
		var height = $(offsetObject).getHeight();
		offsetX = Math.round(width/2);
		offsetY = Math.round(height/2);
	}
	var s = getPageSize();
	var x = s[2];
	var y = s[3];
	return [Math.round(x/2)-offsetX+scrollInfo[0],Math.round(y/2)-offsetY+scrollInfo[1]];
}
function stripNewLines(text)
{
	return text.replace(/(\n\r|\n|\r)/g,' ');  //' //this quote comment is important.
}
//checks to make sure string passed in is of the right date format
function isValidDate(dateStr)
{
	//Currently only formats using default format (SQL DATE FORMAT)
	return QualtricsCPTools.regex.date.test(dateStr);

}
function isValidEmail(email)
{
	return QualtricsCPTools.regex.email.test(email);
}
function isValidURL(url)
{
	return QualtricsCPTools.regex.url.test(url);
}
function isValidGUID(str, prefix)
{
	if (prefix)
	{
		return QualtricsCPTools.regex.guid.test(str) && str.startsWith(prefix + '_');
	}
	else
		return QualtricsCPTools.regex.guid.test(str);
}


window.getMessage=Qualtrics.getMessage;
function benchmark(startd, end, label){
	var seconds = (end.getTime()-startd.getTime())/1000;
	var time = Math.round(seconds*100)/100;
	return (label+": "+time);
}


if (!Qualtrics.Messages)
	Qualtrics.Messages = {};

Object.extend(Qualtrics.Messages, {
	mouseDown: false,
	mouseDrag: false
});

Event.observe(window,'load', runOnLoads);
function runOnLoads()
{
	if($('MessageBox'))
	{
		Event.observe($('MessageBox'), 'mouseover', HoldMessageBox);
		Event.observe($('MessageBox'), 'mouseout', ReleaseMessageBox);
		Event.observe($('MessageBox'), 'click', function(evt)
			{
				if(evt)
				{
					var el = Event.element(evt);
					if(evt.ctrlKey)
					{
						QualtricsCPTools.hideDebugs = true;
					}
					if(el && el.tagName != 'INPUT' && el.tagName != 'BUTTON' && el.tagName != 'A'
							&& !Qualtrics.Messages.mouseDrag)
					{

						var ignoreClick = false;

						//check some parents to see if we should ignore the click
						var depth = 3;
						var depthEl = el;
						while (depth >= 0 && ignoreClick == false)
						{
							if (depthEl.getAttribute('ignoreMsgClick') == '1')
							{
								ignoreClick = true;
							}

							if (depthEl.parentNode)
							{
								depthEl = depthEl.parentNode;
								depth--;
							}
							else
							{
								depth = -1; //quit
							}
						}

						if (!ignoreClick)
							HideMessage(true);
					}
				}
			});

		//detect dragging so we can highlight text and copy it
		Event.observe($('MessageBox'), 'mousedown', function(evt)
			{
				Qualtrics.Messages.mouseDown = true; //the mouse has been depressed
				Qualtrics.Messages.mouseDrag = false; //we aren't draggin
			});
		Event.observe($('MessageBox'), 'mouseup', function(evt)
			{
				Qualtrics.Messages.mouseDown = false; //the mouse has been released
			});
		Event.observe($('MessageBox'), 'mousemove', function(evt)
			{
				if (Qualtrics.Messages.mouseDown)
					Qualtrics.Messages.mouseDrag = true;
			});

		$('MessageBox').oncontextmenu = function(){
			PermaMessageBox();
			return false;
		};
	}
	if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 7)
	{
		var days = 0;
		var today = new Date();
		var year = 2010;
		var eoy = new Date(year,11,31);
		var diff = Date.UTC(eoy.getYear(),eoy.getMonth(),eoy.getDate(),0,0,0) - Date.UTC(today.getYear(),today.getMonth(),today.getDate(),0,0,0);

		days = diff/1000/60/60/24;
		if (days < 0)
			days = 0;

		if($('SystemMessageArea'))
		{
			var browserWarning;
			$('SystemMessageArea').appendChild(QualtricsCPTools.roundy(
				QBuilder('div', null, [
					//QBuilder('div',{className:'Close', clickcallback:'QualtricsCPTools.fadeElement', p1:'BrowserWarning'}),
					browserWarning = QBuilder('div',{className: 'message'}),
					QBuilder('br'),
					//QBuilder('div',{className:'BrowserCountdown'},["Support for Internet Explorer 6 ends in ",QBuilder('span',{className:'days'},[days]), " days"]),
					getMessage('SiteWide','BrowserUpgrade'),
					QBuilder('ul',null,[
						QBuilder('li',null,[
							QBuilder('a', {href:'http://www.getfirefox.com', className:'Firefox', target:'_blank'}, [QBuilder('strong',{className:'icon'} ),QBuilder('strong',null, 'Firefox'), QBuilder('span',null, ' (Free)')])
						]),
						QBuilder('li',null,[
							QBuilder('a', {href:'http://www.google.com/chrome', className:'Chrome', target:'_blank'}, [QBuilder('strong',{className:'icon'} ),QBuilder('strong',null, 'Chrome'), QBuilder('span',null, ' (Free)')])
						]),
						QBuilder('li',null,[
							QBuilder('a', {href:'http://www.microsoft.com/windows/Internet-explorer/default.aspx', className:'IE8', target:'_blank'}, [QBuilder('strong',{className:'icon'} ),QBuilder('strong',null, 'Internet Explorer 8'), QBuilder('span',null, ' (Free)')])
						]),
						QBuilder('li',null,[
							QBuilder('a', {href:'http://code.google.com/chrome/chromeframe/', className:'IE8', target:'_blank'}, [QBuilder('strong',{className:'icon'} ),QBuilder('strong',null, 'Chrome Frame Plugin'), QBuilder('span',null, ' (Free)')])
						])

					]),
					QBuilder('div',{className:'clear'})
				]),{
				className:'BrowserWarning',
				id:'BrowserWarning'
			}));
			browserWarning.innerHTML = getMessage('SiteWide','BrowserWarning');
		}

	}
}

Qualtrics.Inputs = {
	/**
	* Qualtrics.Inputs.autoHideFocus
	*/
	autoHideFocus:function(evt)
	{
		if(!evt) evt = window.event;
		var el = Event.element(evt);
		Qualtrics.Inputs.autoHideFade(el);
	},
	autoHideClick:function(el)
	{
		Qualtrics.Inputs.autoHideFade(el);
	},
	autoHideFade:function(el)
	{
		var forEl = $(el.getAttribute('autohide'));
		if(forEl && !forEl.autofaded)
		{
			forEl.autofaded = true;
			$(forEl).addClassName('Fade');
		}
		if(!el.onblur)
		{
			el.onblur = Qualtrics.globalBlurHandler;
		}
		Qualtrics.Inputs.autoHide(el);
	},
	autoHide:function(el)
	{
		var forEl = $(el.getAttribute('autohide'));
		if(forEl && $(forEl))
		{
			if(el.value != '' && !forEl.autohidden)
			{
				forEl.autohidden = true;
				$(forEl).hide();
			}
		}
	},
	autoShow:function(el)
	{
		if(el.getAttribute('autohide'))
		{
			var forEl = $(el.getAttribute('autohide'));
			if(forEl)
			{
				if(el.value == '' && forEl.autohidden)
				{
					forEl.autohidden = false;
					$(forEl).show();
				}
			}
		}
	},
	autoHideBlur:function(el)
	{
		if(el.getAttribute('autohide'))
		{
			//unfade a label element if they blur the input
			var forEl = $(el.getAttribute('autohide'));
			if(forEl)
			{
				if(forEl.autofaded)//this is more efficient than the method that removeClassName uses
				{
					forEl.autofaded = false;
					$(forEl).removeClassName('Fade');
				}
				Qualtrics.Inputs.autoShow(el);
			}
		}
	},
	/**
	* Qualtrics.Inputs.checkForPrepopulatedValue
	*/
	checkForPrepopulatedValue:function(el)
	{
		Qualtrics.Inputs.autoHideFade(el);
	},
	/**
	* Qualtrics.Inputs.watchInputsForAutoComplete
	* Starts the interval that hides the prompt text specified by the autohide attribute if the text changes
	*/
	watchInputsForAutoComplete:function(var_args)
	{
		var args = arguments;
		setInterval(function(){Qualtrics.Inputs.checkInputsForAutoComplete.apply(this,args)}, 100);
	},
	/**
	* Qualtrics.Inputs.checkInputsForAutoComplete
	* Hides the prompt text specified by the autohide attribute if the text changes
	*/
	checkInputsForAutoComplete:function(var_args)
	{
		for(var i=0,len=arguments.length;i<len; ++i)
		{
			Qualtrics.Inputs.autoHide(arguments[i]);
		}
	},
	autoHideKeyUp:function(el, evt)
	{
		if(el.getAttribute('autohide')){
			var forEl = $(el.getAttribute('autohide'));
			if(el.value == '')
			{
				if(evt && evt.keyCode == Event.KEY_DELETE || evt.keyCode == Event.KEY_BACKSPACE)
				{
					if(forEl)
					{
						forEl.autohidden = false;
						$(forEl).show();
					}
				}
			}
			else
			{
				forEl.autohidden = true;
				$(forEl).hide();
			}
		}
	},
	autoHideKeyDown:function(el, evt)
	{
		if(el.getAttribute('autohide'))
		{
			//instantly removes the prompt as soon as they click
			var forEl = $(el.getAttribute('autohide'));
			if(forEl)
			{
				forEl.autohidden = true;
				$(forEl).hide();
			}
			if(el.value == '')
			{
				if(evt && evt.keyCode == Event.KEY_TAB)
				{
					forEl.autohidden = false;
					$(forEl).show();
				}
			}
		}
	}
};

/**
* blurs dont bubble
* so you need to manually assign this to the blur event on everything you want to use blurcallbacks with.
* the advantage you get is that you dont have to make any closures to call a function with complex params
* example:
* 	input.blurcallback = 'Qualtrics.someFunction(dog, cat, $evt)'
* 	input.onblur = Qualtrics.globalBlurHandler;
*
* NOTE: you could get the same results with currying so this is really kind of pointless, unless you really need to use the custom $evt param that callbacks provide.
*/
Qualtrics.globalBlurHandler = function(evt)
{
	evt = evt || window.event;
	var clickedEl = Event.element(evt);
	Qualtrics.Inputs.autoHideBlur(clickedEl);
	var callback = clickedEl.getAttribute('blurcallback');
	Qualtrics.Event.baseDistributerReader(evt ,clickedEl, 'blurcallback');
};
Qualtrics.globalContextMenuHandler = function(evt)
{
	//they might be about to do a paste into an autoclearing textbox.
	//This will really screw things up badly, so lets preemptively clear it.
	evt = evt || window.event;
	var el = Event.element(evt);
	if(el.nodeName == 'INPUT')
	{
		if(el.getAttribute('autoclear') && el.value == el.getAttribute('autoclear')){
			 el.value = '';
			 $(el).removeClassName('AutoClearMessage');
		}
		else if(el.getAttribute('autohide'))
		{
			//unfade a label element if they blur the input
			if(el.getAttribute('autohide')){
				var forEl = $(el.getAttribute('autohide'));
				if(forEl)
				{
					$(forEl).hide();
				}
			}
		}

	}
};

//Set up autocomplete fixes for when the user wants to paste something in without using the keyboard.
Event.observe(document, 'contextmenu', Qualtrics.globalContextMenuHandler);
/**
* These are run whenever the user tries to activate or deactivate the survey without permission
*/
if (!Qualtrics.showPermissionError_ActivateSurvey)
{
	Qualtrics.showPermissionError_ActivateSurvey = function()
	{
		alert(getMessage('ErrorCodes', 'ESEC35'));
	};
}
Qualtrics.showPermissionError_DeactivateSurvey = function()
{
	alert(getMessage('ErrorCodes', 'ESEC26'));
};
Qualtrics.showPermissionError_ActivateSurvey_XDataCenter = function()
{
	alert(getMessage('ErrorCodes', 'ESEC35'));
};
Qualtrics.showPermissionError_DeactivateSurvey_XDataCenter = function()
{
	alert(getMessage('ErrorCodes', 'ESEC26'));
};

var QualtricsCPTools = {
	cachedFixedPosSupport:null,
	/** An object that contains a whole bunch of usefull regex */
	regex: {
		/** Email regex */
		email: /^([a-zA-Z0-9\'_\+\.\-\&\/])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,
		url: /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/,
		guid: /^[0-9a-zA-Z]{1,4}_[0-9a-zA-Z]{11,15}$/,
		date: /^\d{4}(\-|\/|\.)\d{1,2}(\-|\/|\.)\d{1,2}$/,
		number: /^[0-9]+$/,
		SSOUserName: /.+#.+/
	},
	/** QualtricsCPTools:showTip Shows a yellow tip box.
	 * @param string The template we want to show.
	 * @param object The callbacks to run. The current callbacks are: onComplete.
	 */
		ttOn: function(evt, el, sn, tag, ul, uID) {
				translationTip.on(el, evt, sn, tag, ul, uID);
		},
	showTip: function(template, options){
		var src = URLTools.getAjaxURL('ShowTip', undefined, {t:template});

		var windowOptions = {
			id: 'tipWindow',
			width:(options.width||400)+'px',
			padding:0
		};

		if (options.onClose)
		{
			windowOptions.onClose = options.onClose;
		}
		if (options.closeButton === false)
		{
			windowOptions.closeButton = false;
		}

		var tipWindow = new Q_Window(windowOptions);
		var tip = QBuilder('div',{className:'HelpTip',id:'ShowTip'});
		new Ajax.Updater(tip, src,
			{
				evalScripts:true,
				parameters:options.parameters||null,
				onComplete:function()
				{
					if (options.onComplete)
					{
						try
						{
							Qualtrics.Event.execute.defer(options.onComplete);
						}
						catch(e)
						{
							console.error(e);
						}
					}
					tipWindow.center();
				},
				asynchronous: options.asynchronous === undefined ? true : options.asynchronous
			}
		);
		tipWindow.setContent(tip);

	},
	disableButton:function(id)
	{
		var button = $(id);
		if(button)
		{
			$(button).addClassName('disabled');
			if (button.hasAttribute('clickcallback'))
			{
				button.setAttribute('pendingcallback', button.getAttribute('clickcallback'));
				button.removeAttribute('clickcallback');
			}
		}
	},
	enableButton:function(id)
	{
		var button = $(id);
		button.disabled = false;
		if(button)
		{
			$(button).removeClassName('disabled');
			if (button.hasAttribute('pendingcallback'))
			{
				button.setAttribute('clickcallback', button.getAttribute('pendingcallback'));
				button.removeAttribute('pendingcallback');
			}
		}
	},
	/**
	 * Closes a tool tip.
	 */
	closeTip: function(){
		Q_Window.closeWindow('tipWindow');
	},
	feedback:function(url)
	{
		var popup = new Q_Window(
			{
				id: 'Feedback',
				title: 'Support & Feedback',
				width:'650px',
				height:'650px',
				closeButton:true,
				url:url,
				iframescrolling:true
			}
		);
		var content = QBuilder('div', {}, [

		]);
	},
	/** QualtricsCPTools.showAlertDialog Shows an alert dialog.
	 * @param options The confirmation box options
	 * 		title: the string that should appear in the title bar
	 * 		message: the text of the main delete message
	 * 		messageDivId: the id given to the message element
	 * 		okCallBack: The callback when they press the ok button
	 * 		okButtonClassName: a string with any class names to add to the ok button
	 * 		showCloseButton: boolean for whether to show the close button or not
	 */
	showAlertDialog: function(options)
	{
		var zIndex = 2020000;
		if (options.zIndex)
		{
			//prevent any other window from showing up
			zIndex = options.zIndex;
		}

		var okText = 'OK';
		if (options.okText)
			okText = options.okText;

		var showButton = true;
		if(options.showCloseButton === false)
			showButton = false;

		var icon = 'check';
		if (options.icon)
			icon = options.icon;

		var button = QBuilder('a', {className: 'qbutton'}, okText);

		if(options.okButtonClassName)
			button.addClassName(options.okButtonClassName);

		var buttons = (options.buttons)?options.buttons:[];

		if (icon && icon != 'none' && options.buttons && !buttons[0].icon)
			buttons[0]['icon'] = icon;

		var win = new Q_Window({
				id: 'alertDialog',
				className: (options.className || '') + ' alertDialog',
				width:'auto',
				title: options.title || getMessage('SiteWide', 'Alert'),
				zIndex:zIndex,
				buttons: buttons,
				closeButton: showButton
			});

		if (!options.okCallBack)
		{
			options.okCallBack = function() {
				win.close();
			};
		}
		else
		{
			var f = options.okCallBack;
			options.okCallBack = function()
			{
				try{
					Qualtrics.Event.execute(f);
				}
				catch(e)
				{
					console.error('callback function error:'+e);
				}
				win.close();
			};
		}

		if(buttons.length == 0)
		{
			Event.observe(button, 'click', options.okCallBack);
			win.rightFooterArea.appendChild(button);
		}

		var content = QBuilder('table',{},[
				QBuilder('tbody', null, [
					QBuilder('tr', null, [
						QBuilder('th', null, [QBuilder('div',{className:'warningGraphic'})]),
						QBuilder('td', null, [
							QBuilder('div',{className:'message', id:options.messageDivId || 'message'}, [options.message])
						])
					])
				])
			]);

		win.setContent(content);
		win.showCenter();
	},
	/** QualtricsCPTools.showConfirmDialog Shows a generic confirmation dialog.
	 * @param options The confirmation box options
	 * 		title: the string that should appear in the title bar
	 * 		message: the text of the main delete message
	 * 		okCallBack: The callback when they press the ok button - can be a function or a dot-syntax string
	 *		okCallBackParams: Parameters to pass to the okCallBack - must be an array
	 *		cancelCallBack: the callback when they press the cancel button - can be a function or dot-syntax string
	 *		cancelCallBackParams: parameters to pass to the cancelCallBack - must be an array
	 */
	showConfirmDialog: function(opts)
	{
		var callback = function(action, params) {
			this.destroy();
			if (action)
				Qualtrics.Event.execute(action, params);
		};

		//return the window if we need a reference to it
		return new Q_Window({
			id: 'alertDialog',
			className: (opts.className || '') + ' alertDialog',
			width:opts.width || 'auto',
			title: opts.title,
			buttons: [
				'cancel:cancelCallBack|' + (opts.cancelText || getMessage('SiteWide', 'No')),
				'ok:okCallBack|' + ( opts.okText || getMessage('SiteWide','Yes') )
			],
			okButtonHelper:callback.curry(opts.okCallBack || '', opts.okCallBackParams || []),
			cancelButtonHelper:callback.curry(opts.cancelCallBack || '', opts.cancelCallBackParams || []),
			content:QBuilder('table',{},[
				QBuilder('tbody', null, [
					QBuilder('tr', null, [
						QBuilder('th', null, [QBuilder('div',{className:'warningGraphic'})]),
						QBuilder('td', null, [
							QBuilder('div',{className:'message'}, [opts.message || ''])
						])
					])
				])
			])
		});
	},
	/**
	 * Shows a simple Prompt dialog
	 * @param (Object) opts The prompt options
	 *		title: The window title - none if ommitted
	 *		prompt: The prompt message
	 *		value: The default input value
	 *		okText: Replacement text for the OK button
	 *		cancelText: Replacement text for the cancel button
	 *		okCallBack: the ok call back function - must be a dot syntax string
	 **/
	showPromptDialog:function(opts)
	{
		opts = opts || {};
		var input = QBuilder('input',{id:'PromptDialogInput', value:opts.value || '', keyentercallback:'Q_Window.okButtonHelper('+(opts.okCallBack || '')+')', type:'text'});
		var window = new Q_Window({
			className:'PromptDialog BigFields',
			width:'auto',
			title:opts.title, //This is ok being undefined
			content:QBuilder('div',{},[
				QBuilder('label',{},opts.prompt || ''),
				input
			]),
			okButtonHelper:function(action) {
				var val = $F($(this.content).down('input'));
				this.destroy();
				QualtricsCPTools.executeDotSyntax(action,null,null,null,{'$val':val,'$value':val});
			},
			buttons:[
				'cancel|' + (opts.cancelText || ''),
				'ok:' + ( opts.okCallBack || '' ) + '|' + ( opts.okText || '' )
			]
		});
		if (opts.value)
		{
			//select everything
			QualtricsCPTools.select(input, 0, opts.value.length);
		}
		else
		{
			//just focus the input field
			$(input).focus();
		}
	},
	showUpgradeDialog:function(contentType)
	{
		var win = new Q_Window({
			id:'UpgradeAccountPopup',
			width:'auto',
			height:'auto',
			title:getMessage('Registration','UpgradeToUseFeature'),
			zIndex:2020000,
			closeButton:true
		});

		new Ajax.Request(URLTools.getAjaxURL('getBrandAdminContactInfo'),{
			onComplete:function(brandAdminTransport)
			{
				new Ajax.Request(URLTools.getAjaxURL('GetUpgradePopupContent'),{
					parameters:{
						content:contentType
					},
					onComplete:function(transport){
						var content = "";
						var contactHeader = null;
						var brandAdminText = JSON.parse(brandAdminTransport.responseText);
						if (brandAdminText.length > 0)
						{
							var contactChildren = [QBuilder('h3',{},getMessage('ErrorCodes','ESEC94')),
								QBuilder('br',{})];
							for (var i = 0; i < brandAdminText.length; i++)
							{
								contactChildren.push(QBuilder('h3',{},brandAdminText[i]));
							}
							contactHeader = QBuilder('div',{className:'contactInfo'},contactChildren);
						}
						if(transport.responseText == "" || contactHeader != null){
							var message = 'ESEC69';
							if (contentType === 'QuestionsPerSurvey') {
								message = 'ESEC99';
							}
							content = QBuilder('div',{className:'main'},[
								QBuilder('div',{className:'content'},[
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'whole'},[
											QBuilder('h3',{},getMessage('ErrorCodes',message)),
											contactHeader
										])
									]),
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'whole'},[
											QBuilder('a',{className:'ok button',clickcallback:'Q_Window.closeWindow',p1:'UpgradeAccountPopup'},getMessage('SiteWide','OK'))
										])
									])
								])
							]);
						}
						else
						{
							var json = transport.responseText.evalJSON();
							if(json["Feature"])
							{
								contentType = json["Feature"];
							}
							var benefits = QBuilder('ul');
							for(var i=0, ilen=json.Benefits.Benefit.length; i<ilen;i++)
							{
								benefits.appendChild(QBuilder('li',{},json.Benefits.Benefit[i]));
							}

							content = QBuilder('div',{className:'main'},[
								QBuilder('div',{className:'content'},[
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'whole'},[
											QBuilder('h2',{},json.Headline)
										])
									]),
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'oneThird'},[
											QBuilder('img',{src:"/WRQualtricsShared/UpgradePopup/Images/"+json.Image})
										]),
										QBuilder('div',{className:'twoThirds'},[
											QBuilder('h3',{},'Benefits:'),
											benefits
										])
									]),
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'whole'},[
											QBuilder('h3',{},'Real World Application:'),
											QBuilder('p',{},json.RealWorldApplication)
										])
									]),
									QBuilder('div',{className:'clear'},[
										QBuilder('div',{className:'half'},[
											QBuilder('a',{className:'upgrade button',clickcallback:'QualtricsCPTools.showUpgradeForm', p1:contentType, p2:'UpgradeAccountPopup'},'Upgrade My Account')
										]),
										QBuilder('div',{className:'half'},[
											QBuilder('a',{className:'noThanks button',clickcallback:'Q_Window.closeWindow',p1:'UpgradeAccountPopup'},'No Thanks')
										])
									])
								])
							]);
						}
						win.setContent(content);
						win.center();
					}
				});
			}
		});
	},
	showUpgradeForm:function(product,windowId)
	{
		var surveyLink = 'https://survey.qualtrics.com/SE/?SID=SV_0cheXlKJ5WZq4Pa';
		if (windowId)
		{
			win = Q_Window.closeWindow(windowId);
		}
		if(!product)
		{
			product = 'Unknown';
		}
		var url=surveyLink
				+'&Name='+Qualtrics.User['name']
				+'&Email='+Qualtrics.User.email
				+'&userId='+Qualtrics.User.userId
				+'&product='+product
				+'&Q_lang='+Qualtrics.User.language;

		url = encodeURI(url);

		var win=new Q_Window(
		{
			id: 'UpgradeAccountSurvey',
			width: '560px',
			height: '500px',
			url:url,
			zIndex:2020000,
			closeButton:true
		});
	},
	showHelpMenu:function(qualtricsLink, wikiLink, helpLink)
	{
		return QMenu.showMenu(
			{
				items:[{
						display:getMessage('SiteWide', 'QualtricsUniversity'),
						params:{
							href:wikiLink+'/'+helpLink,
							target:'_blank'
						}
					}/*,
					{
						display:getMessage('SiteWide', 'QualtricsUserCommunity'),
						params:{
							href:qualtricsLink+'/forum',
							target:'_blank'
						}
					}*/]
			},
			$('HelpButton')
		);
	},
	showActivateConfirmation: function(options)
	{
		options.activate = true;
		this.showDeleteConfirmation(options);
	},
	/** QualtricsCPTools:showDeleteConfirmation Shows a yellow tip box.
	 * @param options The confirmation box options
	 * 		title: the string that should appear in the title bar
	 * 		strong: whether the confirmation is strong (Requires text entry)
	 * 		deleteButtonText: the text on the delete button
	 * 		deleteMessage: the text of the main delete message
	 *    disable: optional - if set, things will act like 'Disable'
	 */
	showDeleteConfirmation:function(options)
	{
		if (typeof(options) == "string")
		{
			options = options.evalJSON();
		}
		if (!(options instanceof Object))
		{
			options = {};
		}
		var title = 'Delete';
		var strongConfirm = false;
		var secondConfirm = false;
		var deleteButtonText = getMessage('SiteWide', 'Delete');
		var deleteMessage = getMessage('SiteWide','DeleteConfirmMessage');
		var confirmDeleteText = getMessage('SiteWide','ConfirmDelete').toLowerCase();
		var deleteCallBackParameters = {};
		var confirmAction = null;
		var windowZIndex = options.windowZIndex;
		var deletingMessage = getMessage('Deleting');
		var activate = false;

		if (options.disable)
		{
			title = 'Disable';
			deleteMessage = getMessage('SiteWide','DisableConfirmMessage');
			confirmDeleteText = getMessage('SiteWide','ConfirmDisable').toLowerCase();
			deletingMessage = getMessage('Disabling');
			deleteButtonText = getMessage('ServerAdminSection','Disable');
		}

		if (options.title)
		{
			title = options.title;
		}
		if (options.strong)
		{
			strongConfirm = true;
		}
		if (options.secondConfirm)
		{
			secondConfirm = true;
		}
		if (options.deleteButtonText)
		{
			deleteButtonText = options.deleteButtonText;
		}
		if (options.deleteMessage)
		{
			deleteMessage = options.deleteMessage;
		}
		if (options.deletingMessage)
		{
			deletingMessage = options.deletingMessage;
		}
		if (options.deleteCallBackParameters)
		{
			deleteCallBackParameters = options.deleteCallBackParameters;
		}
		if (options.confirmAction)
		{
			confirmAction = options.confirmAction;
		}
		if (options.confirmDeleteText)
		{
			confirmDeleteText = options.confirmDeleteText;
		}
		if(options.activate)
		{
			activate = options.activate;
		}
		this.advancedOptions = options.advancedOptions;

		this.deleteConfirmationCompleteOnEnter = function(e)
		{
			if (!e) e = window.event;

			if (e.keyCode == Event.KEY_RETURN)
			{
				QualtricsCPTools.deleteConfirmationComplete(e);
				Event.stop(e);
			}
		};
		this.deleteConfirmationCancel = function()
		{
			Q_Window.closeAllWindows('deleteConfirmation');
		};

		this.deleteConfirmationComplete = function(e)
		{
			var skipStrong = false;
			var skipSecond = false;
			if (e.shiftKey && (e.ctrlKey || e.metaKey))
			{
				skipStrong = true;
				skipSecond = true;
			}
			if (deleteCallBackParameters.strong)
			{
				if (skipStrong)
				{
					//shortcut for clicking through strong confirms
					Event.stop(e);
				}
				else
				{
					//check for confirmation, you should also check in the ajax call
					var confirmed = $('confirmationInput').value.toLowerCase();
					var confirmCloseText = getMessage('SiteWide','ConfirmClose').toLowerCase();

					if (confirmAction && confirmAction == 'Deactivate')
					{

						if (confirmed != confirmCloseText && confirmed != '"'+confirmCloseText+'"')
						{
							QualtricsCPTools.showAlertDialog({message:getMessage('SiteWide','MustConfirmClose')});
							return false;
						}
					}
					else
					{
						if (confirmed != confirmDeleteText.toLowerCase() && confirmed != '"' + confirmDeleteText.toLowerCase() + '"')
						{
							QualtricsCPTools.showAlertDialog({message:getMessage('SiteWide','MustConfirmDeletion')});
							return false;
						}
					}
				}

				if ($('CloseSessions'))
				{
					deleteCallBackParameters.ajaxParameters['CloseSessions'] = $('CloseSessions').checked;
				}


				if (deleteCallBackParameters.secondConfirm && !skipSecond)
				{
					var newOptions = deleteCallBackParameters.options;
					newOptions['strong'] = false;
					newOptions['deleteMessage'] = deleteCallBackParameters.options.confirmMessage;

					this.confirmedOptions = {};

					for (var s in this.advancedOptions)
					{
						if($('advancedOptionCheckbox'+s).checked)
						{
							newOptions['deleteMessage'] += '<br/><br/> - ' + this.advancedOptions[s].label;
							this.confirmedOptions[s] = true;
						}
					}

					newOptions.hideAdvancedOptions = true;

					Q_Window.closeAllWindows('deleteConfirmation');
					this.showDeleteConfirmation(newOptions);
					return false;
				}
			}
			if(deleteCallBackParameters.ajaxAction)
			{
				//Ajax Action
				var action = deleteCallBackParameters.ajaxAction;
				var parametersForAjax = deleteCallBackParameters.ajaxParameters;

				if (deleteCallBackParameters.longAjax)
					var longAjax = true;
				else
					var longAjax = false;

				if (this.advancedOptions != null)
				{
					for (var s in this.advancedOptions)
					{
						if((this.confirmedOptions && this.confirmedOptions[s]) || ($('advancedOptionCheckbox'+s) && $('advancedOptionCheckbox'+s).checked))
						{
							parametersForAjax[s] = 'true';
						}
					}
				}
				if(options.optionalInput)
				{
					if($(options.optionalInputName) && $(options.optionalInputName).checked)
					{
						parametersForAjax[options.optionalInputName] = 'true';
					}
				}
				if (parametersForAjax != '')
				{
					var url;
					if (longAjax)
						url = URLTools.getLongAjaxURL(action);
					else
						url = URLTools.getAjaxURL(action);

					new Ajax.Request(url,{
						parameters:parametersForAjax,
						onComplete:function(transport){
							Q_Window.closeAllWindows('deleteConfirmation');
							if (confirmAction && confirmAction == 'Deactivate')
							{
								if(!parametersForAjax.admin || parametersForAjax.admin != 1)
								{
									if(window.MySurveys && parametersForAjax.el)
									{
										MySurveys.uncheckElement(parametersForAjax.el, parametersForAjax.SID, parametersForAjax.svd);
									}
								}
							}
							if (deleteCallBackParameters.ajaxOnComplete)
							{
								QualtricsCPTools.executeDotSyntax(deleteCallBackParameters.ajaxOnComplete, null, null, null, {'$transport':transport});
							}
						},
						onSuccess:function(transport){
							Q_Window.closeAllWindows('deleteConfirmation');
							if (confirmAction && confirmAction == 'Deactivate')
							{
								if(!parametersForAjax.admin || parametersForAjax.admin != 1)
								{
									if(window.MySurveys && parametersForAjax.el)
									{
										MySurveys.uncheckElement(parametersForAjax.el, parametersForAjax.SID, parametersForAjax.svd);
									}
								}
							}
							if (deleteCallBackParameters.ajaxOnSuccess)
							{
								QualtricsCPTools.executeDotSyntax(deleteCallBackParameters.ajaxOnSuccess, null, null, null, {'$transport':transport});
							}
						}
					});
				}
			}
			if(deleteCallBackParameters.javascriptAction)
			{
				//Javascript Action
				var params = deleteCallBackParameters.javascriptParameters || [];

				if(!Object.isArray(params))
					params = [params];

				var instanceid = deleteCallBackParameters.javascriptInstanceId || null;
				QualtricsCPTools.executeDotSyntax(deleteCallBackParameters.javascriptAction, instanceid, null, null, null, params);
				Q_Window.closeAllWindows('deleteConfirmation');
				//javascript Action is immediate
				return true;
			}
			if(deleteCallBackParameters.javascriptFunction)
			{
				//Javascript function
				deleteCallBackParameters.javascriptFunction();
				Q_Window.closeAllWindows('deleteConfirmation');
				//javascript Action is immediate
				return true;
			}

			if (confirmAction && confirmAction == 'Deactivate')
			{
				deletingMessage = getMessage('Deactivating');
			}
			else if (options.deletingMessage)
			{
				deletingMessage = options.deletingMessage;
			}
			var button = $('ConfirmDeleteButton');
			if (button)
			{
				$(button).setAttribute('clickcallback','');
				$(button).addClassName('Disabled');
				$('ConfirmDeleteButton').innerHTML = deletingMessage;
			}
		};

		var confirmTextInput = QBuilder('input',{autocomplete: 'off', type:'text', id:'confirmationInput',name:'confirmationInput', className:'TextBox'});
		Event.observe(confirmTextInput, 'keydown', QualtricsCPTools.deleteConfirmationCompleteOnEnter);
		deleteCallBackParameters.strong = strongConfirm;
		deleteCallBackParameters.secondConfirm = secondConfirm;
		deleteCallBackParameters.options = options;
		if (confirmAction && confirmAction == 'Deactivate')
		{
			var confirmationForm = QBuilder('div',{id:'deleteConfirmationForm'},[
					QBuilder('div',{className:'confirmMessage'}, [getMessage('SiteWide', 'MustEnterClose', getMessage('SiteWide','ConfirmClose'))]),
					confirmTextInput,
					QBuilder('table',{className:'PopUpWarningTable'},[
										QBuilder('tbody', null, [
							QBuilder('tr',{},[
								QBuilder('td',{},[
									QBuilder('input',{type:'checkbox', name:'CloseSessions', id:'CloseSessions', value:'true', checked:'true', className:'checkbox'})
							]),
							QBuilder('td',{},[
								QBuilder('label',{className:'PopUpWarningText', htmlFor:'CloseSessions'},[getMessage('MySurveysSection', 'CloseSessions')])
							])
						])
					])
				])
			]);
		}
		else
		{
			var confirmMessage = getMessage('SiteWide', 'MustEnterDelete', confirmDeleteText);
			if(options && options.strongConfirmPrompt)
			{
				confirmMessage = options.strongConfirmPrompt;
			}
			confirmationForm = QBuilder('div',{id:'deleteConfirmationForm'},[
				QBuilder('div',{className:'confirmMessage'}, confirmMessage),
				confirmTextInput
			]);
		}
		var strongConfirmHeading = QBuilder('div',{className:'deleteHeader'},getMessage('SiteWide', 'WarningCaption'));
		var className = options.className || '';
		var contentClass = 'deleteConfirmationContainer '+(strongConfirm?'strong':'') + ' ' + className;

		var contentChildren = [
			QBuilder('div',{className:'deleteWarningGraphic'}),
			QBuilder('div',{className:'rightContainer'},[
				(strongConfirm)?strongConfirmHeading:'',
				QBuilder('div',{className:'deleteMessage', id:'deleteMessage'},''),
				(strongConfirm)?confirmationForm:''
			]),
			QBuilder('div',{className:'clear'})
		];

		if (this.advancedOptions != null && !options.hideAdvancedOptions)
		{
			var checkboxes = [];
			for(var advOption in this.advancedOptions) {
				var label = this.advancedOptions[advOption].label;
				var value = this.advancedOptions[advOption].value;
				if (this.advancedOptions[advOption].newLine)
				{
					checkboxes.push(QBuilder('br'));
				}
				checkboxes.push(QBuilder('input',{className:'checkbox',id:'advancedOptionCheckbox'+advOption,type:'checkbox',checked:value}));
				checkboxes.push(QBuilder('label',{'for':'advancedOptionCheckbox'+advOption},label));
			}
			contentChildren.push(QBuilder('br',{}));
			contentChildren.push(QBuilder('div',{className:'rightContainer'},[
				QBuilder('div',{className:'advancedOptions'},checkboxes)
			]));
		}
		if(options.optionalInput)
		{
			var optionalInput = [];
			optionalInput.push(QBuilder('input', {className:'checkbox', type:'checkbox', id:options.optionalInputName, name:options.optionalInputName}));
			optionalInput.push(QBuilder('label', {'for':options.optionalInputName}, options.optionalInputLabel));
			contentChildren.push(QBuilder('br',{}));
			contentChildren.push( QBuilder('div',{className:'deleteConfirmation'},optionalInput));
		}

		var content = QBuilder('div',{className:contentClass},contentChildren);

		//Make sure there is no delete confirm already on screen (this will happen if user double clicks)
		var alreadyActiveConfirm = Q_Window.getInstanceByWindowName('deleteConfirmation');
		if (alreadyActiveConfirm)
		{
			console.error('Already a delete confirm active. Cannot have more than one. Aborting...');
			return;
		}

		var buttonOptions = null;
		if(activate)
		{
			buttonOptions = [
					{icon:'', text:getMessage('SiteWide','Cancel'), click:'QualtricsCPTools.deleteConfirmationCancel', className:'neutral'},
					{icon:'check', text:deleteButtonText, click:'QualtricsCPTools.deleteConfirmationComplete',p1:'$evt',  className:'positive', id:'ConfirmDeleteButton'}
				];
		}
		else
		{
			buttonOptions = [
					{icon:'', text:getMessage('SiteWide','Cancel'), click:'QualtricsCPTools.deleteConfirmationCancel', className:'neutral'},
					{icon:'cancel', text:deleteButtonText, click:'QualtricsCPTools.deleteConfirmationComplete',p1:'$evt',  className:'negative', id:'ConfirmDeleteButton'}
				];
		}

		var deleteConfirmation = new Q_Window(
		{
			id: 'deleteConfirmation',
			className: (options.className || '') + ' deleteConfirmation',
			title: title,
			width:'auto',
			height:'auto',
			zIndex:windowZIndex,
			closeButton:true,
			buttons:buttonOptions
		});
		deleteConfirmation.setContent(content);
		if (typeof deleteMessage == 'string')
			$('deleteMessage').innerHTML = deleteMessage;
		else
			$('deleteMessage').appendChild(deleteMessage);
		deleteConfirmation.center();

		if (options.strong && $(confirmTextInput))
			$(confirmTextInput).focus();

	},
	/**
	* QualtricsCPTools.createNewId - an alias to QualtricsTools.createNewId
	* Creates a guid
	* @deprecated - use QualtricsTools.createNewId instead
	*/
	createNewId:QualtricsTools.createNewId,
	/**
	* QualtricsCPTools.getInstanceHelper - an alias to QualtricsTools.getInstanceHelper
	* @deprecated - use QualtricsTools.getInstanceHelper instead
	*/
	getInstanceHelper:QualtricsTools.getInstanceHelper,
	getPageSize:function()
	{
		return getPageSize();
	},
	/**
	* QualtricsCPTools.select
	* selects a portion of a text input.
	* @param {Node} el - the text input you want to select.
	* @param {Number} start - the start position.
	* @param {Number} end - the end position.
	*/
	select:function(el, start, end)
	{
		$(el).focus();
		if (document.selection)
		{
			var completeEntry = el.createTextRange();
			completeEntry.findText(el.value.substring(start,end));
			completeEntry.select();
		}
		else{
			el.setSelectionRange(start,end);
		}
	},
	/**
	* QualtricsCPTools.focusInput
	* does a better job at focusing in ie6
	* @deprecated - use QualtricsTools.focusInput instead
	* @param {HTMLInputNode | HTMLTextareaNode} - the node you want to focus
	*/
	focusInput:function(el, opt_pos)
	{
		return QualtricsTools.focusInput(el, opt_pos);
	},
	Overlay:{
		hasOverlay:false,
		suspend:false,
		ShowOverlay:function(options){
			if(!QualtricsCPTools.Overlay.suspend)
			{
				return new Q_Overlay(options);
			}
		},
		HideOverlay:function(hideWindow, options){
			if(!QualtricsCPTools.Overlay.suspend)
			{
				Q_Overlay.removeAll();
			}
		}
	},
	/**
	* QualtricsCPTools.roundy
	* makes a box with rounded corners
	* @param {DomNode} insideDiv - what you want inside the box.
	* @param {Object} options - options for the roundy.
	* @return {DomNode} - the rounded div element.
	*/
	roundy:function(insideDiv, options)
	{
		if(!options) options = {};
		options = Object.extend({id:'', 'className':'', 'color':'black', 'hasClose':false, rootType:'div'}, options);
		return QBuilder(options.rootType, {id:options.id, className:'RoundedCorners Roundy '+options.className},[
			QBuilder('div', {className:'TopRight'},[
				QBuilder('div', {className:'BottomLeft'},[
					QBuilder('div', {className:'BottomRight'},[
						insideDiv
					])
				])
			])
		]);
	},
	fadeElement:function(id)
	{
		var afterFinish;
		if(window['QES_Global'])
		{
			afterFinish = QES_Global.getTopCacheClearFunction();
		}
		new Effect.Fade($(id),{duration:0.5, afterFinish:afterFinish});
	},

	/**
	* QualtricsCPTools.executeDotSyntax
	* executes javascript functions kind of like eval would.
	* @deprecated - use Qualtrics.Event.executeDotSyntax instead
	*/
	executeDotSyntax:Qualtrics.Event.executeDotSyntax,
	/**
	* QualtricsCPTools.getDotSyntaxParts
	* @deprecated - use Qualtrics.Event.getDotSyntaxParts instead
	**/
	getDotSyntaxParts:Qualtrics.Event.getDotSyntaxParts,
	/**
	* QualtricsCPTools.preventEvents
	* prevent any baseDistributer events from running for a period of time.
	* this is used by dragscroll so you cant click buttons at the end of a drag.
	* @deprecated - use Qualtrics.Event.preventEvents
	* @param {Number} duration- the amount of time in milliseconds before events are allowed again.
	*/
	preventEvents:Qualtrics.Event.preventEvents,
	stopPreventingEvents:Qualtrics.Event.stopPreventingEvents,
	buildDotSyntaxStringFromNode:function(node)
	{
		var callback = node.getAttribute('clickcallback');
		var instanceid = node.getAttribute('instanceid');
		var params = QualtricsCPTools.packageParameters(node);
		return QualtricsCPTools.buildDotSyntaxString(callback,params,instanceid);
	},
	/**
	 * builds the dot syntax string from its parts
	 *
	 * @param {string} command (required) callback function string; if command is not defined, the function returns false
	 * @param {array} parameters
	 * @param {string} instanceid
	 */
	buildDotSyntaxString:function(command,parameters,instanceid)
	{
		if (!command)
			return false;
		var str = command;
		if (instanceid)
		{
			str += (':'+instanceid);
		}
		if (parameters && parameters.length)
		{
			str += '(';
			for (var i=0,ilen=parameters.length;i<ilen;i++)
			{
				str += parameters[i];
				if (i < parameters.length-1)
					str += ',';
			}
			str += ')';
		}
		else if(str.indexOf('(') == -1)
		{
			str += '()';
		}
		return str;
	},

	/**
	* QualtricsCPTools.stripComments:
	* strips html comments. this is useful because word puts 2 pages of junk
	* inside comments when it pastes into rich text.
	*/
	stripComments:function(text)
	{
		//strip comments
		return text.replace(/<!--(.|\n|\r)*?-->/g, "");
	},
	/**
	* QualtricsCPTools.stripFormatting:
	* strips all the html tags in the text leaving BR tags and P tags.
	* @param {String} text the text you want stripped.
	* @return {String} the stripped text.
	*/
	stripFormatting:function(text)
	{
		text = QualtricsCPTools.stripComments(text);

		//we dont want to strip br tags so lets obscure them.
		text = text.replace(/<[Bb][Rr][^>]*>/g, "##br##");
		//we dont want to strip p tags so lets obscure them.
		text = text.replace(/<\/[Pp]>/g, "##/p##");
		text = text.replace(/<[Pp][^>]*>/g, "##p##");
		text = text.replace(/<[Ii][Mm][Gg][^>]/g, "##img##");


		//strip all other tags.
		text = text.stripTags();

		//put the br and p tags back
		text = text.replace(/##br##/g, "<br>");
		text = text.replace(/##p##/g, "<P>");
		text = text.replace(/##\/p##/g, "</P>");
		text = text.replace(/##img##/g, "<img ");
		return text;
	},
	/**
	* QualtricsCPTools.stripMostFormatting:
	* strips a lot of html tags
	* preserves: br p b strong u i em table
	* @param {String} text the text you want stripped.
	* @return {String} the stripped text.
	*/
	stripMostFormatting:function(text)
	{
		//strip comments
		text = QualtricsCPTools.stripComments(text);

		//we dont want to strip br tags so lets obscure them.
		text = text.replace(/<[Bb][Rr][^>]*>/g, "~#br#~");

		//we dont want to strip p tags so lets obscure them.
		text = text.replace(/<[Pp][^>]*>/g, "~#p#~");
		text = text.replace(/<\/[Pp]>/g, "~#/p#~");

		//we dont want to strip b tags so lets obscure them.
		text = text.replace(/<[Bb][^>]*>/g, "~#b#~");
		text = text.replace(/<\/[Bb]>/g, "~#/b#~");

		//we dont want to strip strong tags so lets obscure them.
		text = text.replace(/<[Ss][Tt][Rr][Oo][Nn][Gg][^>]*>/g, "~#strong#~");
		text = text.replace(/<\/[Ss][Tt][Rr][Oo][Nn][Gg]>/g, "~#/strong#~");

		//we dont want to strip strong tags so lets obscure them.
		text = text.replace(/<[Ee][Mm][^>]*>/g, "~#em#~");
		text = text.replace(/<\/[Ee][Mm]>/g, "~#/em#~");

		//we dont want to strip u tags so lets obscure them.
		text = text.replace(/<[Uu][^>]*>/g, "~#u#~");
		text = text.replace(/<\/[Uu]>/g, "~#/u#~");

		//we dont want to strip i tags so lets obscure them.
		text = text.replace(/<[Ii][^>]*>/g, "~#i#~");
		text = text.replace(/<\/[Ii]>/g, "~#/i#~");

		//we dont want to strip div tags because webkit uses them as line breaks so lets obscure them.
		text = text.replace(/<[Dd][Ii][Vv][^>]*>/g, "~#div#~");
		text = text.replace(/<\/[Dd][Ii][Vv]>/g, "~#/div#~");

		//we dont want to strip styles. Span tag will have attributes so don't remove the entire tag.
		text = text.replace(/<span/gi, "~#span#~");
		text = text.replace(/<\/span>/gi, "~#/span#~");

		//we dont want to strip table tags so lets obscure them.
		text = text.replace(/<[Tt][Aa][Bb][Ll][Ee][^>]*>/g, "~#table#~");
		text = text.replace(/<\/[Tt][Aa][Bb][Ll][Ee]>/g, "~#/table#~");
		text = text.replace(/<[Tt][Rr][^>]*>/g, "~#tr#~");
		text = text.replace(/<\/[Tt][Rr]>/g, "~#/tr#~");
		text = text.replace(/<[Tt][Dd][^>]*>/g, "~#td#~");
		text = text.replace(/<\/[Tt][Dd]>/g, "~#/td#~");
		text = text.replace(/<[Tt][Hh][^>]*>/g, "~#th#~");
		text = text.replace(/<\/[Tt][Hh]>/g, "~#/th#~");

		//strip all other tags.
		text = text.stripTags();

		//put the br and p tags back
		text = text.replace(/~#br#~/g, "<br />");
		text = text.replace(/~#p#~/g, "<p>");
		text = text.replace(/~#\/p#~/g, "</p>");

		//put the b tags back
		text = text.replace(/~#b#~/g, "<strong>");
		text = text.replace(/~#\/b#~/g, "</strong>");

		//put the u tags back
		text = text.replace(/~#u#~/g, "<u>");
		text = text.replace(/~#\/u#~/g, "</u>");

		//put the i tags back
		text = text.replace(/~#i#~/g, "<em>");
		text = text.replace(/~#\/i#~/g, "</em>");

		//put the div tags back
		text = text.replace(/~#div#~/g, "<div>");
		text = text.replace(/~#\/div#~/g, "</div>");

		//put the span tags back
		text = text.replace(/~#span#~/g, "<span");
		text = text.replace(/~#\/span#~/g, "</span>");

		//put the strong tags back
		text = text.replace(/~#strong#~/g, "<strong>");
		text = text.replace(/~#\/strong#~/g, "</strong>");

		//put the em tags back
		text = text.replace(/~#em#~/g, "<em>");
		text = text.replace(/~#\/em#~/g, "</em>");

		//put the table tags back
		text = text.replace(/~#table#~/g, "<table class='UserTable'>");
		text = text.replace(/~#\/table#~/g, "</table>");
		text = text.replace(/~#tr#~/g, "<tr>");
		text = text.replace(/~#\/tr#~/g, "</tr>");
		text = text.replace(/~#td#~/g, "<td>");
		text = text.replace(/~#\/td#~/g, "</td>");
		text = text.replace(/~#th#~/g, "<th>");
		text = text.replace(/~#\/th#~/g, "</th>");
		return text;
	},
	/** The onload event for coloring the survey select boxes correctly in firefox
	 */
	selectSurveyOnload: function()
	{
		var select = $('SurveySelect');
		//check to see if we selected a survey or if we selected a folder
		if (select && select.options && select.options[select.selectedIndex].getAttribute('folder') == 1)
		{
			//we have a folder
			if (Qualtrics.Browser.Gecko)
				select.addClassName('FireFoxFolder');
		}
	},

	/** This function handles the new survey select bar folders.
	 * @param {DOM} select The select box that triggered the event.
	 */
	selectSurvey: function(select)
	{
		//check to see if we selected a survey or if we selected a folder
		if (select.options[select.selectedIndex].getAttribute('folder') == 1)
		{
			//we have a folder
			//1. hide all the other selects
			//2. show my select

			//make the box a color
			select.addClassName('Folder');
			if (Qualtrics.Browser.Gecko)
				select.addClassName('FireFoxFolder');

			var folders = $('SurveySelector');
			var selects = folders.getElementsByTagName('div');
			var showElement = null;
			var hideElement = null;
			for (var i=0; i < selects.length; i++)
			{
				var element = $(selects[i]);
				if (element.getAttribute('folderDiv') == '1')
				{
					if ("SurveyFolder_"+select.value == element.id)
					{
						showElement = element;
					}
					else
					{
						if (element.getStyle('display') != 'none')
						{
							hideElement = element;
						}
					}
				}
			}
			if (hideElement && showElement)
			{
				var hidden = false;
				select.blur();
				hideElement.focus();
				Effect.Appear(showElement,
					{
						duration: 0.5,
						afterUpdate: function()
						{
							if (!hidden)
							{
								hideElement.setStyle({display: 'none'});
								hidden = true;
							}
						},
						afterFinish: function() {
						}
					}
				);
			}
			else
			{
				select.blur();
				hidden = false;
				if (showElement)
				{
					new Effect.BlindRight(showElement,
						{
							duration: 0.35,
							afterUpdate: function()
							{
								if (!hidden)
								{
									showElement.focus();
									hidden = true;
								}
							},
							afterFinish: function()
							{
								showElement.focus();
							}
						}
					);
				}
			}
		}
		else
		{
			select.removeClassName('Folder');
			select.removeClassName('FireFoxFolder');

			//we have a survey
			URLTools.post("setActiveSurvey", select.value);
		}
	},
	/**
	* QualtricsCPTools.smartTruncateSelectBox:
	* trucates select box options so that when ie chops of the sides, the user can still see the differentiating factors in the options list.
	* In other words, it will figure out if it should truncate the end or the middle based on the cardinality of the last 3 chars.
	* its a little bit smart, but it could be a lot smarter.
	*
	* @param {Select} selectNode - the select node that contains the options to truncate
	* @param {Number} opt_size - the characters to allow before truncation. (defaults to 100)
	* @param {Number} opt_cutSize - the amount of chars to check at the end (defaults to 3).
	* @param {Number} opt_startAt - which option to start checking for differences (defaults to 0)
	*                               this is useful if you have a descriptive option at the top of the list, and you dont want it to mess up your percentages.
	*/
	smartTruncateSelectBox:function(selectNode, opt_size, opt_cutSize, opt_startAt)
	{
		var cutSize = opt_cutSize || 3;
		var startAt = 0;
		if(opt_startAt !== undefined)
		{
			startAt = opt_startAt;
		}
		var size = opt_size || 100;
		var list = selectNode.childNodes;
		var uniques = {};
		var uniquesCount = 0;

		for(var i = startAt, len=list.length; i<len; ++i)
		{
			var opt = list[i].innerHTML.strip();
			var lastPart = opt.substring(opt.length-cutSize, opt.length);
			if(!uniques[lastPart])
			{
				++uniquesCount;
			}
			uniques[lastPart] = 1;
		}

		var percentThatHaveTheSameEnding = uniquesCount / (list.length-startAt);
		for(i = startAt, len=list.length; i<len; ++i)
		{

			if(list[i].innerHTML.length > size)
			{
				var full = list[i].innerHTML; //if we are truncating the options then put the full text as a title.
				if(percentThatHaveTheSameEnding < 0.6)
				{
					list[i].innerHTML = list[i].innerHTML.truncate(size);
				}
				else
				{
					//do a middle truncate
					list[i].innerHTML = QualtricsCPTools.middleTruncate(list[i].innerHTML, size);
				}
				list[i].title = full;
			}
		}
	},
	/**
	* QualtricsCPTools.middleTruncate:
	* trucates the middle of the string so they can still see all the ends.
	*
	*
	* @param {String} v - what you want truncated
	* @param {Number} size - the characters to allow before truncation.
	*/
	middleTruncate:function(v, size, rep)
	{
		if(v && v.length > size)
		{
			if(rep == undefined)
			{
				rep = '...';
			}
			var middle = (size/2)-(rep.length);
			var end = v.substring(v.length-middle, v.length);
			var start = v.substring(0, middle);
			v = start+rep+end;
		}
		return v;
	},
	/**
	 * QualtricsCPTools.setTimeoutTimer
	 * shows an alert when the user is about to timeout
	 */
	setTimeoutTimer: function()
	{
		var page = $('Page');
		//checking to see if there is a client action prevents the timer on the login page.
		if(page && page.ClientAction)
		{
			//the front end needs to be keeping alive or the backend will log them out even with front end activity
			//so we keep the backend alive with this timeout every 30 mins
			QualtricsCPTools.preventSessionTimeout();

			QualtricsCPTools.resetTimeoutTimer();
			if(Qualtrics.TimeoutInterval)
			{
				//make sure we never set more than 1
				clearInterval(Qualtrics.TimeoutInterval);
			}
			Qualtrics.TimeoutInterval = setInterval(function(){
				Qualtrics.TimeoutTimerCountDown--;
				//check to see if the timeout countdown is up
				if(Qualtrics.TimeoutTimerCountDown == 0)
				{
					new Ajax.Request(URLTools.getAjaxURL('getRemainingSessionMinutes'),{
						onSuccess:function(transport)
						{
							var minutesRemaining = transport.responseText.evalJSON();
							var minutesLeeway = 10;
							if(minutesRemaining <= minutesLeeway)
							{
								//make sure everything is saved
								if(Qualtrics.savePage)
									Qualtrics.savePage();

								var countDown = 120; //we give them a 120 second window to cancel the timeout
								var win = new Q_Window('Keepalive', {
									title:'You are about to be logged out due to inactivity',
									buttons:[
										{text:'Cancel', click:'QualtricsCPTools.cancelTimeout'},
										'close:URLTools.post(Logout)|Logout'
									]
								});
								win.setContent(QBuilder('div',{},[
									'If you do nothing you will automatically be logged out in ',
									QBuilder('span',{id:'TimeoutTimer'},countDown),
									' Seconds'
								]));
								if(Qualtrics.TimeoutMiniTimer)
								{
									Qualtrics.TimeoutMiniTimer.stop();
								}
								Qualtrics.TimeoutMiniTimer = new PeriodicalExecuter(function(pe) {
									if($('TimeoutTimer'))
									{
										countDown--;
										$('TimeoutTimer').innerHTML = countDown;
										if(countDown < 1)
										{
											pe.stop();
											URLTools.post('Logout');
										}
									}
									else
									{
										pe.stop();
									}
								}, 1); //count down every second to 0
							}
							else
								Qualtrics.TimeoutTimerCountDown = Math.min(minutesRemaining - minutesLeeway, 55);
						}
					});
				}
			}, 60*1000); //every sixty seconds we decrement the Qualtrics.TimeoutTimerCountDown by 1
		}
	},
	cancelTimeout:function()
	{
		Q_Window.closeWindow('Keepalive');
		QualtricsCPTools.resetTimeoutTimer();
		if(Qualtrics.TimeoutMiniTimer)
		{
			Qualtrics.TimeoutMiniTimer.stop();
		}
		QualtricsCPTools.keepAlive();
	},
	/**
	 * QualtricsCPTools.resetTimeoutTimer
	 **/
	resetTimeoutTimer:function()
	{
		//we store the timeout countdown seperately because it needs to be reset a lot and needs to be overhead free.
		Qualtrics.TimeoutTimerCountDown = 55;
		// The keepalive is sent if enough time has passed
		QualtricsCPTools.keepAlive();
	},
	resetKeepAliveTimer:function()
	{
		Qualtrics.KeepAliveTimerCountDown = 30;
	},
	keepAlive:function()
	{
		if(Qualtrics.KeepAliveTimerCountDown <= 0)
		{
			new Ajax.Request(URLTools.getAjaxURL('keepAlive'));
			QualtricsCPTools.resetKeepAliveTimer();
		}
	},
	preventSessionTimeout: function()
	{
		//the front end needs to be keeping alive or the backend will log them out even with front end activity
		QualtricsCPTools.resetKeepAliveTimer();
		if(Qualtrics.KeepAliveInterval)
		{
			//make sure we never set more than 1
			clearInterval(Qualtrics.KeepAliveInterval);
		}
		Qualtrics.KeepAliveInterval = setInterval(function(){
			Qualtrics.KeepAliveTimerCountDown--;
		}, 60*1000); //every minute count down till the keepalive request
	},
	/**
	* QualtricsCPTools.getBooleanClassName
	* returns a className if the variable equals values
	* this is useful for adding the QMenu 'check' classes
	*/
	getBooleanClassName:function(variable, value, className)
	{
		return (variable == value)?className:'';
	},
	activateSurveyAccessibilityCheck:function(callback, surveyID)
	{
		QModules.loadModule('Accessibility.js');
		Accessibility.activateSurveyAccessibilityCheck(callback, surveyID);
	},
	buildAccountMenu:function()
	{
		var items = [
			{display:Qualtrics.System.brandDescription, disabled:true, className:'BrandName'},
			{display:Qualtrics.User.name+' - '+Qualtrics.User.accountType, disabled:true, className:'UserName'}
		];
		if (Qualtrics.System.AvailableProducts)
		{
			var count = 0;
			for (var product in Qualtrics.System.AvailableProducts)
			{
				count++;
			}
			if (count > 1)
			{
				var canAccessCP = !!Qualtrics.System.AvailableProducts.ControlPanel;
				var canAccessThreeSixty = !!Qualtrics.System.AvailableProducts.ThreeSixty;
				var canAccessSI = !!Qualtrics.System.AvailableProducts.SiteIntercept;
				var canAccessContacts = !!Qualtrics.System.AvailableProducts.Contacts;

				var productSwitchers = {
					ControlPanel: {display:getMessage('SiteMenu', 'ControlPanel'), action:'QualtricsCPTools.changeProduct(ControlPanel)'},
					ThreeSixty: {display:getMessage('SiteMenu', 'ThreeSixty'), action:'QualtricsCPTools.changeProduct(ThreeSixty)'},
					SiteIntercept: {display:getMessage('SiteMenu', 'SiteIntercept'), action:'QualtricsCPTools.changeProduct(SiteIntercept)'},
					Contacts: {display:getMessage('SiteMenu', 'Contacts'), action:'QualtricsCPTools.changeProduct(Contacts)'}
				};

				var activeProduct = productSwitchers[Qualtrics.System.productName];
				activeProduct.action = '';
				activeProduct.keepmenuopen = true;
				activeProduct.className = 'ActiveProduct';
				if (canAccessCP)
					items.push(productSwitchers.ControlPanel);
				if (canAccessThreeSixty)
					items.push(productSwitchers.ThreeSixty);
				if (canAccessSI)
					items.push(productSwitchers.SiteIntercept);
				if (canAccessContacts)
					items.push(productSwitchers.Contacts);
				items.push({separator:true});
			}
		}

		//add account settings
		items.push({display:getMessage('SiteMenu','AccountSettings')+'...', action:'URLTools.post(ChangePage, UserSettingsSection)', defer:true});

		items.push({separator:true});

		if ($('SupportAndFeedback'))
		{
			var feedbackLink = $('SupportAndFeedback').value;
			var feedback = {display:getMessage('SiteWide','SupportAndFeedback'), action:'QualtricsCPTools.feedback('+feedbackLink+')'};
			items.push(feedback);
		}

		items.push({display:getMessage('SiteMenu','RefreshAccount'), action:'URLTools.post(RefreshUserInformation)',defer:true});
		items.push({display:getMessage('SiteMenu','Logout'), action:'URLTools.post(Logout)',defer:true});
		items.push({domNode:'QualtricsCPTools.SupportLoginEnabler.buildAllowSupportLoginEnabler', keepmenuopen:true});

		return {
			className:'AccountMenu',
			items: items,
			onMenuClose:'QualtricsCPTools.accountMenuClosed'
		};
	},
	/**
	 * callback for when the account menu closes
	 */
	accountMenuClosed: function()
	{
		QualtricsCPTools.SupportLoginEnabler.accountMenuClosed();
	},
	/**
	 * QualtricsCPTools.changeProduct
	 * @param {string} product
	 */
	changeProduct: function(product)
	{
		if (product && Qualtrics.System.AvailableProducts && Qualtrics.System.AvailableProducts[product])
		{
			var relUrl = Qualtrics.System.AvailableProducts[product];
			var a = document.createElement('a');
			a.href = relUrl;
			window.location.href = a.href;
		}
	},
	/**
	* this will test to see if the browser supports position:fixed.
	* and it will cache the result.
	*/
	browserSupportsFixedPosition:function()
	{
		if(this.cachedFixedPosSupport === null)
		{
			var testBox = QBuilder('div');
			$(testBox).setStyle({
				position:'fixed',
				top:'0px'
			});
			//$(testBox).setStyle({position:'fixed', top:'0px', height:'10px',width:'10px',backgroundColor:'pink', zIndex:19999});
			$('pageDiv').appendChild(testBox);
			var pos = testBox.offsetTop;
			removeElement(testBox);

			if(pos === 0)
			{
				this.cachedFixedPosSupport = true;
			}
			else
			{
				this.cachedFixedPosSupport = false;
			}
		}
		return this.cachedFixedPosSupport;
	},

	modernBrowserWarning: function() {
		var win = new Q_Window('OutcomesBrowserWarning', {
			id: 'IENotSupportedSplash',
			width: 'auto',
			height: 'auto',
			title: getMessage('EditSection', 'UpgradeBrowser'),
			zIndex: 2020000,
			closeButton: true
		});

		var browserWarning = QBuilder('div', null, [
			QBuilder('div', {
				className: 'error-message'
			}, [
				getMessage('EditSection', 'IENotSupported')
			]),
			QBuilder('ul', null, [
				QBuilder('li', null, [
					QBuilder('div', {
						className: 'browser-option'
					}, [
						QBuilder('a', {
							href: 'http://www.getfirefox.com',
							className: 'firefox',
							target: '_blank'
						}, [QBuilder('strong', null, 'Firefox'), QBuilder('span', null, ' (Free)')])
					])
				]),
				QBuilder('li', null, [
					QBuilder('div', {
						className: 'browser-option'
					}, [
						QBuilder('a', {
							href: 'http://www.google.com/chrome',
							className: 'chrome',
							target: '_blank'
						}, [QBuilder('strong', null, 'Chrome'), QBuilder('span', null, ' (Free)')])
					])
				]),
				QBuilder('li', null, [
					QBuilder('div', {
						className: 'browser-option'
					}, [
						QBuilder('a', {
							href: 'http://www.microsoft.com/windows/Internet-explorer/default.aspx',
							className: 'ie',
							target: '_blank'
						}, [QBuilder('strong', null, 'Internet Explorer 9+'), QBuilder('span', null, ' (Free)')])
					])
				])
			])
		]);
		win.setContent(browserWarning);
		win.center();
	},
	/**
	* QualtricsCPTools.updateScrollables
	* any element with the Scrollable class (Inside a ScrollableWrapper class) will get scroll with the window
	*
	* @param {String} scrollableId - id of the item that should move with the scrollbar
	* @param {Bool} containInParent - Whether the item should stay within the bounds of it's containing parent
	* @param {Bool} shrinkElement - Whether something in the element should shrink before moving out of it's containing parent
	* @param {String} shrinkId - The element that should shrink before moving off the screen.
	* @param {String} scrollableWrapperId - the ID of the wrapper if it contains one.  There should be a wrapper if the
	*					scrollable object isn't at the top of its parentContainer. Otherwise, the starting position will get mixed up
	*
	*/
	updateScrollables:function(scrollableId, parentContainer, scrollableWrapperId)
	{
		if($(scrollableId))
		{
			var scrollTop = getScrollInfo()[1];

			var scrollablePos;
			if(scrollableWrapperId != null)
			{
				scrollablePos = Position.cumulativeOffset($(scrollableWrapperId))[1];
			}
			else
			{
				if($(parentContainer))
				{
					scrollablePos = Position.cumulativeOffset($(parentContainer))[1];
				}
			}



			//Calculate the new revisions position
			var newScrollable = scrollTop-scrollablePos;

			//dont go into negatives
			if(newScrollable < 0)
			{
				newScrollable = 0;
			}

			var fixedPosition = this.browserSupportsFixedPosition();

			if($(parentContainer)){
				//Calculate height
				var parentHeight = $(parentContainer).getHeight();
				var height = $(scrollableId).getHeight();
				//Calculate distance from the bottom of parent
				var parentOffset = Position.cumulativeOffset($(parentContainer))[1];
				var distanceFromBottom = parentHeight - (scrollablePos - parentOffset);
				if(height + newScrollable >= distanceFromBottom)
				{
					//We don't want the element to leave it's parent container.
					newScrollable = distanceFromBottom-height;

					//dont go into negatives
					if(newScrollable < 0)
					{
						newScrollable = 0;
					}

					fixedPosition = false;
				}
			}


			if(fixedPosition )
			{
				//use position fixed so that the div remains at the top of the viewscreen
				if(scrollTop > scrollablePos)
				{
					//For some reason if the width is auto it can change with position fixed, so enforce the same
					//width as it first had
					var width = $(scrollableId).getWidth();

					newScrollable = 0;
					$(scrollableId).setStyle({
						position:'fixed',
						width:width+'px'
					});
				}
				else
				{
					$(scrollableId).setStyle({
						position:'static'
					});
					fixedPosition = false;
				}
				$(scrollableId).setStyle({
					top:(newScrollable)+'px'
				});
			}
			else
			{

				//move the RevisionsHeadup so it is at the top of the view.
				$(scrollableId).setStyle({
					position:'relative'
				});
				$(scrollableId).setStyle({
					top:(newScrollable)+'px'
				});
			}
			return fixedPosition;
		}
	},
	numberFormat:function(number, decimals, dec_point, thousands_sep)
	{
		number = (number + '').replace(/[^0-9+\-Ee.]/g, '');
		var n = !isFinite(+number) ? 0 : +number,
		prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),
		sep = (typeof thousands_sep === 'undefined') ? ',' : thousands_sep,
		dec = (typeof dec_point === 'undefined') ? '.' : dec_point, s = '', toFixedFix = function (n, prec)
		{
			var k = Math.pow(10, prec);
			return '' + Math.round(n * k) / k;
		};
		// Fix for IE parseFloat(0.55).toFixed(0) = 0;
		s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.');
		if (s[0].length > 3)
		{
			s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
		}
		if ((s[1] || '').length < prec)
		{
			s[1] = s[1] || '';
			s[1] += new Array(prec - s[1].length + 1).join('0');
		}
		return s.join(dec);
	},
	hexToRgb:function(hex_string, default_)
	{
		if (default_ == undefined)
		{
			default_ = null;
		}
		if (hex_string.substr(0, 1) == '#')
		{
			hex_string = hex_string.substr(1);
		}

		var r;
		var g;
		var b;
		if (hex_string.length == 3)
		{
			r = hex_string.substr(0, 1);
			r += r;
			g = hex_string.substr(1, 1);
			g += g;
			b = hex_string.substr(2, 1);
			b += b;
		}
		else if (hex_string.length == 6)
		{
			r = hex_string.substr(0, 2);
			g = hex_string.substr(2, 2);
			b = hex_string.substr(4, 2);
		}
		else
		{
			return default_;
		}

		r = parseInt(r, 16);
		g = parseInt(g, 16);
		b = parseInt(b, 16);
		if (isNaN(r) || isNaN(g) || isNaN(b))
		{
			return default_;
		}
		else
		{
			return {r: r / 255, g: g / 255, b: b / 255};
		}
	},
	rgbToHex:function(r, g, b, includeHash)
	{
		r = Math.round(r * 255);
		g = Math.round(g * 255);
		b = Math.round(b * 255);
		if (includeHash == undefined)
		{
			includeHash = true;
		}
		r = r.toString(16);
		if (r.length == 1)
		{
			r = '0' + r;
		}
		g = g.toString(16);
		if (g.length == 1)
		{
			g = '0' + g;
		}
		b = b.toString(16);
		if (b.length == 1)
		{
			b = '0' + b;
		}
		return ((includeHash?'#':'') + r + g + b).toUpperCase();
	},
	hsvToRgb:function(hue, saturation, value)
	{
			var red;
			var green;
			var blue;
			if (value == 0.0)
			{
					red = 0;
					green = 0;
					blue = 0;
			}
			else
			{
					var i = Math.floor(hue * 6);
					var f = (hue * 6) - i;
					var p = value * (1 - saturation);
					var q = value * (1 - (saturation * f));
					var t = value * (1 - (saturation * (1 - f)));
					switch (i)
					{
							case 1:red = q;green = value;blue = p;break;
							case 2:red = p;green = value;blue = t;break;
							case 3:red = p;green = q;blue = value;break;
							case 4:red = t;green = p;blue = value;break;
							case 5:red = value;green = p;blue = q;break;
							case 6: // fall through
							case 0:red = value;green = t;blue = p;break;
					}
			}
			return {r: red, g: green, b: blue};
	},
	rgbToHsv:function(red, green, blue)
	{
			var max = Math.max(Math.max(red, green), blue);
			var min = Math.min(Math.min(red, green), blue);
			var hue;
			var saturation;
			var value = max;
			if (min == max)
			{
					hue = 0;
					saturation = 0;
			}
			else
			{
				var delta = (max - min);
				saturation = delta / max;
				if (red == max)
				{
						hue = (green - blue) / delta;
				}
				else if (green == max)
				{
						hue = 2 + ((blue - red) / delta);
				}
				else
				{
						hue = 4 + ((red - green) / delta);
				}
				hue /= 6;
				if (hue < 0)
				{
						hue += 1;
				}
				if (hue > 1)
				{
						hue -= 1;
				}
		}
		return {
				h: hue,
				s: saturation,
				v: value
		};
	},

	/**
	* Determines whether or not a question text contains illegal javascript, which is decided if the following conditions are met:
	* 1) User's account does not have permission to use javascript in surveys
	* 2) Question text did NOT previously have a script in it (allows this change to be backwards compatible)
	*
	* @param {string} newText - the modified question text
	* @param {string} oldText - the question text that was previously saved
	* @return {boolean} - true if user is attempting to save a question with js when they are not allowed to, else false if this question text is g2g
	*/

	questionTextHasIllegalScripting: function(newText, oldText) {

		var canUseJavascript = Survey.getInstance().getPermission('allowJavaScript', true); //does this user have permission to use JS in their surveys

		if(canUseJavascript) { //no need to look further, user can use JS willy nilly
			return false;
		}

		var blacklist = [ //html stuffs that can execute js
			/onabort\s*=/i,
			/onblur\s*=/i,
			/onchange\s*=/i,
			/onclick\s*=/i,
			/ondblclick\s*=/i,
			/ondragdrop\s*=/i,
			/onerror\s*=/i,
			/onfocus\s*=/i,
			/onkeydown\s*=/i,
			/onkeypress\s*=/i,
			/onkeyup\s*=/i,
			/onload\s*=/i,
			/onmousedown\s*=/i,
			/onmousemove\s*=/i,
			/onmouseout\s*=/i,
			/onmouseover\s*=/i,
			/onmouseup\s*=/i,
			/onmove\s*=/i,
			/onreset\s*=/i,
			/onresize\s*=/i,
			/onselect\s*=/i,
			/onsubmit\s*=/i,
			/onunload\s*=/i,
			/<script/i
		];

		var newTextHasScript = false, //does the user have a script in the question text
			oldTextHasScript = false; //did the question text previousyly have a script in it?

		blacklist.forEach(function(regex) {
			if(newText.match(regex)) {
				newTextHasScript = true;
			}
			if(oldText.match(regex)) {
				oldTextHasScript = true;
			}
		});

		//user without JS permission has attempted to add a script to a question text that previously did not have a script
		return (newTextHasScript && !oldTextHasScript);
	}
};

/**
 * Allows user to grant support login access from the account menu on any page.
 */
QualtricsCPTools.SupportLoginEnabler = {
	intervalPeriod: 5000,
	intervalId: null,
	domNode: null,
	loginRequested: false,
	requestorEmail: null,
	innerDisplay: null,
	displayText: null,
	errors: 0,
	errorThreshold: 5,
	allowSupportLoginInProgress: false,
	self: 'QualtricsCPTools.SupportLoginEnabler',
	build:function()
	{
		if (!this.domNode)
			this.domNode = QBuilder('div', {id:'AllowSupportLoginEnabler', clickcallback: this.self+'.allowSupportLogin', className:'Requested'});

		return this.domNode;
	},

	buildAllowSupportLoginEnabler: function(opt_repositionCallback)
	{
		this.repositionMenuCallback = opt_repositionCallback || Qualtrics.Menu.positionMenus;
		this.build();
		this.hide();
		var that = this;
		this.checkForSupportLoginRequested();
		this.intervalId = setInterval(function() {that.checkForSupportLoginRequested()}, this.intervalPeriod);

		return this.domNode;
	},
	show: function()
	{
		var firstTime = false;
		if (this.requestorEmail)
		{
			if (!this.innerDisplay)
			{
				this.displayText = getMessage('SiteWide', 'AllowSupportLogin', getMessage('UserSettingsSection', 'QualtricsSupport'));
				this.innerDisplay = QBuilder('span', {}, this.displayText);
				firstTime = true;
			}
			$(this.domNode).appendChild(this.innerDisplay);
		}
		$(this.domNode).show();
		this.repositionMenuCallback();
	},
	hide: function()
	{
		$(this.domNode).hide();
	},
	destroy: function()
	{
		this.stopAjaxRequests();
		$(this.domNode).remove();
		this.domNode = null;
	},
	stopAjaxRequests: function()
	{
		if (this.intervalId)
		{
			clearInterval(this.intervalId);
			this.intervalId = null;
		}
	},
	accountMenuClosed:function()
	{
		this.stopAjaxRequests();
	},
	handleError: function()
	{
		this.loginRequested = false;
		this.errors++;
		if (this.errors > this.errorThreshold)
		{
			this.stopAjaxRequests();
			console.error('too many errors, stop polling for Login Requested');
		}
	},
	/**
	 * Runs while the menu is open until it closes or we discover that support has requested permission to log in
	 */
	checkForSupportLoginRequested: function()
	{
		if (this.loginRequested)
		{
			this.supportLoginRequested();
		}
		else
		{
			var that = this;
			new Ajax.Request(URLTools.getAjaxURL('GetPermissionedLogins'), {
				onSuccess: function(transport)
				{
					var response = transport.responseText.evalJSON();
					if (response)
					{
						for (var i = 0; i < response.length; ++i)
						{
							var permissionedLogin = response[i];
							if (permissionedLogin.Accepted !== true && permissionedLogin.Email.indexOf('@') !== -1) {
								//get the email and other data to show to the user
								that.requestorEmail = permissionedLogin.Email;
								that.loginRequested = true;
								that.supportLoginRequested();
								break;
							}
						}
					}
					else
					{
						that.loginRequested = false;
					}
				},
				onFailure: function()
				{
					that.handleError.apply(that);
				}
			});
		}
	},
	supportLoginRequested: function()
	{
		this.stopAjaxRequests();
		this.show();
	},
	supportLoginGranted: function(duration)
	{
		this.stopAjaxRequests();
		this.displayText = getMessage('SiteWide', 'SupportLoginGranted', getMessage('UserSettingsSection', 'QualtricsSupport'));
		this.innerDisplay = QBuilder('span', {}, [this.displayText]);
		var newDomNode = QBuilder('div', {id:'AllowSupportLoginEnabler', className:'Enabled'}, [this.innerDisplay]);

		$(this.domNode).replace(newDomNode);
		this.domNode = newDomNode;

		this.repositionMenuCallback();
	},
	/**
	 * The user is allowing support to login as them
	 */
	allowSupportLogin:function()
	{

		var that = this;
		if (!this.allowSupportLoginInProgress)
		{
			var finshedSaveGrantAcess = false;
			var finishedSavePermissionedLogin = false;
			this.allowSupportLoginInProgress = true;
			//allow logins across all QUni
			new Ajax.Request(URLTools.getAjaxURL('SaveGrantAccess'), {
				parameters: {
					loginType: 'GrantLoginOther',
					expireTime: '+7 day',
					email: that.requestorEmail
				},
				onSuccess: function(transport)
				{
					if (transport.responseText != '')
					{
						var result = transport.responseText.evalJSON();
						if (result.Diff && result.Date) {
							//we successfully allowed support to login
							console.log('allowing Qualtrics Support to login for ' + result.Diff);
							that.supportLoginGranted();
						}
					}
				},
				onFailure: function()
				{
					that.handleError.apply(that);
				},
				onComplete: function()
				{
					finshedSaveGrantAcess = true;
					if (finishedSavePermissionedLogin)
						that.allowSupportLoginInProgress = false;
				}
			});
		}
	}
};


QualtricsCPTools.Highlighter = Class.create();
QualtricsCPTools.Highlighter.registry = new Array();
QualtricsCPTools.Highlighter.autoHighlight = function(element, options)
{
	if($(element))
	{
		if(!options){ options = {}; }
		options.targetObj = element;
		if(options && options.type && options.type == 'class')
		{
			//we dont want to measure the element cause its not useful

			return new QualtricsCPTools.Highlighter(options).render();
		}
		else
		{
			var width = $(element).getWidth();
			var height = $(element).getHeight();
			var pos = Position.cumulativeOffset($(element));

			options.x = pos[0];
			options.y = pos[1];
			options.width = width;
			options.height = height;
		}
		return new QualtricsCPTools.Highlighter(options).render();
	}
};
QualtricsCPTools.Highlighter.getAll = function()
{
	return QualtricsCPTools.Highlighter.registry;
};
QualtricsCPTools.Highlighter.removeAll = function()
{
	for(var i=0,len=QualtricsCPTools.Highlighter.registry.length;i<len;++i)
	{
		QualtricsCPTools.Highlighter.registry[i].remove();
	}
	QualtricsCPTools.Highlighter.registry.length = 0;
};
QualtricsCPTools.Highlighter.getById = function(id)
{
	for(var i=0,len=QualtricsCPTools.Highlighter.registry.length;i<len;++i)
	{
		if(QualtricsCPTools.Highlighter.registry[i].id == id)
			return QualtricsCPTools.Highlighter.registry[i];
	}
	return null;
};
QualtricsCPTools.Highlighter.prototype = {
	id:null, //NOTE: this is not the id attribute, just a way to keep track of the highlighters.
	x:null,
	y:null,
	width:null,
	height:null,
	element:null,
	options:null,
	backgroundColor:null,
	color:null,
	opacity:0.6,
	type:'overlay', //overlay or class
	className:null,
	zIndex:10001,
	targetObj:null, //the thing that its highlighting, watch out for circular reference memory leaks with this one
	initialize:function(options)
	{
		if(options && options.type)
		{
			this.type = options.type;
		}
		if(options && options.className)
		{
			this.className = options.className;
		}
		if(options && options.id)
		{
			this.id = options.id;
		}
		if(options && options.targetObj)
		{
			//the target object is for use with options.type = "class"
			this.targetObj = options.targetObj;
		}
		else
		{
			if(options && options.type == "class")
			{
				console.error('if you use a "class" highlighter, you must use options.targetObj');
				return;
			}
		}
		if(options && options.backgroundColor)
		{
			if(options.backgroundColor == 'red')
			{
				options.backgroundColor = '#C75E5E';
			}
			if(options.backgroundColor == 'blue')
			{
				options.backgroundColor = '#3D72D6';
			}

			this.backgroundColor = options.backgroundColor;
		}
		if(options && options.color)
		{

			if(options.color == 'red')
			{
				options.color = '#C75E5E';
			}
			if(options.color == 'blue')
			{
				options.color = '#3D72D6';
			}
			this.color = options.color;
		}
		if(options && options.opacity)
		{
			this.opacity = options.opacity;
		}
		if(options && options.zIndex)
		{
			this.zIndex = options.zIndex;
		}
		if(this.type == 'overlay')
		{
			//make color work for backgroundColor
			//cause there is no color in overlay
			var x = options.x;
			var y = options.y;
			var width = options.width;
			var height = options.height;
			if(!options || x == undefined || y == undefined || width == undefined || height == undefined)
			{
				return QES_Error('an overlay highlight needs x, y, width, and height in the options');
			}
			this.x = Number(x)+1;
			this.y = Number(y)+1;
			this.width = Number(width);
			this.height = Number(height);

			if(Qualtrics.Browser.IE)
			{
				//i dont know
				this.x = Number(x)+2;
				this.y = Number(y)+2;
			}
			if(options && options.padding)
			{
				this.x = this.x - (options.padding);
				this.y = this.y - (options.padding);
				this.width = this.width + (options.padding*2);
				this.height = this.height + (options.padding*2);
			}
			//default to a white overlay
			if(!options || !options.backgroundColor)
			{
				this.backgroundColor = 'white';
			}
			//make it so you can use color instead of backgroundColor cause it keep confusing me
			if(this.color) this.backgroundColor = this.color;
		}
		this.options = options;
		QualtricsCPTools.Highlighter.registry.push(this);
		return this;
	},
	render:function()
	{
		if(this.type == 'overlay')
		{
			var highlighter = QBuilder('div',{className:'Highlighter'});
			if(this.options.caption)
			{
				highlighter.appendChild(QBuilder('div',{className:'Caption'},this.options.caption));
			}
			$(highlighter).setStyle({
				opacity:this.opacity,
				position:'absolute',
				zIndex:this.zIndex,
				backgroundColor:this.backgroundColor,
				top:this.y+'px',
				left:this.x+'px',
				width:this.width+'px',
				height:this.height+'px'
			});
			$('pageDiv').appendChild(highlighter);
			this.element = highlighter;
		}
		else if(this.type == 'class')
		{
			$(this.targetObj).addClassName(this.className);
			if(this.backgroundColor)
			{
				$(this.targetObj).setStyle({backgroundColor:this.backgroundColor});
			}
			if(this.color)
			{
				$(this.targetObj).setStyle({color:this.color});
			}
		}
		if(this.options && this.options.onclick)
		{
			var el = this.element;
			if(this.targetObj)
			{
				el = this.targetObj;
			}
			el.onclick = this.options.onclick;
			$(el).setStyle({cursor:'pointer'});
		}
		return this;
	},
	remove:function()
	{
		if(this.type == 'overlay')
		{
			if($(this.element))
			{
				//remove the onclick;
				if(this.options && this.options.onclick)
					this.element.onclick = null;
				removeElement(this.element);
			}
		}
		else if(this.type == 'class')
		{
			//remove all the things put in to the targetObj by the class highlighting.
			if($(this.targetObj))
			{
				$(this.targetObj).removeClassName(this.className);
				if(this.backgroundColor)
				{
					$(this.targetObj).setStyle({backgroundColor:''});
				}
				if(this.color)
				{
					$(this.targetObj).setStyle({color:''});
				}
				//remove the onclick
				if(this.options && this.options.onclick)
					this.targetObj.onclick = null;
				$(this.targetObj).setStyle({cursor:''});
			}
		}
	}
};
QualtricsCPTools.errorHandlers =
{
	timeoutRedirect: false,
	timeout:function(msg)
	{
		if (QualtricsCPTools.errorHandlers.timeoutRedirect)
			return;

		alert(msg);

		QualtricsCPTools.errorHandlers.timeoutRedirect = true;

		var s = window.location+'';
		window.location = s.substring(0, s.indexOf('?'));
	}
};
QualtricsCPTools.parseHeaderJSON = function(json, transport)
{
	if(json)
	{
		if(json['error'] && json['error'].length)
		{
			for(var i=0, error; error=json['error'][i]; ++i)
			{
				if(QualtricsCPTools.errorHandlers[error['code']])
				{
					QualtricsCPTools.errorHandlers[error['code']](error['message']);
				}
			}
		}

		ShowMessage(json, transport);
	}
};

/**
* QualtricsCPTools.velocimeter
* measures the velocity of mouse movements.
* you can also assign callbacks to be executed on every update with the current velocity as a param.
*/
QualtricsCPTools.velocimeter = {
	currentVelocity:[0,0],
	lastPos:null,
	intervalObj:null, //this is the interval that
	callbacks:null,
	nextCallbackIndex:'1',
	started:false,
	/**
	* @param {function} callback
	* @return {String} the index of the
	*/
	add:function(callback)
	{
		if(!QualtricsCPTools.velocimeter.callbacks) QualtricsCPTools.velocimeter.callbacks = {};
		var index = QualtricsCPTools.velocimeter.nextCallbackIndex;
		QualtricsCPTools.velocimeter.callbacks[index] = callback;
		//increment the index
		QualtricsCPTools.velocimeter.nextCallbackIndex = String(Number(QualtricsCPTools.velocimeter.nextCallbackIndex)+1);
		if(!QualtricsCPTools.velocimeter.started)
		{
			QualtricsCPTools.velocimeter.start();
		}
		return index;
	},
	remove:function(callbackIndex)
	{
		delete QualtricsCPTools.velocimeter.callback[callbackIndex];
		//if there are no more callbacks then stop the velocimeter
		for(i in QualtricsCPTools.velocimeter.callbacks)
		{
			return;
		}
		QualtricsCPTools.velocimeter.stop();
	},
	start:function()
	{
		QualtricsCPTools.velocimeter.currentVelocity = [0,0];
		QualtricsCPTools.velocimeter.lastPos = [window.mousePos[0], window.mousePos[1]];
		QualtricsCPTools.velocimeter.intervalObj = setInterval(QualtricsCPTools.velocimeter.measureVelocity, 50);
		QualtricsCPTools.velocimeter.started = true;
	},
	stop:function()
	{
		if(this.intervalObj)
		{
			clearInterval(this.intervalObj);
			this.intervalObj = null;
		}
		QualtricsCPTools.velocimeter.callbacks = null;
		QualtricsCPTools.velocimeter.started = false;
	},
	measureVelocity:function()
	{
		QualtricsCPTools.velocimeter.currentVelocity = [
			window.mousePos[0]-QualtricsCPTools.velocimeter.lastPos[0],
			window.mousePos[1]-QualtricsCPTools.velocimeter.lastPos[1]
		];
		QualtricsCPTools.velocimeter.lastPos = [window.mousePos[0], window.mousePos[1]];
		QualtricsCPTools.velocimeter.executeCallBacks();
	},
	executeCallBacks:function()
	{
		for(i in QualtricsCPTools.velocimeter.callbacks)
		{
			QualtricsCPTools.velocimeter.callbacks[i](QualtricsCPTools.velocimeter.currentVelocity);
		}
	}
};
/*
 * returns the intersection of two arrays
 */
QualtricsCPTools.arrayIntersect = function(a, b, opt_shouldSort)
{
	//make a copy of the arrays to not destroy the originals
	a = a.clone();
	b = b.clone();

	//if they haven't been sorted
	if(!!opt_shouldSort)
	{
		a.sort();
		b.sort();
	}

	var result = [];
	while( a.length > 0 && b.length > 0 )
	{
		if(a[0] < b[0])
			a.shift();
		else if(a[0] > b[0])
			b.shift();
		else
		{
			result.push(a.shift());
			b.shift();
		}
	}
	return result;
};

/**
* Q_GlobalLogic contains functions that are used in all the different logics (Q_LogicEditor, skipLogic, dynamicChoices).
*/
window.Q_GlobalLogic = {
	/**
	* Q_GlobalLogic.getDataFromLocator:
	* This is for Skip logic and Branching logic
	* returns an object with properties parsed from the locator
	* @param {String} locator - the system locator eg. q://QID1/SelectableChoice/1
	*											UNIT TEST:	q://QID3%231/ChoiceGroup/SelectedAnswers/2 (for SBS, the aggregateId should be 1, choiceId should be 2)
	* @returns {Object} - the same data in a nice object that is usable eg. {type:'SelectableChoice, choiceId:1}
	*/
	getDataFromLocator:function(locator)
	{
		var data = {};
		var aggregate = false;
		if(locator)
		{
			if(locator.indexOf('%') != -1)
			{
				//its been url encoded
				locator = decodeURIComponent(locator);
			}

			var locatorParts = this.getLocatorParts(locator);
			var query = locatorParts.query;
			if (query != undefined)
			{
				// query string needs to be stripped off the locator for further parsing
				locator = this.removeQueryStringFromLocator(locator);
			}

			var parts = locator.split('/');
			data.type = parts[3];
			if(locator.startsWith('qo://'))
			{
				data.quotaId = parts[2];

				if (query != undefined && query.SV != undefined)
				{
					data.surveyId = query.SV;
				}
			}
			else
			{
				data.questionId = parts[2];
				//the questionId could have # for sidebyside stuff
				if(data.questionId && data.questionId.indexOf('#') != -1)
				{
					var questionParts = data.questionId.split('#');
					data.questionId = questionParts[0];
					data.aggregateId = questionParts[1];
					aggregate = true;
				}
				if(parts[4] == 'Group')
				{
					data.choiceId = parts[5];
					data.answerIndex = parts[6];
					data.subType = 'Group';
				}
				else if(parts[4] == 'Rank')
				{
					data.choiceId = parts[5];
					data.subType = 'Rank';
				}
				else
				{
					if (data.type == 'DisplayableQuestion')
					{
						return data;
					}
					else if (data.type == 'SelectableAnswer' ||
							data.type == 'SelectedAnswerCount' ||
							data.type == 'SelectedChoicesCount')
					{
						data.answerId = parts[4];
					}
					else if (data.type == 'Region')
					{
						data.regionId = parts[4];
					}
					else
					{
						data.choiceId = parts[4];
					}
					if(parts.length > 5)
					{
						data.answerId = parts[5];
					}
				}

				//SBS stuff
				if(aggregate)
				{
					data.answerId = data.aggregateId;

					if (data.type == 'SelectableAnswer' || data.type == 'SelectedAnswerCount' || data.type == 'SelectedChoicesCount')
					{
						data.answerSeriesIndex = parts[4];
					}
					else if (data.type == 'ChoiceGroup')
					{
						data.choiceId = parts[5];
						data.answerSeriesIndex = parts[5];
					}
					else
					{
						//SelectableChoice
						data.choiceId = parts[4]; //this is already set by the previous stuff but lets do it again just for clarity.
						data.answerSeriesIndex = parts[5];
					}

					if(data.answerSeriesIndex !== undefined)
					{
						//the server stores this as 1 based and we just keep them in a 0 based array.
						//so we need to subtract 1.
						data.answerSeriesIndex--;
					}

				}
			}
		}
		return data;
	},
	removeQueryStringFromLocator: function(locator)
	{
		var index = locator.indexOf('?');
		if (index >= 0)
		{
			return locator.substr(0, index);
		}
		else
		{
			return locator;
		}
	},
	getLocatorParts:function(locator)
	{
		if (!locator)
			return {};
		var ret = {};
		var typeStart = locator.indexOf('://');
		if (typeStart == -1)
			return {};

		ret.type = locator.substring(0,typeStart);
		var str = locator.substring(typeStart+3);
		var parts = str.split('?');
		ret.base = parts[0];
		var query = parts[1];
		if (query != undefined)
		{
			var subparts = query.split('&');
			ret.query = {};
			for (var i=0,ilen=subparts.length;i<ilen;i++)
			{
				var kvp = subparts[i].split('=');
				var key = kvp[0];
				var val = kvp[1];
				ret.query[key] = val;
			}
		}
		return ret;

	},
	/**
	* Q_GlobalLogic.getLocatorFromDataObject
	* This is the counterpart to Q_GlobalLogic.getDataFromLocator,
	* if you dont have a data object you might want to use Q_GlobalLogic.getLocatorFromData which takes a series of params.
	*
	* @ param {Object} data - this is the data that you get out of Q_GlobalLogic.getDataFromLocator
	* @ return {String} - the locator described by the data
	*/
	getLocatorFromDataObject:function(data)
	{
		/*
		* first we take all known items out of the data and put them into more generic variables
		*/
		var location1 = data['regionId'] || data['choiceId'] || data.location1;
		//answerIds are normal matrix type things
		//answerIndex is for things like PGR groups where they are 0 based
		var opt_location2 = data['answerId'] || data['answerIndex'] || data.location2;
		var id = data.questionId || data.quotaId || data.elementId;
		var type = data.type;
		var subType = data.subType;
		var opt_id2 = data.aggregateId;

		switch(type)
		{
			case 'Quota':
				//location1 should be the operator
				if(id && location1)
				{
					var locator = "qo://"+encodeURIComponent(id)+"/";
					if(location1 != 'QuotaMet' && location1 != 'QuotaNotMet')
					{
						location1 = 'QuotaCount';
					}
					locator+=location1;
					//check for survey parameter
					if (opt_location2)
					{
						locator+=('?SV='+opt_location2);
					}
				}
				else
				{
					locator = null;
				}
			break;
			case 'Status':
				var prefix = '';
				var key = '';
				switch (data.elementType)
				{
					case 'Survey':
						prefix = 's';
						if (location1 == 'IsActive' || location1 == 'IsNotActive')
							key = 'SurveyStatus';
					break;
				}
				locator = prefix + '://' + encodeURIComponent(id) + '/' + key;

			break;
			case 'EmbeddedData':
				locator = 'e://Field/'+encodeURIComponent(id);
			break;
			case 'PanelMember':
				locator = 'm://'+encodeURIComponent(id);
			break;
			case 'SurveyDirectorActionCount':

				locator = 'sd://' + encodeURIComponent(id) + '/' + location1 + '/Count';
			break;
			default:
				/*
				* then we turn the generic variables into a locator.
				*/
				if(!opt_location2)
				{
					//normalize falsy values
					opt_location2 = undefined;
				}
				if(!opt_id2)
				{
					//normalize falsy values
					opt_id2 = undefined;
				}
				if(opt_id2)
				{
					//add the sbs stuff to the question id
					id += '#'+opt_id2;
				}
				if (data.loopId)
				{
					id = data.loopId + '_' + id;
				}
				if(data.aggregateId !== undefined)
				{
					if(data.answerSeriesIndex != undefined)
					{
						opt_location2 = Number(data.answerSeriesIndex)+1;
					}
					else
					{
						opt_location2 = null;
					}
				}
				//if an answerId is passed without a choiceId then we need to have the answerId function as the choiceId.
				//so it will just be SelectableAnswer/1
				//instead of SelectableAnswer/null/1
				if(location1 === undefined || location1 === null)
				{
					if(opt_location2 !== undefined && opt_location2 !== null)
					{
						location1 = opt_location2;
						opt_location2 = null;
					}
				}
				locator = 'q://'+encodeURIComponent(id)+'/'+type;

				if(subType)
				{
					locator += '/'+subType;
				}

				if(location1)
				{
					locator += '/'+location1;
				}


				if(opt_location2 !== undefined && opt_location2 !== null && opt_location2 !== "")
				{
					locator += '/'+opt_location2;
				}
			break;
		}


		return locator;
	},
	/**
	* Q_GlobalLogic.getLocatorFromData
	* this is used for skip logic and branching
	* NOTE: carry forward has its own getDataFromLocator
	* NOTE: This doesn't support the subTypes used in PGR questions.
	* @param {String} id - a questionId or quotaId
	* @param {String} type - the locator type
	* @param {String} location1 - choiceId or quota type, what we are looking at, our subject.
	* @param {String} opt_location2 - an optional second location parameter eg. an answerId.
	* @param {String} opt_id2 - an optional second part to the id to further distinguish the question. ie. SBS will have question ids like this: QID29#2, you would pass 'QID29' for id, and '2' for opt_id2.
	* @return {String} a fully formed locator.
	*/
	getLocatorFromData:function(id, type, location1, opt_location2, opt_id2, opt_subType)
	{
		var data = {
			type:type
		};

		switch(type)
		{
			case 'Quota':
				data.quotaId = id;
				data.location1 = location1;
				data.location2 = opt_location2;
			break;
			case 'Status':
				data.elementId = id;
				data.elementType = opt_location2;
				data.location1 = location1;
			break;
			case 'SurveyDirectorActionCount':
				data.elementId = id;
				data.location1 = location1;
			break;
			case 'EmbeddedData':
				data.elementId = id;
			break;
			case 'PanelMember':
				data.elementId = id;
			break;
			default:
				data.questionId = id;
				data.location1 = location1;
				data.location2 = opt_location2;
				data.subType = opt_subType;
			break;

		}
		return Q_GlobalLogic.getLocatorFromDataObject(data);
	},
	/**
	* Q_GlobalLogic.getDefaultLocatorType: SKIPLOGIC ONLY
	@ param {String} questionType - The question type eg. Matrix, MC, RO.
	@ param {String} selector - The question selector.
	* @return {String} the appropriate deafult locator type for use in a locator.
	*/
	getDefaultLocatorType:function(questionType, selector)
	{
		var retVal = '';
		switch(questionType)
		{
			case 'DB':
			case 'FileUpload':
			case 'Captcha':
				retVal = 'DisplayableQuestion';
			break;
			case 'TE':
				retVal = 'ChoiceTextEntryValue';
			break;
			case 'CS':
			case 'RO':
			case 'Slider':
			case 'Timing':
				retVal = 'ChoiceNumericEntryValue';
			break;
			case 'Matrix':
				if(selector && selector == 'RO')
				{
					retVal = 'ChoiceNumericEntryValue';
				}
				else
				{
					retVal = 'SelectableChoice';
				}
			break;
			case 'SBS':
				retVal = 'SelectableAnswer';
			break;
			default:
				retVal = 'SelectableChoice';
			break;
		}
		return retVal;
	},
	getDefaultOperator:function(locatorType)
	{
		var retVal = '';
		switch(locatorType)
		{
			case 'DisplayableQuestion':
				retVal = 'Displayed';
			break;
			case 'SelectableAnswer':
			case 'SelectableChoice':
			case 'DisplayableChoice':
				retVal = 'Selected';
			break;
			case 'ChoiceNumericEntryValue':
			case 'ChoiceTextEntryValue':
			case 'AnswerNumericEntryValue':
			case 'AnswerTextEntryValue':
			case 'SelectedAnswerCount':
			case 'SelectedChoicesCount':
				retVal = 'NotEmpty';
			break;
			case 'EmbeddedField':
				retVal = 'EqualTo';
			break;
			case 'UploadedFile':
				retVal = 'Uploaded';
			break;
			case 'UploadedFileSize':
				retVal = 'GreaterThan';
			break;
			case 'UploadedFileType':
				retVal = 'Document';
			break;
		}
		return retVal;
	},
	needsValueBox:function(condition)
	{
		switch (condition)
		{
			case 'Displayed':
			case 'NotDisplayed':
			case 'Selected':
			case 'NotSelected':
			case 'Empty':
			case 'NotEmpty':
			case 'QuotaMet':
			case 'QuotaNotMet':
			case 'ClickedIn':
			case 'NotClickedIn':
			case 'Uploaded':
			case 'NotUploaded':
			case 'Document':
			case 'Spreadsheet':
			case 'Graphic':
			case 'PDF':
				return false;
			break;
			default:
				return true;
			break;
		}
	},
	getQuestionIdFromLocator:function(locator)
	{
		var data = Q_GlobalLogic.getDataFromLocator(locator);
		var questionId = data.questionId;
		if(data.aggregateId)
		{
			questionId += '#'+data.aggregateId;
		}
		return questionId;
	},
	getQuestionLeftOperand:function(questionId, choiceLocator, operator, opt_location1, opt_location2, descriptor)
	{
		var values = [];
		if (descriptor)
		{
			values = descriptor.split(',');
		}
		var blockId = values[0];
		var loopId = values[1];

		var locatorData = Q_GlobalLogic.getDataFromLocator(choiceLocator);
		if(operator == 'Displayed' || operator == 'NotDisplayed')
		{
			//the type will usually stay the same exept for Displayed and NotDisplayed
			if(locatorData.type == 'SelectableAnswer')
			{
				locatorData['type'] = 'AnswerDisplayed';
			}
			else if (locatorData.type == 'DisplayableQuestion')
			{
				locatorData['type'] = 'QuestionDisplayed';
			}
			else
			{
				locatorData['type'] = 'ChoiceDisplayed';
			}
		}

		//allow locations to be manually passed in.
		locatorData.location1 = opt_location1;
		locatorData.location2 = opt_location2;

		if (blockId && loopId && loopId != 'all' && loopId != 'any')
		{
			locatorData.loopId = loopId;
		}

		var locator = Q_GlobalLogic.getLocatorFromDataObject(locatorData);
		return locator;
	},
	getTypeFromLocator:function(locator)
	{
		return this.getDataFromLocator(locator).type;
	},
	questionIsInLoopTextResponse: function(isInLoop)
	{
		var text = isInLoop === true ? 'yes':'no';
		return text;
	},
	loopAndMergeTargetFunction: function(descriptor) {
		var values = [];
		if (descriptor)
		{
			values = descriptor.split(',');
		}
		var blockId = values[0];
		var loop = values[1];

		if (loop == 'all')
		{
			return 'evaluateAllInArrayFunction';
		}
		else if (loop == 'any')
		{
			return 'evaluateAnyInArrayFunction';
		}
		else
		{
			return 'none';
		}
	},
	isROQuestionType: function(qId) {
		var question = BaseQuestion.getQuestionByQuestionId(qId);
		if (question && question.questionType == 'RO')
		{
			return true;
		}
		return false;
	},
	canUseRankOrder: function(subtype) {
		if (subtype && subtype.length > 0)
		{
			var exceptions = ['NotDisplayedChoices'];
			if (subtype.toLowerCase().indexOf('choices') >= 0)
			{
				return !(exceptions.indexOf(subtype) >= 0);
			}
		}
		return false;
	}
};


//respond to the ajaxDebug and ajaxMessage php functions
Ajax.Responders.register({
	onComplete: function(responseObj) {
		if(responseObj)
		{
			try
			{
				var json;
				if(Ajax.Response)
					responseObj = new Ajax.Response(responseObj); //for prototype 1.6
				//this is evaling the json in the header. not the body.
				if(responseObj.evalJSON)
				{
					//prototype 1.5
					json = responseObj.evalJSON();
				}
				else
				{
					json = responseObj.headerJSON;
				}

			QualtricsCPTools.parseHeaderJSON(json, responseObj.transport);
		}
			catch(e)
		{
			console.error(e);
		}
		}
	}
});
//automatically add the unique id into the request so it can be approved
Ajax.Responders.register(
	{
		onCreate: function(request)
		{
			try
			{
				request.options = request.options || {};
				request.options.requestHeaders = request.options.requestHeaders || {};
				var xsrfCookie = window.Cookie.readCookie('XSRF-TOKEN');
				request.options.requestHeaders['X-XSRF-TOKEN'] = xsrfCookie;
			}
			catch (e)
			{
				console.error(e);
			}
		},
		onComplete: function(requester, trans, xjson)
		{
			if (trans.transport.responseText)
			{
				if (trans.transport.responseText.indexOf('PHP Fatal error:') != -1)
				{
					console.error("Ajax Fatal Error: "+trans.responseText);
				}
			}
		}
	});


var EditorPopup = Class.create({
	initialize:function(options)
	{
		this.options = options || {};
		this.id = QualtricsCPTools.createNewId('EP');
		EditorPopup.reg[this.id] = this;
		this.width = 650;
		this.height = 300;
		if (options.width)
			this.width = options.width;
		if (options.height)
			this.height = options.height;
		if (options.contents)
		{
			this.contents = options.contents;
		}
		else
		{
			this.contents = '';
		}
		this.initializeButtons();
		//set up buttons array
		this.buttons = [
			{icon:'cancel', text:getMessage('SiteWide','Cancel'), click:'EditorPopup.cancel',instanceid:this.id, className:'negative'},
			{id:'Save', icon:'check', text:getMessage('SiteWide','Save'), click:'EditorPopup.save',instanceid:this.id, className:'positive'}
		];

		if (options.fullScreenButton && this.fullScreenButton)
			this.buttons.push(this.fullScreenButton);

		if (options.clearButton && this.clearButton)
			this.buttons.push(this.clearButton);

		if(options.buttons && options.buttons instanceof Array)
		{
			this.buttons = this.buttons.concat(options.buttons);
		}

		this.contentContainer = QBuilder('div',{style:'min-width:'+this.width+'px;min-height:'+this.height+'px;'});

		this.popup = new Q_Window(
			{
				id: this.options.id?this.options.id:'EditorPopup',
				title: options.title,
				width: 'auto',
				height: 'auto',
				buttons: this.buttons,
				className:this.options.className||'EditorPopup'
			}
		);

		this.popup.setContent(this.contentContainer);
		if (typeof(options.contents)!='undefined')
		{

			if (Object.isString(options.contents))
			{
				this.setEditorContent();
				this.popup.center();
			}
			else
			{
				if (options.contents.ajaxAction)
				{
					this.setupAjaxContents();
					this.popup.center();
				}
			}
		}
	},
	initializeButtons:function()
	{
		//Set up re-usable buttons
		this.clearButton = {
			icon:'popup',
			align:'left',
			text:getMessage('SiteWide', 'Clear'),
			click:'EditorPopup.clear',
			instanceid:this.id,
			className:'negative'
		};
		this.restoreButton = {
			icon:'next',
			align:'left',
			text:getMessage('SiteWide', 'RestoreSize'),
			click:"EditorPopup.resizePopupToDefault()",
			instanceid:this.id
		};
		this.fullScreenButton = {
			icon:'previous',
			align:'left',
			text:getMessage('SiteWide', 'FullScreen'),
			click:"EditorPopup.resizePopupToFullScreen()",
			instanceid:this.id
		};
	},
	setHeaderContent:function(header)
	{
		this.popup.updateHeader(header);
	},
	setEditorContent:function()
	{
		this.ta = QBuilder('textarea',{id:this.id},[this.contents]);
		$(this.ta).setStyle({width: this.width+'px',height: this.height-90+'px'});
		this.contentContainer.appendChild(this.ta);
		var that = this;
		//this has to be deferred for ie6
		var options = {
				on:{
					instanceReady:function(e){
						that.popup.center();
						e.editor.focus();
					}
				}
			};
		if (this.options.toolbar)
			options.toolbar = this.options.toolbar;
		if (this.width)
			options.width = this.options.width;
		if (this.height)
			options.height = this.options.height;
		(function(){that.editor = CKEDITOR.replace(that.ta,options)}).defer();
	},
	setupAjaxContents:function()
	{
		var waiter = QAjaxWaiter.showMediumRing();
		this.contentContainer.appendChild(waiter);
		$(waiter).setStyle({width: this.width+'px',height: this.height+'px'});
		this.popup.center();

		if (this.options.contents.ajaxAction)
		{
			var that = this;
			new Ajax.Request(URLTools.getAjaxURL(this.options.contents.ajaxAction),{
				parameters:this.options.contents.ajaxParams,
				onSuccess:function(transport)
				{
					var content = transport.responseText;
					if (that.options.contents.ajaxResultsFormatter)
					{
						content = that.options.contents.ajaxResultsFormatter(content);
					}
					that.contents = content;
					that.contentContainer.innerHTML = '';
					that.setEditorContent();
				}
			});
		}

	},
	save:function()
	{
		if(this.options.saveCallBack(this.editor.getData(), this) !== false)
		{
			this.closeWindow();
		}
	},
	cancel:function()
	{
		this.closeWindow();
	},
	clear:function()
	{
		$(this.ta).value = "";
	},
	closeWindow:function()
	{
		Q_Window.closeWindow(this.popup.options.id);
	},
	resizePopupToFullScreen:function()
	{
		var win = Q_Window.getInstance(this.popup.options.id);
		var leftButtonsContainer = $(win.footerNode).down('.LeftButtons');
		leftButtonsContainer.innerHTML = "";
		if (this.options.fullScreenButton && this.restoreButton)
			leftButtonsContainer.appendChild(win.buildButton(this.restoreButton));
		if (this.options.clearButton && this.clearButton)
			leftButtonsContainer.appendChild(win.buildButton(this.clearButton));
		this.appendAdditionalButtons(win, leftButtonsContainer);

		var viewport = getPageSize();
		//We need to add 20 px of padding so it resizes;
		var width = viewport.windowWidth - win.getResizeOffset('x') - 20;
		var height = viewport.windowHeight - win.getResizeOffset('y') - 20;

		$(this.ta).setStyle({width: width+"px",height: height+"px"});

		if (this.resizeContents)
			this.resizeContents(width,height);

		win.setSize(width, height);
		win.center();

	},
	resizePopupToDefault:function()
	{
		var win = Q_Window.getInstance(this.popup.options.id);
		var leftButtonsContainer = $(win.footerNode).down('.LeftButtons');
		leftButtonsContainer.innerHTML = "";
		if (this.options.fullScreenButton && this.fullScreenButton)
			leftButtonsContainer.appendChild(win.buildButton(this.fullScreenButton));
		if (this.options.clearButton && this.clearButton)
			leftButtonsContainer.appendChild(win.buildButton(this.clearButton));
		this.appendAdditionalButtons(win, leftButtonsContainer);

		this.resizeContents(this.width,this.height);

		win.setSize(this.width, this.height);
		win.center();

	},
	appendAdditionalButtons:function(qwindow, container)
	{
		if (this.additionalButtons && this.additionalButtons.length)
		{
			for(var i=0,len=this.additionalButtons.length; i<len; i++)
			{
				var button = this.additionalButtons[i];
				if (button['align'] === 'left')
					container.appendChild(qwindow.buildButton(button));
			}
		}
	},
	resizeContents:function(width, height)
	{
		$(this.ta).setStyle({width: width+"px",height: height+"px"});
	}
});
EditorPopup.reg = {};
EditorPopup.getInstance = QualtricsCPTools.getInstanceHelper(EditorPopup.reg);

var CodeMirrorEditorPopup = Class.create(EditorPopup,{
	setEditorContent:function(opt_replacementContents)
	{
		QModules.loadStylesheet('codemirroreditor.css',{blocking:true});
		QModules.loadModule('/WRQualtricsShared/JavaScript/CodeMirror/js/codemirror.js');

		var container = QBuilder('div',{className:'cssEditorContainer'});
		if(opt_replacementContents)
		{
			this.contents = opt_replacementContents;
		}
		this.ta = QBuilder('textarea',{id:this.id}, this.contents);

		$(container).setStyle({height: this.height+'px', width: this.width + 'px'});
		container.appendChild(this.ta);
		this.popup.setContent(container);

		this.loadEditor.curry(this).delay();
	},
	//this function is needed to make the editor appear in IE 6
	loadEditor:function(that)
	{
		that.editor = window.CodeMirror.fromTextArea($(that.ta),{
			matchBrackets: true,
			content: that.contents,
			textWrapping: false,
			height: that.height+'px',
			width: that.width + 'px',
			indentUnit:4,
			indentWithTabs:true,
			smartIndent:true,
			lineNumbers:(!!that.options.lineNumbers),
			extraKeys: {
				"Ctrl-S": function (instance) {
					return that.keySave(instance);
				},
				"Cmd-S": function (instance) {
					return that.keySave(instance);
				}
			 }
		});

		if (that.options.mode)
		{
			window.CodeMirror.modeURL = QModules.parsePath("/WRQualtricsShared/JavaScript/CodeMirror/js/%Nsyntax.js");
			that.editor.setOption("mode",that.options.mode);
			window.CodeMirror.autoLoadMode(that.editor,that.options.mode);
		}

		if (that.options.alwaysFullScreen)
		{
			that.resizePopupToFullScreen();
		}
		else
		{
			that.resizePopupToDefault();
		}
	},
	keySave:function()
	{
		if(this.options.keySaveCallBack)
		{
			return this.options.keySaveCallBack(this.editor.getValue());
		}
		return undefined;
	},
	save:function()
	{
		if(this.options.saveCallBack(this.editor.getValue()) !== false)
		{
			this.closeWindow();
		}
	},
	clear:function(optionalCode)
	{
		this.editor.setValue(optionalCode || "");
	},
	resizeContents:function(width,height)
	{
		if (this.options.apiLink)
		{
			height -= 25; //leave room for it.
		}

		$(this.ta).parentElement.setStyle({height: height+'px', width: width + 'px'});
		this.editor.setSize(width,height);
		this.editor.refresh();
	}
});

var CSSEditorPopup = Class.create(CodeMirrorEditorPopup,{
	initialize:function($super, options)
	{
		options.mode = 'css';
		$super(options);
	}
});
var JavascriptEditorPopup = Class.create(CodeMirrorEditorPopup,{
	initialize:function($super, options)
	{
		options.mode = 'javascript';
		$super(options);

		if (options.apiLink)
		{
			$(this.popup.content).addClassName('JavaScriptAPI');
			$(this.popup.content).parentElement.addClassName('JavaScriptAPI Container');
			this.addAPILink();
		}

	},
	addAPILink:function()
	{
		var apiLink = QBuilder('a',{href:'/WRAPI/QuestionAPI/', className:'JavaScriptAPI Link', target:'_blank'}, getMessage('UserSettingsSection', 'JSAPILink'));
		$(this.popup.content).parentElement.appendChild(apiLink);
	},
	clear:function($super, optionalCode)
	{
		$super(optionalCode || JavascriptEditorPopup.defaultJS);
	},
	save:function()
	{
		QModules.loadModule('/WRQualtricsShared/JavaScript/Esprima/esprima.js');
		var code = this.editor.getValue();
		var allowWindowClose = true;
		try {
			//Verify javascript syntax
			window.esprima.parse(code);

			var that = this;

			var alertOptions = {
				showCloseButton:true,
				cancelText: getMessage('EditSection', 'SaveAnyway'),
				okText: getMessage('EditSection', 'FixErrors'),
				cancelCallBack: function() {
					that.closeWindow();
				}
			};

			//Check for abandoned setInterval calls
			if (code.indexOf('setInterval') !== -1) {
				//Found a setInterval, check for a clearInterval
				if (code.indexOf('clearInterval') === -1) {
					alertOptions.message = getMessage('EditSection', 'SetIntervalNotCleared');
					QualtricsCPTools.showConfirmDialog(alertOptions);
					allowWindowClose = false;
				}
			}

			//Check for Ajax calls
			if (code.indexOf('Ajax.php') !== -1) {
				alertOptions.message = getMessage('EditSection', 'AjaxCallNotAllowed');
				QualtricsCPTools.showConfirmDialog(alertOptions);
				allowWindowClose = false;
			}

			if (code.indexOf('document.write') !== -1) {
				alertOptions.message = getMessage('EditSection', 'DocumentWriteWarning');
				QualtricsCPTools.showConfirmDialog(alertOptions);
				allowWindowClose = false;
			}

			if (code.indexOf('window.onload') !== -1) {
				alertOptions.message = getMessage('EditSection', 'WindowOnloadNotAllowed');
				QualtricsCPTools.showConfirmDialog(alertOptions);
				allowWindowClose = false;
			}
		} catch(e) {
			var alertOptions = {message:getMessage('EditSection', 'InvalidJavaScript') + e.description};
			QualtricsCPTools.showAlertDialog(alertOptions);
			console.log(e);
			return false;
		}

		if(code == JavascriptEditorPopup.defaultJS)
			code = "";

		if(this.options.saveCallBack(code) !== false && allowWindowClose === true)
		{
			this.closeWindow();
		}
	}
});
var JsonEditorPopup = Class.create(JavascriptEditorPopup,{
	initialize:function($super, options)
	{
		JsonEditorPopup.instance = this;
		$super(options);
	},
	initializeButtons:function($super)
	{
		this.additionalButtons = [
			{
				icon:'warning',
				align:'left',
				text:"Validate JSON",
				click:"EditorPopup.validateJson(1,1)",
				instanceid:this.id
			}
		];
		if(this.options.buttons && this.options.buttons instanceof Array)
		{
			this.options.buttons = this.options.buttons.concat(this.additionalButtons);
			this.additionalButtons = this.options.buttons;
		}
		else
		{
			this.options.buttons = this.additionalButtons;
		}

		$super();
	},
	validateJson:function(opt_showAlertIfFailed, opt_showAlertIfPassed)
	{
		QModules.loadModule("jsonlint.js");
		var success = true;
		var errorMessage = "";
		try
		{
			//if the json is invalid, jsl.parse throws an error, which will include details about where the error occurred, etc.
			//  so let's use that
			window.jsl.parser.parse(this.editor.getValue());
		}
		catch (e)
		{
			errorMessage = e.message;
			success = false;
		}

		if ((success && opt_showAlertIfPassed) || (!success && opt_showAlertIfFailed))
		{
			var message = (success) ? "This JSON is valid" : QBuilder('span',{},["Validation failed:",QBuilder('pre',{style:'color:red'},"\n\n"+errorMessage)]);
			var alertOptions = {message:message};
			QualtricsCPTools.showAlertDialog(alertOptions);
		}

		return success;

	},
	save:function()
	{
		if (this.options.mustValidate && !this.validateJson(true, false))
			return false;

		Q_Window.getInstance('EditorPopup').busifyButton('Save');
				var code = this.editor.getValue();
		var success = this.options.saveCallBack(code);

		if(success !== false)
		{
			this.closeWindow();
		}

		return success;
	}
});

var SIJavascriptEditorPopup = Class.create(JavascriptEditorPopup,{
	initialize:function($super, options)
	{
		options.apiLink = false;
		$super(options);
	},
	clear:function($super, optionalCode)
	{
		$super(optionalCode || SIJavascriptEditorPopup.defaultSIJS);
	},
	save:function()
	{
				var code = this.editor.getValue();
				if(code == SIJavascriptEditorPopup.defaultSIJS)
						code = "";

		if(this.options.saveCallBack(code) !== false)
		{
			this.closeWindow();
		}
	},
	initializeButtons:function()
	{
		//Set up re-usable buttons
		this.clearButton = {
			align:'left',
			text:getMessage('SiteWide', 'Clear'),
			click:'EditorPopup.clear',
			instanceid:this.id,
			className:'negative'
		};
		this.restoreButton = {
			align:'left',
			text:getMessage('SiteWide', 'RestoreSize'),
			click:"EditorPopup.resizePopupToDefault()",
			instanceid:this.id
		};
		this.fullScreenButton = {
			align:'left',
			text:getMessage('SiteWide', 'FullScreen'),
			click:"EditorPopup.resizePopupToFullScreen()",
			instanceid:this.id
		};
	}
});

JavascriptEditorPopup.defaultJS = 'Qualtrics.SurveyEngine.addOnload(function()\n{\n\t/*Place Your Javascript Below This Line*/\n\n});';
SIJavascriptEditorPopup.defaultSIJS = '(function() {\n\n\t/*Insert code here*/\n\n})();';

var SIMultiJavascriptEditorPopup = Class.create(SIJavascriptEditorPopup,{
	initialize:function($super, options)
	{
		options.mode = 'javascript';

		this.options = options || {};

		this.id = QualtricsCPTools.createNewId('EP');
		EditorPopup.reg[this.id] = this;
		this.width = 650;
		this.height = 300;
		if (options.width)
			this.width = options.width;
		if (options.height)
			this.height = options.height;

		this.initializeButtons();
		//set up buttons array
		this.buttons = [
			{icon:'cancel', text:getMessage('SiteWide','Cancel'), click:'EditorPopup.cancel',instanceid:this.id, className:'negative'},
			{id:'Save', icon:'check', text:getMessage('SiteWide','Save'), click:'EditorPopup.save',instanceid:this.id, className:'positive'}
		];

		if (options.fullScreenButton && this.fullScreenButton)
			this.buttons.push(this.fullScreenButton);

		if (options.clearButton && this.clearButton)
			this.buttons.push(this.clearButton);

		if(options.buttons && options.buttons instanceof Array)
		{
			this.buttons = this.buttons.concat(options.buttons);
		}
		this.tabsContainer = QBuilder('div',{className:'EditorTabs'});
		this.tabs = {};
		if (options.tabs)
		{
			this.tabContents = {};
			var tabs = options.tabs;
			var i = 0;
			for (var tabId in tabs)
			{
				var tab = tabs[tabId];
				if (i == 0)
					this.currentTab = tabId;
				if (tab.contents)
				{
					this.tabContents[tabId] = tab.contents;
				}
				else
				{
					this.tabContents[tabId] = '';
				}
				var tabEl = QBuilder('div',{className:'EditorTab', clickcallback:'EditorPopup.selectTab:'+this.id+'('+tabId+')'},getMessage('SiteInterceptSection', tabId));
				this.tabs[tabId] = tabEl;
				this.tabsContainer.appendChild(tabEl);
				i++;
			}
			this.tabsContainer.appendChild(QBuilder('div',{className:'clear'}));
		}
		QModules.loadStylesheet('codemirroreditor.css',{blocking:true});
		QModules.loadModule('/WRQualtricsShared/JavaScript/CodeMirror/js/codemirror.js');

		this.contentContainer = QBuilder('div',{style:'min-width:'+this.width+'px;min-height:'+this.height+'px;', className:'MultiContentContainer'});
		this.outerContainer = QBuilder('div',{},[
			this.tabsContainer,
			this.contentContainer
		]);

		this.popup = new Q_Window(
			{
				id: this.options.id?this.options.id:'EditorPopup',
				title: options.title,
				width: 'auto',
				height: 'auto',
				buttons: this.buttons,
				className:this.options.className||'EditorPopup'
			}
		);

		this.popup.setContent(this.outerContainer);
		this.selectTab(this.currentTab);
	},
	setEditorContent:function(opt_replacementContents)
	{
		var container = QBuilder('div',{className:'EditorContainer'});
		if(opt_replacementContents)
		{
			this.contents = opt_replacementContents;
		}
		this.ta = QBuilder('textarea',{id:this.id}, this.contents);
		$(container).setStyle({height: this.height+'px', width: this.width + 'px'});
		container.appendChild(this.ta);
		this.contentContainer.innerHTML = '';
		this.contentContainer.appendChild(container);
		this.loadEditor.curry(this).delay();
	},
	selectTab:function(tab)
	{
		if (this.currentTab)
		{
			$(this.tabs[this.currentTab]).removeClassName('selected');
			if (this.editor)
			{
				var code = this.editor.getValue();
				this.tabContents[this.currentTab] = code;
			}
		}
		$(this.tabs[tab]).addClassName('selected');
		this.currentTab = tab;
		this.setEditorContent(this.tabContents[tab]);
	},
	save:function()
	{
		var code = [];
		for (var tabId in this.tabs)
		{
			var tabCode = this.tabContents[tabId];

			if (this.currentTab == tabId)
			{
				//grab the currently displayed code
				tabCode = this.editor.getValue();
			}
			//check to see if it has been reset to the default
			if(tabCode == SIJavascriptEditorPopup.defaultSIJS)
				tabCode = "";
			var origCode = this.options.tabs[tabId].contents;
			code.push(origCode);
			code.push(tabCode);
		}

		if(this.options.saveCallBack.apply(null, code) !== false)
		{

			this.closeWindow();
		}
	}
});
/**
 * This is an ajax queue allowing you to push jobs to be run on demand.
 * They are run one at a time and will not run until the previous ajax call returns
 * (this allows other ajax calls to be run without waiting for all previous calls to return)
 * jobs are JSON objects containing the following:
 * action: the ajax action that is put in the URL (e.g Ajax.php?action=GetPanelMemberCount)
 * parameters: these are the ajax parameters that will be passed through the ajax call
 * onSuccess: the callback function that will be run when the call returns. this function can take
 *  the result from the ajax call as the first parameter.
 *
 * see example:
 * var updateCountJob = {
 *	action:'GetPanelMemberCount',
 *	parameters:{id:id},
 *	onSuccess:Panels.updateMemberCount
 *  };
 * AjaxQueue.push(updateCountJob);
 * AjaxQueue.execute();
 */
var AjaxQueue = {
	queue:[],
	type:'QUEUE', // set to STACK to simulate LIFO
	state: 0, //stopped state
	stateExecuting: 1,
	stateStopped: 0,
	setType:function(type)
	{
		this.type = type;
	},
	push:function(job)
	{
		this.queue.push(job);

		if (this.state == this.stateStopped)
		{
			this.execute();
		}
	},
	clear: function()
	{
		this.queue.length = 0;
		this.state = this.stateStopped;
	},
	execute:function()
	{
		if (this.queue.length > 0)
		{
			this.state = this.stateExecuting;
			var job;
			if (this.type == 'QUEUE')
			{
				job = this.queue[0];
				this.queue.splice(0,1);
			}
			else if (this.type == 'STACK')
			{
				job = this.queue.pop();
			}
			var that = this;
			var url;

			if (!job.url)
				url = URLTools.getAjaxURL(job.action);
			else
				url = job.url;

			var ajaxType = 'Request';
			if(job.cached)
			{
				ajaxType = 'CachedRequest';
			}
			new Ajax[ajaxType](url, {
				parameters:job.parameters,
				asynchronous:!job.asynchronous,
				onSuccess:function(transport)
				{
					try
					{
						job.onSuccess(transport);
					}
					catch(e)
					{
						console.warn('Queued Job Callback could not be run: '+e);
					}
				},
				onComplete: function()
				{
					that.execute();
				}
			});
		}
		else
		{
			this.state = this.stateStopped;
		}
	}
};
/**
 * This is a simple job queue that will run a series of functions
 * The parameter 'waitForFinish' can be set to true to force the queue to wait until an external event
 * has set the job's callStatus value to true
 * A periodical executer is started for each job
 *
 * Job parameters:
 * waitForFinish: (bool) set to true if the job is run asynchronously (ie. AJAX or iframe load)
 * call: (function) the function to be run
 * callStatus: (string) the job's starting status, once set to finished the next job in the queue is run
 * use setCurrentJobStatus to set the status of the currently running job.
 *
 */
var JobQueue = {
	queue:[],
	type:'QUEUE', // set to STACK to simulate LIFO
	waitForFinish:false,
	setType:function(type)
	{
		this.type = type;
	},
	push:function(job)
	{
		this.queue.push(job);
	},
	pop:function()
	{
		if (this.queue.length > 0)
		{
			var job = this.queue.pop();
			var that = this;
			job.call();
		}
	},
	setCurrentJobStatus:function(status)
	{
		if (this.currentJob)
			this.currentJob.callStatus = status;
	},
	execute:function()
	{
		if (this.queue.length > 0)
		{
			var job;
			if (this.type == 'QUEUE')
			{
				job = this.queue[0];
				this.queue.splice(0,1);
			}
			else if (this.type == 'STACK')
			{
				job = this.queue.pop();
			}
			this.currentJob = job;
			job.call();
			if (this.waitForFinish)
			{
				var that = this;
				that.executor = new PeriodicalExecuter(
					function(pe)
					{
						if (job.callStatus == 'finished')
						{
							pe.stop();
							that.execute();
						}
					},.5
				);
			}
			else
			{
				this.execute();
			}

		}
	},
	getJobCount:function()
	{
		return this.queue.length;
	},
	clear:function()
	{
		this.queue.length = 0;
	}
};

/**
 * This is a little helper class to insert ajax loading images into your page
 * showBar:
 * Will produce the gray candy cane image in a div
 * If no parameters are passed it returns the dom node of the loading image
 * if node is passed with no options it will replace the contents of the node with the loading image
 * options:
 *  repNode: bool  default is true, if true it will remove the contents of the specified node then insert the image
 * 	type: 'div' | 'tbody'  if the type is tbody it will insert a tr and td and div
 *  colSpan: int  this is useful if you are inserting in a table using type = 'tbody' so the td spans the table
 *  nst: bool  this is to indicate if it is going into a NiceSelectableTable where there is a column for checks
 */
var QAjaxWaiter = {
	showBar:function (node,options)
	{
		options = options || {};
		options.className = 'candyBarLoadingImage';
		return this.show(node,options);
	},
	showSmallRing:function (node,options)
	{
		options = options || {};
		options.className = 'smallRingLoadingImage';
		return this.show(node,options);
	},
	showSmallBar:function (node,options)
	{
		options = options || {};
		options.className = 'smallBarLoadingImage';
		return this.show(node,options);
	},
	showMediumRing:function (node,options)
	{
		options = options || {};
		options.className = 'mediumRingLoadingImage';
		return this.show(node,options);
	},
	show:function(node,options)
	{
		var className = 'candyBarLoadingImage';
		if (options.className != undefined)
			className = options.className;
		//if no parameters are set just return the loading image as a dom node
		if (node == undefined)
		{
			return QBuilder('div',{className:className});
		}
		options = options || {};
		var replace;
		if (options.repNode == undefined)
			replace = true;
		else
			replace = options.repNode;

		var type;
		if (options.type == undefined)
			type = 'div';
		else
			type = options.type;


		if ($(node))
		{
			//get current dimensions
			var dimensions = $(node).getDimensions();

			if (replace)
			{
				deleteChildren($(node));
			}

			if (type == 'div')
			{
				$(node).appendChild(QBuilder('div',{className:className}));
			}
			else if (type == 'tbody')
			{
				var colSpan;
				if (options.colSpan == undefined)
					colSpan = 1;
				else
					colSpan = options.colSpan;
				var nst = false;
				if (options.nst != undefined)
					nst = options.nst;

				var td = QBuilder('td',{colSpan:colSpan},[
						QBuilder('div',{className:className})
					]);

				$(td).setStyle({height:dimensions.height+'px'});

				var loadingimage = QBuilder('tr',{},[
						(nst)?QBuilder('td',{className:"Col_Selected"}):'',
						td
				]);
				$(node).appendChild(loadingimage);
			}
		}

		return $(node);
	}
};
Qualtrics.savePageOnUnload = function()
{
	if(typeof Qualtrics !== undefined && Qualtrics.savePage)
	{
		Qualtrics.savePage(false);
	}
};
Event.observe(window, 'unload', Qualtrics.savePageOnUnload);

//start the inactivity timer
QualtricsCPTools.setTimeoutTimer();

Qualtrics.disableInput = function(el)
{
	if ($(el))
	{
		var parentNode = $(el).up();
		var cover = QBuilder('div',{className:'disablingCover'});
		$(cover).setStyle({backgroundColor:'#ffffff',opacity:.6,position:'absolute'});
		cover.clonePosition($(el));
		$('body').appendChild(cover);

	}
};

Qualtrics.QButtonBuilder = {
	build:function(options)
	{
		if(!options.id)
			options.id = QualtricsCPTools.createNewId('BTN');
		var buttonClass = '';
		if (options.buttonClass)
			buttonClass = options.buttonClass;
		var className = 'qbutton ' + buttonClass;
		var iconClass = '';
		if (options.iconType)
		{
			iconClass = 'icon ' + options.iconType;
		}
		var clickcallback = options.clickcallback;
		return QBuilder('a',{id:options.id,className:className,href:'javascript:void(0);',clickcallback:clickcallback},[
			QBuilder('span',{className:iconClass}),
			options.buttonText
		]);
	}
};

Qualtrics.DateTools = {
	getMonths:function()
	{
		return [
			getMessage('SiteWide', 'January'),	getMessage('SiteWide', 'February'),
			getMessage('SiteWide', 'March'), getMessage('SiteWide', 'April'),
			getMessage('SiteWide', 'May'), getMessage('SiteWide', 'June'),
			getMessage('SiteWide', 'July'), getMessage('SiteWide', 'August'),
			getMessage('SiteWide', 'September'), getMessage('SiteWide', 'October'),
			getMessage('SiteWide', 'November'), getMessage('SiteWide', 'December')
		];
	},
	getDays:function()
	{
		return [
			getMessage('SiteWide', 'Sunday'), getMessage('SiteWide', 'Monday'),
			getMessage('SiteWide', 'Tuesday'), getMessage('SiteWide', 'Wednesday'),
			getMessage('SiteWide', 'Thursday'), getMessage('SiteWide', 'Friday'),
			getMessage('SiteWide', 'Saturday')
		];
	},
	mysqlTimeStampToDate:function(timestamp)
	{
			//function parses mysql datetime string and returns javascript Date object
			//input has to be in this format: 2007-06-05 15:26:02
			var regex=/^([0-9]{2,4})-([0-1][0-9])-([0-3][0-9]) (?:([0-2][0-9]):([0-5][0-9]):([0-5][0-9]))?$/;
			var p=timestamp.replace(regex,"$1 $2 $3 $4 $5 $6").split(' ');
			return new Date(p[0],p[1]-1,p[2],p[3],p[4],p[5]);
	},
	dateToMysqlTimeStamp:function(date)
	{
		var year = date.getFullYear();
		var month = date.getMonth()+1;
		if (month < 10)
			month = '0'+month;
		var day = date.getDate();
		if (day < 10)
			day = '0'+day;
		var hour = date.getHours();
		if (hour < 10)
			hour = '0'+hour;
		var min = date.getMinutes();
		if (min < 10)
			min = '0'+min;
		var sec = date.getSeconds();
		if (sec < 10)
			sec = '0'+sec;

		return year+'-'+month+'-'+day+' '+hour+':'+min+':'+sec;
	},

	roundDay:function(d,up)
	{
		if (!d)
			d = new Date();

		return new Date(d.getFullYear(), d.getMonth(), d.getDate(), up?23:0,up?59:0,up?59:0);
	},
	getFormattedDate:function(date)
	{
		if (!date)
			var d = new Date();
		else
			var d = new Date(date);
		return this.getMonths()[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear();
	},
	getFormattedDateTime:function(date)
	{
		if (!date)
			var d = new Date();
		else
			var d = new Date(date);
		return this.getMonths()[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear() + ' ' + d.getHours() + ':' + d.getMinutes();
	},
	getDurationText:function(start,end)
	{
		// start and end should be passed in as a Date object or as milliseconds
		var duration = end-start;
		return Qualtrics.DateTools.getFormattedTime(duration/1000);
	},
	getFormattedTime:function(time)
	{
		var sec = time;
		var min = 0;
		var str = '';
		var hasDay = false;
		if (time >= 60)
		{
			min = Math.floor(time/60);
			sec = time%60;
			if (min >= 60)
			{
				var hour = Math.floor(min/60);
				min = min%60;

				if (hour >=24)
				{
					hasDay = true;
					var day = Math.floor(hour/24);
					hour = hour%24;
					str += (day+'d ');
				}
				str += (hour+'h ');
			}

		}
		str += (min+'m ');
		if (!hasDay)
			str += (sec+'s ');


		return str;
	},
	formatMySQLDate:function(date)
	{
		var date = this.mysqlTimeStampToDate(date);
		return this.formatJSDate(date);
	},
	formatJSDate:function(date)
	{
		if (date)
		{
			var d = date.getDate();
			d = d < 10 ? '0' + d : d;
			var m = this.getMonths()[date.getMonth()];
			var y = date.getFullYear();
			var h = date.getHours();
			var am = h < 12;
			h = h%12;
			if (h == 0)
				h = 12;
			//h = h < 10 ? '0' + h : h;
			var mn = date.getMinutes();
			mn = mn < 10 ? '0' + mn : mn;


			return m + ' ' + d + ', ' + y + ' ' + h + ':' + mn + ' ' + (am ? 'am' : 'pm');
		}
	}

};
/**
 * This is a wrapper class for the Rich Text Editor so we can better keep track of the DOM node it's in.
 * @param {Object} options
 */
Qualtrics.RichTextEditor = Class.create({
	readyQueue:[],
	initialize:function(options)
	{
		this.options = options || {};
		if (this.options.value)
			this.val = this.options.value;
		this.id = QualtricsCPTools.createNewId('RTE');
		Qualtrics.RichTextEditor.reg[this.id] = this;
		this.ready = false;
		this.heightOffset = -83;
	},
	buildContainer:function()
	{
		this.container = QBuilder('div',{className:'QualtricsRTE'});
	},
	buildEditor:function()
	{
		var that = this;
		var options = {
			on:{
					instanceReady:function(e){
						try
						{
							that.ready = true;
							e.editor.focus();
							that.editorReady();
							if (that.options.onReady)
								that.options.onReady();
						}
						catch(err)
						{
							console.error(err);
						}
					}
				}
		};
		var style = {};
		if (this.options.width)
		{
			options.width = this.options.width;
			style.width = this.options.width + 'px';
		}
		if (this.options.height)
		{
			options.height = this.options.height+this.heightOffset;
			style.height = this.options.height + 'px';
		}

		if (this.options.toolbar)
			options.toolbar = this.options.toolbar;
		$(this.container).setStyle(style);
		//The container div has to exists prior to CKEditor.appendTo, so we will defer this.
		//This may have issues if you leave a console.log in
		(function(){that.editor = CKEDITOR.appendTo(that.container,options);}).defer();
		this.setText(this.options.value);
	},
	build:function()
	{
		this.buildContainer();
		this.buildEditor();

		return this.container;
	},
	editorReady:function()
	{
		while(this.readyQueue.length)
		{
			this.readyQueue[0]();
			this.readyQueue.splice(0,1);
		}
	},
	replace:function(id,options)
	{
		this.editor = CKEDITOR.replace(id,options);
	},
	setText:function(val)
	{
		this.val = val;
		var that = this;
		var f = function(){if (that.editor)that.editor.setData(val);};
		this.execute(f);
	},
	isDirty:function()
	{
		if (this.ready && this.editor)
		{
			return this.editor.checkDirty();
		}
		return false;
	},
	resetDirty:function()
	{
		var that = this;
		var f = function(){if (that.editor)that.editor.resetDirty();};
		this.execute(f);
	},
	execute:function(f)
	{
		if (this.ready) f();
		else this.readyQueue.push(f);
	},
	getText:function()
	{
		if (this.editor)
			return this.editor.getData();
		else if(this.val)
			return this.val;
	},
	destroy:function()
	{
		var that = this;
		var f = function(){if (that.editor)that.editor.destroy();that.editor = null;};
		this.execute(f);

	}
});
Qualtrics.RichTextEditor.reg = {};
Qualtrics.RichTextEditor.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.RichTextEditor.reg);

/* disableSelects
 *  This lovely function will disable all the inputs and selects on whatever page calls it, including QMenus.
 */
function disableSelects()
{
	var elements = $$(".menuButton");
	var elements2 = $$(".menuButton b b b");
	elements.each(function(el) {
		el.setAttribute('onclick', "return false;");
		el.addClassName('Disabled');
	});
	elements2.each(function(el) {
		el.setAttribute('downcallback', '');
	});

	elements = $$('input');
	elements.each(function(el)
		{
			el.disabled = true;
		});

	elements = $$('select');
	elements.each(function(el)
		{
			el.disabled = true;
		});
}

Object.extend(Qualtrics, {
/** Qualtrics.removeLabelHint() Attached to some form inputs to hint this is a label (ex. Configure Time Series, Benchmark Data, etc.) */
	removeLabelHint:function(e)
	{
		var textBox = this;	//This is the textbox
		textBox.removeClassName('Initial');

		//Remove default text
		if (textBox.value == getMessage('SiteWide','EnterLabelHint'))
		{
			textBox.value = '';
		}

		Event.stopObserving(textBox, 'click');
		Event.stopObserving(textBox, 'keydown');
	},
	/** Renumbers the first child element of the LI when reordered. Used in Configure Time Series, Benchmark Data, etc.) */
	renumberFirstChildOnSort:function(li)
	{
		if (li)
		{
			var ul = li.parentNode;
			var childs = $(ul).childElements();
			for (var i=0,len=childs.length; i<len; ++i)
			{
				$(childs[i]).down().innerHTML = (i+1);
			}
		}
	}
});


Qualtrics.EditableSpan = Class.create(Editable, {
	objType:'EditableSpan',
	keyMap:{enter:'onEnter'},
	maxlength:255,
	initialize:function(id,parent,callback)
	{
		this.parentObj = parent;
		this.callback = callback;
		this.id = id;
		Qualtrics.EditableSpan.reg[this.id] = this;
	},
	onEnter:function()
	{
		inlineEditor.getInstance().removeInlineEditor();
	},
	afterEdit:function()
	{
		//strip new lines

		this.text = stripNewLines(this.text);
		var name = this.text;
		if(name)
		{
			this.callback(this.id,name);
		}
	},
	onEmpty:function()
	{
		this.text = this.originalText;
		$(this.id).innerHTML = this.text;
	}
});
Qualtrics.EditableSpan.reg = {};
Qualtrics.EditableSpan.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.EditableSpan.reg, 'id');

Qualtrics.DetectZoom = {
	mediaQueryBinarySearch: function(
			property, unit, a, b, maxIter, epsilon) {
		var head = document.getElementsByTagName('head')[0];
		var style = document.createElement('style');
		var div = document.createElement('div');
		div.className = 'mediaQueryBinarySearch';
		head.appendChild(style);
		div.style.display = 'none';
		document.body.appendChild(div);
		var r = binarySearch(a, b, maxIter);
		head.removeChild(style);
		document.body.removeChild(div);
		return r;

		function binarySearch(a, b, maxIter) {
			var mid = (a + b)/2;
			if (maxIter == 0 || b - a < epsilon) return mid;
			if (mediaQueryMatches(mid + unit)) {
				return binarySearch(mid, b, maxIter-1);
			} else {
				return binarySearch(a, mid, maxIter-1);
			}
		}
		function mediaQueryMatches(r) {
			style.sheet.insertRule('@media (' + property + ':' + r +
														 ') {.mediaQueryBinarySearch ' +
														 '{text-decoration: underline} }', 0);
			var computedStyle = getComputedStyle(div, null);
			if(computedStyle)
			{
				var matched = computedStyle.textDecoration == 'underline';
			}
			style.sheet.deleteRule(0);
			return matched;
		}
	},
	_zoomIe7: function() {
		// the trick: body's offsetWidth was in CSS pixels, while
		// getBoundingClientRect() was in system pixels in IE7.
		// Thanks to http://help.dottoro.com/ljgshbne.php
		var rect = document.body.getBoundingClientRect();
		var z = (rect.right-rect.left)/document.body.offsetWidth;
		z = Math.round(z * 100) / 100;
		return {zoom: z, devicePxPerCssPx: z};
	},
	_zoomIe8: function() {
		// IE 8+: no trick needed!
		// TODO: MSDN says that logicalXDPI and deviceXDPI existed since IE6
		// (which didn't even have whole-page zoom). Check to see whether
		// this method would also work in IE7.
		return {
			zoom: screen.systemXDPI / screen.logicalXDPI,
			devicePxPerCssPx: screen.deviceXDPI / screen.logicalXDPI
		};
	},
	_zoomWebkitMobile: function() {
		// the trick: window.innerWIdth is in CSS pixels, while
		// documentElement.clientWidth is in system pixels.
		// And there are no scrollbars to mess up the measurement.
		var z = document.documentElement.clientWidth / window.innerWidth;
		var devicePixelRatio = window.devicePixelRatio != null ? window.devicePixelRatio : 1;
		// return immediately; don't round at the end.
		return {zoom: z, devicePxPerCssPx: z*devicePixelRatio};
	},
	_zoomWebkit: function() {
		// the trick: an element's clientHeight is in CSS pixels, while you can
		// set its line-height in system pixels using font-size and
		// -webkit-text-size-adjust:none.
		// device-pixel-ratio: http://www.webkit.org/blog/55/high-dpi-web-sites/

		// Previous trick (used before http://trac.webkit.org/changeset/100847):
		// documentElement.scrollWidth is in CSS pixels, while
		// document.width was in system pixels. Note that this is the
		// layout width of the document, which is slightly different from viewport
		// because document width does not include scrollbars and might be wider
		// due to big elements.

		var devicePixelRatio = window.devicePixelRatio != null ? window.devicePixelRatio : 1;

		var container = document.createElement('div')
			, div = document.createElement('div');
		// The container exists so that the div will be laid out in its own flow
		// while not impacting the layout, viewport size, or display of the
		// webpage as a whole.
		container.setAttribute('style', 'width:0; height:0; overflow:hidden;' +
				'visibility:hidden; position: absolute');
		div.innerHTML = "one<br>two<br>three<br>four<br>five<br>six<br>seven<br>eight<br>nine<br>ten";
		div.setAttribute('style', "font: 100px/1em sans-serif; -webkit-text-size-adjust:none;");
		container.appendChild(div);
		document.body.appendChild(container);
		var z = 1000 / div.clientHeight;
		z = Math.round(z * 100) / 100;
		var r = {
			zoom: z,
			devicePxPerCssPx: devicePixelRatio * z
		};
		document.body.removeChild(container);
		return r;
	},
	_zoomFF35: function() {
		// the trick for FF3.5 ONLY: device-width gives CSS pixels, while
		// screen.width gave system pixels. Thanks to QuirksMode's widths table,
		// which called it a bug. http://www.quirksmode.org/m/widths.html
		var z = screen.width /
			this.mediaQueryBinarySearch('min-device-width', 'px', 0, 6000, 20, .0001);
		z = Math.round(z * 100) / 100;
		return {zoom: z, devicePxPerCssPx: z};
	},
	_zoomFF36: function() {
		// the hack for FF3.6: you can measure scrollbar's width in CSS pixels,
		// while in system pixels it's 15px (verified in Ubuntu).

		// TODO: verify for every platform that a scrollbar is exactly 15px wide.
		var container = document.createElement('div')
			, outerDiv = document.createElement('div');
		// The container exists so that the div will be laid out in its own flow
		// while not impacting the layout, viewport size, or display of the
		// webpage as a whole.
		container.setAttribute('style', 'width:0; height:0; overflow:hidden;' +
				'visibility:hidden; position: absolute');
		outerDiv.style.width = outerDiv.style.height = '500px';  // enough for all the scrollbars
		var div = outerDiv;
		for (var i = 0; i < 10; ++i) {
			var child = document.createElement('div');
			child.style.overflowY = 'scroll';
			div.appendChild(child);
			div = child;
		}
		container.appendChild(outerDiv);
		document.body.appendChild(container);
		var outerDivWidth = outerDiv.clientWidth;
		var innerDivWidth = div.clientWidth;
		var scrollbarWidthCss = (outerDivWidth - innerDivWidth)/10;
		document.body.removeChild(container);
		var z = 15 / scrollbarWidthCss;  // scrollbars are 15px always?
		z = Math.round(z * 100) / 100;
		return {zoom: z, devicePxPerCssPx: z};
	},
	_zoomFF4: function() {
		// no real trick; device-pixel-ratio is the ratio of device dpi / css dpi.
		// (Note that this is a different interpretation than Webkit's device
		// pixel ratio, which is the ratio device dpi / system dpi).
		// TODO: is mozmm vs. mm promising?
		var z = this.mediaQueryBinarySearch(
						'min--moz-device-pixel-ratio',
						'', 0, 10, 20, .0001);
		z = Math.round(z * 100) / 100;
		return {zoom: z, devicePxPerCssPx: z};
	},
	_zoomOpera: function() {
		// the trick: a div with position:fixed;width:100%'s offsetWidth is the
		// viewport width in CSS pixels, while window.innerWidth was in system
		// pixels. Thanks to:
		// http://virtuelvis.com/2005/05/how-to-detect-zoom-level-in-opera/
		//
		// Unfortunately, this failed sometime in 2011; newer Opera always returns 1.
		// TODO: find a trick for new Opera versions.
		var fixedDiv = document.createElement('div');
		fixedDiv.style.position = 'fixed';
		fixedDiv.style.border = '5px solid blue';
		fixedDiv.style.width = '100%';
		fixedDiv.style.height = '100%';
		fixedDiv.style.top = fixedDiv.style.left = '0';
		fixedDiv.style.visibility = 'hidden';
		document.body.appendChild(fixedDiv);
		var z = window.innerWidth / fixedDiv.offsetWidth;
		z = Math.round(z * 100) / 100;
		document.body.removeChild(fixedDiv);
		return {zoom: z, devicePxPerCssPx: z};
	},
	ratios: function() {
		var r;
		if (! isNaN(screen.logicalXDPI) && ! isNaN(screen.systemXDPI) ) {
			return this._zoomIe8();
		} else if ('ontouchstart' in window && document.body.style.webkitTextSizeAdjust != null) {
			return this._zoomWebkitMobile();
		} else if (document.body.style.webkitTextSizeAdjust != null) {  // webkit
			return this._zoomWebkit();
		} else if (-1 != navigator.userAgent.indexOf('Firefox/3.5')) {
			return this._zoomFF35();
		} else if (-1 != navigator.userAgent.indexOf('Firefox/3.6')) {
			return this._zoomFF36();
		} else if (-1 != navigator.appVersion.indexOf("MSIE 7.")) {
			return this._zoomIe7();
		} else if (-1 != navigator.userAgent.indexOf('Opera')) {
			return this._zoomOpera();
		} else if (0.001 < (r = this._zoomFF4()).zoom) {
			return r;
		} else {
			return {zoom: 1, devicePxPerCssPx: 1};
		}
	},
	zoom: function() {
		return this.ratios().zoom;
	},
	device: function() {
		return this.ratios().devicePxPerCssPx;
	}
};

/***************************
 *
 *
 * Qualtrics.History
 *
 * Use this to make undos for your actions!
 *
 **/
Qualtrics.History = Class.create({
	undoStack:null,
	redoStack:null,
	initialize:function()
	{
		Qualtrics.History._instance = this;
		this.undoStack = [];
		this.redoStack = [];
	},
	addAction:function(description, undoActionDef, redoActionDef)
	{
		if(Qualtrics.History.suppressAddAction)
		{
			//we dont allow adding to the history when executing an action.
			return;
		}
		if(!redoActionDef)
		{
			console.error('Created undo without a redo, bad programmer');
		}
		//make sure all the parameters are safely packaged up
		if(undoActionDef.parameters)
		{
			this.autoPackageParameters(undoActionDef.parameters);
		}
		if(redoActionDef.parameters)
		{
			this.autoPackageParameters(redoActionDef.parameters);
		}
		this.undoStack.push({description:description, undo:undoActionDef, redo:redoActionDef});
	},
	autoPackageParameters:function(params)
	{
		for(var i=0,len=params.length; i<len; ++i)
		{
			if(params[i] && typeof params[i] == 'object' && !params[i].qPacked)
			{
				params[i] = Qualtrics.History.Actions.buildParameter(params[i]);
			}
		}
	},
	undo:function()
	{
		var action = this.undoStack.pop();
		if(action)
		{
			this.executeAction(action.undo);
			this.redoStack.push(action);
		}
	},
	redo:function()
	{
		var action = this.redoStack.pop();
		if(action)
		{
			this.executeAction(action.redo);
			this.undoStack.push(action);
		}
	},
	executeAction:function(actionDef)
	{
		//add a global flag to suppress any attempts to add things to the history while we are performing an undo/redo
		Qualtrics.History.suppressAddAction = true;
		Qualtrics.History.Actions.execute(actionDef);
		Qualtrics.History.suppressAddAction = false;
	}
});
Qualtrics.History.getInstance = function()
{
	if(!Qualtrics.History._instance)
	{
		return new Qualtrics.History();
	}
	return Qualtrics.History._instance;
};
Qualtrics.History.Actions = {
	/**
	 * Qualtrics.History.Actions.buildParameter
	 **/
	buildParameter:function(var_args)
	{
		var a = arguments[0];
		if(typeof a == 'object')
		{
			if(Object.isArray(a))
			{
				return Qualtrics.History.Actions.buildParameter_ObjectArray(a);
			}
			else
			{
				return Qualtrics.History.Actions.buildParameter_Object(a);
			}
		}
		else if(typeof a == 'number')
		{
			return Qualtrics.History.Actions.buildParameter_Number(a);
		}
		else if(typeof a == 'string')
		{
			return Qualtrics.History.Actions.buildParameter_String(a);
		}
				else if(typeof a == 'boolean')
				{
						return Qualtrics.History.Actions.buildParameter_Boolean(a);
				}
		//we cant figure it out so return null as the param
		if(a === undefined)
		{
			return undefined;
		}
		if(a === null)
		{
			return null;
		}
		console.warn('Could not build parameter for arguments', arguments, typeof a);
		return null;
	},
	/**
	 * Qualtrics.History.Actions.buildParameter_ObjectArray
	 **/
	buildParameter_ObjectArray:function(a)
	{
		var param = {};
		param.type = 'Array';
		param.items = [];
		param.qPacked = true;
		for(var i=0,len=a.length; i<len; ++i)
		{
			param.items[i] = Qualtrics.History.Actions.buildParameter(a[i]);
		}
		return param;
	},
	/**
	 * Qualtrics.History.Actions.buildParameter_Object
	 **/
	buildParameter_Object:function(a)
	{
		if(a === null)
		{
			return null;
		}
		var actionPath = a.actionPath || a.self;
		if(actionPath)
		{
			//its a qualtrics object with a path
			var param = {};
			param.type = 'Object';
			param.qPacked = true;
			param.actionPath = actionPath;
			if(a.getInstanceId && a.getInstanceId())
			{
				param.instanceId = a.getInstanceId();
			}
			return param;
		}
		else
		{
			var param = {};
			param.type = 'Object';
			param.qPacked = true;
			param.items = {};
			for(var key in a)
			{
				if(typeof a[key] !== 'function')
					param.items[key] = Qualtrics.History.Actions.buildParameter(a[key]);
			}
			return param;
		}
		return null;
	},
	buildParameter_Number:function(a)
	{
		return a;
	},
	buildParameter_String:function(a)
	{
		return a;
	},
		buildParameter_Boolean:function(a)
		{
				return a;
		},
	/**
	 * Qualtrics.History.Actions.recreateParametersFromDef
	 **/
	recreateParametersFromDef:function(parametersDef)
	{
		var params = [];
		for(var i=0, len=parametersDef.length; i<len; ++i)
		{
			params.push(Qualtrics.History.Actions.recreateParameterFromDef(parametersDef[i]));
		}
		return params;
	},
	/**
	 * Qualtrics.History.Actions.recreateParameterFromDef
	 **/
	recreateParameterFromDef:function(paramDef)
	{
		if(paramDef == null)
		{
			return null;
		}
		if(paramDef == undefined)
		{
			return undefined;
		}
		if(typeof paramDef == 'object')
		{
			if(paramDef.type)
			{
				if(paramDef.type == 'Array')
				{
					var param = [];
					for(var i=0,len=paramDef.items.length; i<len; ++i)
					{
						param.push(Qualtrics.History.Actions.recreateParameterFromDef(paramDef.items[i]));
					}
					return param;
				}
				else if(paramDef.type == 'Object')
				{
					if(paramDef.actionPath)
					{
						var pkg = Qualtrics.Event.getDotSyntaxParts(paramDef.actionPath);
						if(pkg && pkg.root && pkg.callBack)
						{
							var obj = pkg.root[pkg.callBack];
							if(obj.getInstance)
							{
								var instance = obj.getInstance(paramDef.instanceId);
								if(instance)
								{
									//return the instance returned by getInstance
									return instance;
								}
							}
							//return the static object
							return obj;
						}
					}
					else if (paramDef.items)
					{
						if (paramDef.items instanceof Array) //stupid way to make sure it's not an empty array "[]""
							paramDef.items = {};

						var param = {};

						for(var key in paramDef.items)
						{
							param[key] = Qualtrics.History.Actions.recreateParameterFromDef(paramDef.items[key]);
						}
						return param;
					}
				}
			}
		}
		if(typeof paramDef == 'number' || typeof paramDef == 'string' || typeof paramDef == 'boolean')
		{
			return paramDef;
		}
		console.warn('could not recreate parameterDef', paramDef);
		return null;
	},
	/**
	 * Qualtrics.History.Actions.execute
	 **/
	execute:function(actionDef)
	{
		if(actionDef.action)
		{
			var action = actionDef.action;
			var instanceId = actionDef.instanceId;
			var root = null;
			var parameters = null;
			var paramMap = null;
			var defaultParams = null;
			if(actionDef.parameters)
			{
				parameters = Qualtrics.History.Actions.recreateParametersFromDef(actionDef.parameters);
			}
			Qualtrics.Event.executeDotSyntax(actionDef.action, instanceId, root, parameters, paramMap, defaultParams);
		}
	}
};
/***
 * Not Complete-Don't use yet.
 */
Qualtrics.Help = {
	getHelp:function()
	{
		this.generateScreenshot();
		this.popup = new Q_Window(
			{
				id: 'GetHelp',
				title: 'Get Help',
				width:'auto',
				height:'auto',
				closeButton:false,
				buttons:[
					'cancel',
					'save:Qualtrics.Help.getHelp'
				]
			}
		);
		this.content = QBuilder('div',{},[QAjaxWaiter.showBar()]);
		this.popup.setContent(this.content);

	},
	generateScreenshot:function()
	{
		var html = document.documentElement.innerHTML;
		var that = this;
		new Ajax.Request(URLTools.getAjaxURL('generateScreenshot'),{
			parameters:{
				HTML:html
			},
			onSuccess:function(transport)
			{
				var file = transport.responseText;
				var img = QBuilder('img',{width:400, height: 300,src:file});
				that.content.innerHTML = '';
				that.content.appendChild(img);
				that.popup.center();
			}
		});
	}
};
/*
 * This is a rebuilt confirmation dialog. It has most of the features of the old one but is much cleaner.
 * see default options for list of options - defaults are for delete confirmation
 */
Qualtrics.Confirm = Class.create({
	getDefaultOptions:function(){
		return {
			title:getMessage('SiteWide','Delete'),
			confirmButtonText:getMessage('SiteWide','Delete'),
			buttonBusyText:getMessage('SiteWide','Deleting'),
			confirmButtonClassName:'negative',
			confirmButtonIcon:'cancel',
			strong:false,
			contentClassName:'',
			confirmMessage:'Are you sure you wish to delete this item?',
			secondConfirmMessage:'Are you really sure you wish to delete this item?',
			strongConfirmPrompt:getMessage('SiteWide', 'MustEnterDelete', getMessage('SiteWide','ConfirmDelete').toLowerCase()),
			confirmInputText:getMessage('SiteWide','ConfirmDelete').toLowerCase(),
			doubleConfirm:false
		};
	},
	initialize:function(options)
	{
		this.id = QualtricsCPTools.createNewId('QC');
		Qualtrics.Confirm.reg[this.id] = this;
		options = options || {};
		if (typeof(options) == "string")
		{
			options = options.evalJSON();
		}
		this.options = this.getDefaultOptions();
		Object.extend(this.options,options);
		this.show();
	},
	show:function()
	{

		this.popup = new Q_Window(
		{
			id: 'Confirm',
			title: this.options.title,
			width:'auto',
			height:'auto',
			closeButton:true,
			buttons: [
					{icon:'', text:getMessage('SiteWide','Cancel'), click:'Qualtrics.Confirm.confirmationCancel:'+this.id, className:'neutral'},
					{icon:this.options.confirmButtonIcon, text:this.options.confirmButtonText, click:'Qualtrics.Confirm.confirmationComplete:'+this.id, p1:'$evt',  className:this.options.confirmButtonClassName, id:'ConfirmButton'}
				]
		});
		this.popup.setContent(this.build());
	},
	build:function()
	{

		var confirmationForm = this.buildStrongConfirmationForm();

		var contentClass = 'ConfirmationContainer '+(this.options.strong?'strong':'') + ' ' + this.options.contentClassName;

		var contentChildren = [
			QBuilder('div',{className:'ConfirmationWarningGraphic'}),
			QBuilder('div',{className:'rightContainer'},[
				(this.options.strong)?QBuilder('div',{className:'ConfirmationHeader'},getMessage('SiteWide', 'WarningCaption')):'',
				QBuilder('div',{className:'ConfirmationMessage'},[this.options.confirmMessage]),
				(this.options.strong)?confirmationForm:''
			]),
			QBuilder('div',{className:'clear'})
		];
		var content = QBuilder('div',{className:contentClass},contentChildren);
		return content;

	},
	buildStrongConfirmationForm:function()
	{
		this.confirmTextInput = QBuilder('input',{autocomplete: 'off', type:'text', id:'confirmationInput',name:'confirmationInput', className:'TextBox'});
		Event.observe(this.confirmTextInput, 'keydown', this.confirmationCompleteOnEnter.bind(this));
		return QBuilder('div',{id:'deleteConfirmationForm'},[
				QBuilder('div',{className:'StrongConfirmMessage'}, this.options.strongConfirmPrompt),
				this.confirmTextInput
			]);
	},
	confirmationCompleteOnEnter:function(e)
	{
		e = e || window.event;

		if (e.keyCode == Event.KEY_RETURN)
		{
			this.confirmationComplete(e);
			Event.stop(e);
		}
	},
	confirmationCancel:function()
	{
		this.popup.close();
	},
	confirmationComplete:function(e)
	{
		e = e || window.event;

		var skipStrong = false;
		var skipSecond = false;
		if (e.shiftKey && (e.ctrlKey || e.metaKey))
		{
			skipStrong = true;
			skipSecond = true;
		}
		if (this.options.strong)
		{
			if (skipStrong)
			{
				//shortcut for clicking through strong confirms
				Event.stop(e);
			}
			else
			{
				//check for confirmation, you should also check in the ajax call
				var confirmed = this.confirmTextInput.value.toLowerCase();

				if (confirmed != this.options.confirmInputText && confirmed != '"'+this.options.confirmInputText+'"'){
					alert(getMessage('SiteWide','MustConfirmDeletion'));
					return false;
				}
			}


			if (this.options.doubleConfirm && !skipSecond)
			{
				this.popup.close();
				var options = this.options;
				delete(options.doubleConfirm);
				options.strong = false;
				options.confirmMessage = options.secondConfirmMessage;
				new Qualtrics.Confirm(options);
				return;
			}
		}
		if(this.options.onConfirm)
		{
			//console.log(this.options.onConfirm)
			//Ajax Action
			if (this.options.onConfirm.ajax)
			{
				var ajaxOptions = this.options.onConfirm.ajax;
				var action = ajaxOptions.action;
				var parameters = ajaxOptions.parameters;


				if (action)
				{
					var that = this;
					new Ajax.Request(URLTools.getAjaxURL(action),{
						parameters:parameters,
						onComplete:function(transport){
							that.popup.close();

							if (ajaxOptions.onComplete)
							{
								ajaxOptions.onComplete(transport);
							}
						},
						onSuccess:function(transport){

							if (ajaxOptions.onSuccess)
							{
								ajaxOptions.onSuccess(transport);
							}
						}
					});
				}
			}
			else if(Object.isFunction(this.options.onConfirm))
			{
				this.options.onConfirm();
				this.popup.close();
			}
			else if(Object.isString(this.options.onConfirm))
			{
				Qualtrics.Event.executeDotSyntax(this.options.onConfirm);
				this.popup.close();
			}
		}


		var button = $('ConfirmButton');
		if (button)
		{
			$(button).setAttribute('clickcallback','');
			$(button).addClassName('Disabled');
			$(button).innerHTML = this.options.buttonBusyText;
		}
	}
});

Qualtrics.Confirm.reg = {};
Qualtrics.Confirm.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.Confirm.reg);


Qualtrics.Draggable = Class.create({
	initialize:function(el)
	{
		el = $(el);
		if(el.id) //the node must have an id
		{
			Qualtrics.Draggable.reg[el.id] = this;
			new Draggable(el);
		}
	}
});
Qualtrics.Draggable.dragNode = function(el)
{
	if(el.id)
	{
		var instance = Qualtrics.Draggable.getInstance(el.id);
		if(instance)
		{
			//console.log(instance);
		}
		else
		{
			new Qualtrics.Draggable(el);
		}
	}
};
Qualtrics.Draggable.reg = {};
Qualtrics.Draggable.getInstance = QualtricsTools.getInstanceHelper(Qualtrics.Draggable.reg);

/*function DumpObjectIndented(obj, indent)
{
	var result = "";
	if (indent == null) indent = "";

	for (var property in obj)
	{
		var value = obj[property];
		if (typeof value == 'string')
			value = "'" + value + "'";
		else if (typeof value == 'object')
		{
			if (value instanceof Array)
			{
				// Just let JS convert the Array to a string!
				value = "[ " + value + " ]";
			}
			else
			{
				// Recursive dump
				// (replace "  " by "\t" or something else if you prefer)
				var od = DumpObjectIndented(value, indent + "  ");
				// If you like { on the same line as the key
				//value = "{\n" + od + "\n" + indent + "}";
				// If you prefer { and } to be aligned
				value = "\n" + indent + "{\n" + od + "\n" + indent + "}";
			}
		}
		result += indent + "'" + property + "' : " + value + ",\n";
	}
	return result.replace(/,\n$/, "");
}*/

/**
 * Given a JSON string (or an object that can be quickly stringified to JSON), this returns a pretty-printed JSON string.
 *	This will try to use "automatic" formatting supplied by JSON.stringify, but if the json string has errors,
 *		it will fall back to manual formatting using the more forgiving (but slower) jsonlint.
 *
 * @param {string,object} json - JSON string or object that is "stringifiable" to json
 * @return {string} pretty-printed json string
 */
function prettyPrintJson(json)
{
	var prettyJson = "";
	var indent = "    ";

	if (json && typeof json !== "string")
	{
		prettyJson = JSON.stringify(json, null, indent);
	}
	else
	{
		try //if the JSON is valid, just parse and re-stringify it with formatting
		{
			var parsed = JSON.parse(json);
			prettyJson = JSON.stringify(parsed, null, indent);
		}
		catch (e) //if it's not valid, we have to use the jsonlint formatter to get something usable
		{
			QModules.loadModule("jsonlint.js");
			prettyJson = window.jsl.format.formatJson(json);
		}
	}

	return prettyJson || "";
}

/**
 *
 * Ajax Messaging
 *
 * This should be refactored so all of the global functions reside inside of the AjaxMessaging object.
 *
 **/
var messageFadeTimer = null;
var MessageFade = null;
var PermaMessage = false;
function PermaMessageBox()
{
	HoldMessageBox();
	if(PermaMessage)
	{
		$('MessageBox').setStyle({opacity:0.9});
	}
	PermaMessage = !PermaMessage;
}
function HoldMessageBox()
{
	clearTimeout(messageFadeTimer);
	if(MessageFade)
		MessageFade.cancel();
	$('MessageBox').setStyle({opacity:1});
}
function ReleaseMessageBox(time)
{
	if(typeof time != 'number')
	{
		/* sometimes things pass events in here*/
		time = false;
	}
	if(!time)
	{
		time= 1000;
	}
	if(!PermaMessage)
	{
		$('MessageBox').setStyle({backgroundColor:''});
		$('MessageBox').setStyle({opacity:0.90});
		messageFadeTimer = setTimeout(HideMessage, time);
	}
}
/**
* an alias for quickies
* @param String id - if you want the message to only appear once or replace another message use the same id
*/
function msg(str, id, limit)
{
	ShowMessageStr(str, id, limit);
}
/**
* This is for sending a message directly from javascript (no ajax)
* @param String id - if you want the message to only appear once or replace or be replaced by another message, then use the same id for all the messages
*/
function ShowMessageStr(str, id, limit){

	var json = {"message":[{msg:str}]};
	if(id)
	{
		json = {"message":[{id:id, msg:str}]};
	}
	ShowMessage(json, null, limit);
}

function ShowMessage(json, obj, limit){

	if(limit === undefined)
	{
		limit = 2;
	}

	if(json)
	{
		var msgDom = $('MessageBox');
		if(!msgDom) return;
		// when reading this keep in mind that messages and debugs can both come through together in the same packet
		var msg = json.message;
		var debug = json.debug;
		if(json.message){
			for(var i=0,len=msg.length; i<len; ++i){
				var inside = QBuilder('div',{className:'message'}, msg[i]['msg']);
				var id = msg[i]['id'];
				if(id){
					//remove the existing element
					if($('msgId_'+id))
					{
						removeElement($('msgId_'+id));
					}
					$(inside).id = 'msgId_'+id;
				}
				if(msgDom.childNodes.length > limit){
					removeElement(msgDom.firstChild);
				}
				msgDom.appendChild(inside);
				inside = null;
			}
		}
		if(!QualtricsCPTools.hideDebugs)
		{
			if(json.debug)
			{
				for(var i=0,len=debug.length; i<len; ++i)
				{
					var inside = constructDebugData(debug[i], false);
					msgDom.appendChild(inside);
					inside = null;
				}
			}
			if(json.debugHtml){
				var debugHtml = json.debugHtml;
				for(var i=0,len=debugHtml.length; i<len; ++i)
				{
					var inside = constructDebugData(debugHtml[i], true);
					msgDom.appendChild(inside);
					inside = null;
				}
				debugHtml=null;
			}
		}
		if(MessageFade){
			MessageFade.cancel();
		}
		clearTimeout(messageFadeTimer);
		msgDom.show();
		ReleaseMessageBox(500);
		msg=null;
		debug=null;
	}
}

function constructDebugData(msg, showHtml)
{
	try
	{
		if(msg['label'])
		{
			var inside = QBuilder('div',{ className:"debug"});
			inside.onmouseover = function() { AddOver(this); };
			inside.onmouseout = function() { RemoveOver(this); };

			var label = QBuilder('p', msg['label'] + ' \u21B5');
			if (showHtml)
			{
				var content = QBuilder('pre', {ignoreMsgClick: '0'});
				content.innerHTML = msg['msg'];
			}
			else
			{
				var content = QBuilder('pre', {ignoreMsgClick: '0'}, msg['msg']);
			}

			var hideFlag = QBuilder('div', {className:"HiddenDebug"},[
				label,
				content
			]);
			inside.appendChild(hideFlag);
			hideFlag = null;
			label = null;
			content = null;
			return inside;
		}
	}
	catch(e)
	{

	}
	var inside = QBuilder('div',{ className:"debug"},
	[
		QBuilder('pre',msg)
	]);
	return inside;
}

function HideMessage(instant)
{
	if(MessageFade){
		MessageFade.cancel();
		MessageFade = null;
	}
	if(instant){
		clearTimeout(messageFadeTimer);
		$('MessageBox').setStyle({display:'none'});
		deleteChildren($('MessageBox'));
	}
	if(typeof Effect != 'undefined')
	{
		MessageFade = new Effect.Fade($('MessageBox'),
		{
			duration:2,
			from: 0.9, to: 0,
			afterFinish:function(){

				$('MessageBox').setStyle({display:'block'});
				$('MessageBox').setStyle({opacity:1});

				deleteChildren($('MessageBox'));
				MessageFade = null;
			}
		});
	}
}

/**
 * Q_Window
 * this is a streamlined replacement for the prototype windows class.
 * It should work roughly the same way. be a lot smaller, faster. and have better features that we actually need, like no scroll bars, and auto centering updates.
 * @author oliverh@qualtrics.com
 */
window.Q_Window = Class.create();
Q_Window._chopOffset = null;
/**
 * in firefox, in order to remove the scroll bars we have to set the top of 'pageDiv' to be whatever the scroll was.
 * so getChopOffset helps you compensate for the weirdness.
 * @return {Array || null} - what the scroll used to be.
 **/
Q_Window.getChopOffset = function()
{
	//TODO fix me for firefox
	if(parent) //go to the root if we are in an iframe
	{
		try
		{
			return parent.Q_Window._chopOffset;
		}
		catch(e)
		{
		}
	}
	return Q_Window._chopOffset;
};
/**
 * offsets a position (probably from something like Position.cumulativeOfset) and offsets it with the choppOffset numbers.
 * sometimes you need this and sometimes you dont depending on what you are using cumulative offset for.
 * for example: if you are following the cursor you wouldnt need it. but if you are matching positions with an existing element on the page you would need to offset.
 */
Q_Window.preparePos = function(pos)
{
	var offset = Q_Window.getChopOffset();
	if(offset && pos && pos.length == 2)
	{
		if(offset[0]) pos[0] = pos[0] - offset[0];
		if(offset[1]) pos[1] = pos[1] - offset[1];
	}
	return pos;
};
Q_Window.registry = {};
Q_Window.openedOrder = [];
Q_Window.getWindowCount = function()
{
	var reg = Q_Window.getRegistry();
	var count = 0;
	for (var id in reg)
	{
		count++;
	}
	return count;
};
Q_Window.getInstance = function(id)
{
	var reg = Q_Window.getRegistry();
	if(id)
	{
		if (reg[id])
			return reg[id];

		//if no matching name then lets search the internal id we can search based on window name
		var namedWindow = Q_Window.getInstanceByWindowName(id);
		if(namedWindow) return namedWindow;
	}
	else
	{
		//they havent defined a window so we need to choose one for them.
		//we will pick instances in the in the reverse order that they were opened.
		for(var i = Q_Window.openedOrder.length-1; i>=0; --i)
		{
			if(reg[Q_Window.openedOrder[i]])
			{
				return reg[Q_Window.openedOrder[i]];
			}
		}
		//something has gone wrong so lets just return whatever? should never get here.
		for (id in reg)
			return reg[id];
	}

	return null;
};

Q_Window.getInstanceByWindowName = function (windowName)
{
	var reg = Q_Window.getRegistry();
	var foundInstances = [];
	for (id in reg)
	{
		if (reg[id].windowName == windowName)
		{
			foundInstances.push(reg[id]);
		}
	}

	if (foundInstances.length == 1)
	{
		return foundInstances[0];
	}
	else if (foundInstances.length > 1)	// We have more than a single instance of this window open at the same time
	{
		//Return the one with the highest zIndex (the window on top)
		var highestZIndex = -1;
		var highestZIndexInstance = null;
		for (var i=0; i < foundInstances.length; i++)
		{
			if (foundInstances[i].zIndex > highestZIndex)
			{
				highestZIndex = foundInstances[i].zIndex;
				highestZIndexInstance = foundInstances[i];
			}
		}
		return highestZIndexInstance;
	}

	return false;
};

Q_Window.getRegistry = function(id)
{
	var reg = Q_Window.registry;
	reg = Q_Window.registry;
	return reg;
};
/** @deprecated doesn't work when Qualtrics is inside an iframe */
Q_Window.getRoot = function()
{
	var root = window;
	var last = window;
	try
	{
		var limit = 0;
		while (root.parent && limit < 10)
		{
			root.name; //try to access a property of the window (if permission denied it will throw an exception)
			if (root.parent == root)
				break;
			last = root;
			root = root.parent;
			limit++;
		}
	}
	catch(e)
	{
		return last;
	}

	return root;
};
Q_Window.setRegistry = function(windowObj)
{
	Q_Window.registry[windowObj.id] = windowObj;
	Q_Window.openedOrder.push(windowObj.id);
};
Q_Window.removeFromRegistry = function(id)
{
	delete Q_Window.registry[id];
};
Q_Window.isRegistryEmpty = function()
{
	for (el in Q_Window.registry)
	{
		return false;
	}
	return true;
};
Q_Window.getWindow = function(windowName)
{
	return Q_Window.getInstance(windowName);
};
Q_Window.closeWindow = function(windowName)
{
	var inst = Q_Window.getInstance(windowName);
	if (inst)
		inst.destroy();
};
Q_Window.closeAllWindows = function(windowName)
{
	if(windowName)
	{
		var inst = Q_Window.getInstanceByWindowName(windowName);
		while (inst)
		{
			inst.destroy();
			inst = Q_Window.getInstanceByWindowName(windowName);
		}
	}
	else
	{
		while(Q_Window.getInstance())
			Q_Window.getInstance().destroy();
	}
};
Q_Window.addObserver = function(windowName)
{
	//maintain compatibility with prototype.windows
};

Q_Window.resizeWatcher = null;//we only have 1 resize observer because if we make a new one for every window we open it will get leaky
Q_Window.centerTimer = null;//this is to prevent from resizing too often cause safari hates it.
/**
 * Q_Window.centerWindows
 * centers all the open windows that need centering
 */
Q_Window.centerWindows = function()
{
	if(Q_Window.centerTimer)
	{
		clearTimeout(Q_Window.centerTimer);
		Q_Window.centerTimer = null;
	}
	Q_Window.centerTimer = setTimeout(function(){
		var reg = Q_Window.getRegistry();
		for(id in reg)
		{
			if(reg[id].keepCentering)
			{
				reg[id].center();
			}
		}
	},50);
};


Q_Window.setChopOffset = function(v)
{
	Q_Window._chopOffset = v;
};

//creates the function, and executes it initially
(Q_Window.resetZIndex = function() {
	Q_Window.currentZIndex = 10001;
})();

//gets the next zindex (increment of 100)
Q_Window.getNextZIndex = function()
{
	Q_Window.currentZIndex += 100;
	return Q_Window.currentZIndex;
};
Q_Window.setCurrentZIndex = function(z)
{
	Q_Window.currentZIndex = z;
};
Q_Window.getCurrentZIndex = function()
{
	return Q_Window.currentZIndex;
};
/**
 * static Q_Window.getInstanceOrCreate
 * will return an existing one or create a new one. like a singleton.
 */
Q_Window.getInstanceOrCreate = function(windowName, options)
{
	var win = Q_Window.getInstanceByWindowName(windowName);
	if(win && options && options.buttons !== undefined)
	{
		//you can change the button set, or set options.buttons to false to clear existing buttons
		if(win.footerNode)
		{
			deleteChildren(win.footerNode);
			if(options.buttons)
			{
				win.footerNode.appendChild(win.buildButtons(options.buttons));
			}
		}
	}
	if(!win)
	{
		win = new Q_Window(windowName, options);
	}
	return win;
};

/**
* Q_Window
*
*Options:
* @param {Bolean} options.overlayClose - if true will close the window on the overlay click.
* @param {Boolean} options.closeButton - if true will show an x in the top right.
* @param {String} options.className - the class name for the content containing div
* @param {String|Node|Array} options.title - if you give a title, a header will be made with your title text. Passing in an array gives you the most control over the title. you must make your own h2 pass an array
* @param {string} options.url - url for an iframe popup
* @param {Array} options.buttons - an array containing objects containing info about the buttons you want in the footer, which will now be created. eg:
	buttons:[
				{icon:'cancel', text:'Cancel', click:'Q_Window.closeWindow'},
				{icon:'check', text:'Save Flow', click:'Q_SurveyFlow.saveFlow'},
				{icon:'check', text:'Flow Options', click:'Q_SurveyFlow.flowOptions', align:'left'},
				{icon:'check', text:'Positive', click:'Q_SurveyFlow.flowOptions', id: 'positive', className: 'positive'}
			]
*/
Q_Window.prototype = {
	width:'600px', //the width of the contents
	height:'auto', // the height of the contents
	element:null, //the window dom node.
	headerDom:null, //the header dom node if it exists.
	innerElement:null,
	className:'', // classname of the popup
	url:null, //url of the contents
	windowName:null, //this is the id that you can assign.
	id:null, //this is the auto generated random id.
	keepCentering:false, //automatically
	buttons:null, //array of buttons
	title:null, //if specified the title shows in a header frame
	pctHeight:null, //the percentage height the window can be before scroll bars are used
	pctWidth:null, //the percentage width the window can be before scroll bars are used
	preservePctHeightAndWidth:false, //if true, preserves pctHeight and pctWidth while the Q_Window is open
	closeButton:false, // if true the 'X' is added to the header
	fitContents:false, // the window will scale to the size of the contents
	padding:null, //amount of padding to put on elements contained in the popup
	zIndex:10000, //overrides the window's css z-index
	autoWidth:false,
	autoHeight:true,
	buttonReg:{},
	initialize:function(windowName, options, var_args)
	{
		this.initTime = new Date();
		this.id = QualtricsTools.createNewId('QW');

		if(arguments.length == 1 && typeof windowName == 'object')
		{
			options = windowName;
			//assume options in the only param
			options.id = options.id || this.id;
			this.windowName = options.id;
			if(options.id)
			{
				//maintain compatibility with prototype.windows
				this.className = options.id;
			}
		}
		else
		{
			this.windowName = windowName;
			this.className = windowName; //you can override this by setting className in the options.
		}

		options = options || {};
		this.options = options; //so we can evaluate options throughout the class

		for(var option in options)
		{
			if(option != 'id')
				this[option] = options[option];
		}
		if (this.skeleton)
			this.className += ' Skeleton';
		if (this.hidden)
			this.className += ' Hide';

		Q_Window.setRegistry(this);

		var startZIndex = Q_Window.getCurrentZIndex();
		this.setSize(this.width,this.height,false);

		if(options && options.zIndex)
		{
			//if they have specified a zindex then use it
			this.zIndex = options.zIndex;
		}
		else
		{
			//use the next default zIndex
			this.zIndex = Q_Window.getNextZIndex();
		}

		//update the currentZIndex so that any child windows will be on top.
		this.zDiff = this.zIndex - startZIndex;
		Q_Window.setCurrentZIndex(this.zIndex);

		if(!options.buttons && options.closeButton === undefined)
		{
			options.closeButton = true;
		}
		this.render();
        if(!options.enableScroll)
            this.disableScroll();
		//this.center();
		this.focusInput();
		if(options.content)
		{
			this.setContent(options.content);
		}

	},
	focusInput:function(opt_node)
	{
		var inputs = (opt_node||this.innerElement).getElementsByTagName('INPUT');
		if(inputs)
		{
			for(var i = 0, len=inputs.length; i<len; ++i)
			{
				var type = inputs[i].getAttribute('type');
				if((type == 'text') && (!inputs[i].disabled))
				{
					Form.Element.focus(inputs[i]);
					break;
				}
			}
		}
	},
	getFocusInputFunction:function(iframe)
	{
		var that = this;
		return function()
		{
			if (that.hasBeenFocused)	//Only run once on the first load or IE7 complains
			{
				return function(){};
			}

			that.hasBeenFocused = true;
			try
			{
				that.focusInput(iframe.contentDocument||iframe.contentWindow.document);
			}
			catch (e)
			{
			}
		};
	},
	build:function()
	{
		this.innerElement = QBuilder('div',{id:this.id, className:'Q_Window PopUp'});
		if(this.options.id)
		{
			this.innerElement.id = this.options.id;
		}
		if(this.options.onScroll)
		{
			var that = this;
			Event.observe(this.innerElement, 'scroll', function(evt){
				Qualtrics.Event.executeDotSyntax(
					that.options.onScroll,
					null,
					null,
					null,
					{
						'$evt':evt,
						'$scrollTop':that.innerElement.scrollTop,
						'$scrollLeft':that.innerElement.scrollLeft
					},
					null
				);
			});

		}
		if(this.stylesheet)
		{
			QModules.loadStylesheet(this.stylesheet);
		}
		this.element = QBuilder('div',{className:'Q_WindowBorder '+this.className, id:'Q_Window_'+this.id});
		this.element.div = QBuilder('div');
		if(this.tabs)
		{
			this.element.appendChild(this.buildTabs());
		}
		this.element.appendChild(this.element.div);
		if(this.title)
		{
			this.headerDom = QBuilder('div',{className:'Q_WindowHeader'},[this.buildTitle(this.title,{closeButton:this.closeButton})]);
			this.element.div.appendChild(this.headerDom);
		}
		else if (this.headerDom)
		{
			this.element.div.appendChild(this.headerDom);
		}

		// add a message banner
		if (this.options.banner)
		{
			this.element.div.appendChild(QBuilder('span', {className:'Q_WindowBanner'}, this.options.banner));
		}
		var innerContainer = this.innerElement;
		if(this.options.bottomFade)
		{
			innerContainer = QBuilder('div',{className:'InnerContainer'},[
				this.innerElement
			]);
			innerContainer.appendChild(QBuilder('div',{className:'BottomFade'}));
			$(this.innerElement).addClassName('HasBottomFade');
		}
		this.element.div.appendChild(innerContainer);
		if(this.options && this.options.closeButton && !this.title)
		{
			this.element.div.appendChild(QBuilder('div',{clickcallback:'Q_Window.destroy', instanceid:this.id, className:'Q_WindowClose'}));
		}

		//$(this.innerElement).setStyle({width:this.width, height:this.height}); //took this out since I assume it will be called with setcontent

		if(this.url)
		{
			var scrolling = 'no';
			//default to no iframe scroll bars cause they are ugly and usually not needed.
			if (this.options.iframescrolling)
			{
				scrolling = 'auto';
			}
			var iframe = QBuilder('iframe',
			{
				className: 'Q_WindowFrame',
				frameBorder: '0',
				scrolling: scrolling,
				src: this.url
			});
			var waiter = QAjaxWaiter.showMediumRing();
			$(iframe).hide();
			this.innerElement.appendChild(waiter);
			this.innerElement.appendChild(iframe);
			var that = this;

//			OH:I need to take this out because it is crashing firefox
//			I think it is ok if I take this out since we have it happening with the function.defer
//			iframe.src = that.url;

			(function()
			{
				if (Qualtrics.Browser.IE && Qualtrics.Browser.Version > 7)
				{
					//Start the iframe shown for stupid browsers, or IE8+ will not show the content; fixes Library Survey Preview in IE9 bug not showing preview
					iframe.show();
				}
				iframe.src = that.url;
				Event.observe(iframe, 'load', function(){
					$(iframe).show();
					$(waiter).hide();
					that.getFocusInputFunction(iframe);
					Q_Window.centerWindows();
					if(iframe.contentDocument && iframe.contentDocument.body && $(iframe.contentDocument.body).addClassName)
					{
						$(iframe.contentDocument.body).addClassName('iframe');
					}
				});
			}).defer();

			var frameHeight = '100%';
			var frameWidth = '100%';

			if (this.options.frameHeight)
				frameHeight = this.options.frameHeight;
			if (this.options.frameWidth)
				frameWidth = this.options.frameWidth;
			$(iframe).setStyle(
			{
				width: frameWidth,
				height: frameHeight,
				border: 'none',
				marginBottom: '-3px'
			}); //marginBottom:'-3px' helps with conjoints iframe scrollbars in safari.


			this.iframe = iframe;
			this.setSize(this.width, this.height);
		}
		if(this.ajaxUrl)
		{
			new Ajax.Updater(this.innerElement, this.ajaxUrl);
			this.setSize(this.width,this.height);
		}

		if (!this.noFooter || this.buttons)
		{
			this.footerNode = QBuilder('div', {className:'Q_WindowFooterContainer'});
			this.element.div.appendChild(this.footerNode);
			if(this.buttons)
			{
				this.footerNode.appendChild(this.buildButtons(this.buttons));
			}
		}

		if (this.padding !== null)
		{
			this.innerElement.style.padding = this.padding+'px';
		}
		if (this.zIndex !== null)
		{
			$(this.element).setStyle({zIndex:this.zIndex});
		}
		//this.setupDraggable.bind(this).defer();

		if (this.minHeight)
		{
			$(this.innerElement).setStyle({minHeight:this.minHeight});
		}
		if (this.minWidth)
		{
			$(this.innerElement).setStyle({minWidth:this.minWidth});
		}

		return this.element;
	},
	buildTabs:function()
	{
		this.tabsContainer = QBuilder('div',{className:'TabsContainer'},[this.buildTabsInner()]);
		return this.tabsContainer;
	},
	buildTabsInner:function()
	{
		var tabsContainer = document.createDocumentFragment();
		for(var i=0,len=this.tabs.length; i<len; ++i)
		{
			var className = ' NotSelected';
			if(this.currentTab == this.tabs[i].name)
			{
				className = ' Selected';
			}
			tabsContainer.appendChild(QBuilder('a',{
				className:'Q_WindowTab'+className,
				downcallback:this.getSelfFunction('switchTab', this.tabs[i].name, this.tabs[i].action)
			},[
				this.tabs[i].display
			]));
		}
		tabsContainer.appendChild(QBuilder('div',{className:'clear'}));
		return tabsContainer;
	},
	redrawTabs:function()
	{
		deleteChildren(this.tabsContainer);
		this.tabsContainer.appendChild(this.buildTabsInner());
	},
	switchTab:function(tabName, action)
	{
		this.currentTab = tabName;
		//I dont like it when the window gets smaller, so make sure it only changes if it gets bigger
		var curHeight = this.innerElement.offsetHeight;
		$(this.innerElement).setStyle({height:curHeight+'px'});
		this.minHeight = curHeight;
		this.redrawTabs();
		Qualtrics.Event.executeDotSyntax(action);
	},

	getCurrentTab:function()
	{
		return this.currentTab;
	},
	getSelfFunction:function(var_args)
	{
		return Qualtrics.Event.getSelfFunction('Q_Window', this.id, arguments);
	},
	setupDraggable:function()
	{
		new Draggable(this.element,{handle:this.headerDom,onStart:function(el){$(el.element).setStyle({zIndex:200000000})}});
	},
	updateHeader:function(domNode)
	{
		deleteChildren(this.headerDom);
		this.headerDom.appendChild(domNode);
	},
	buildButtons:function(buttonsArray)
	{
		var footer = QBuilder('div', {className:'Q_WindowFooter'});
		this.leftFooterArea = QBuilder('div', {className:'LeftButtons'});
		this.rightFooterArea = QBuilder('div', {className:'RightButtons'});
		for(var i=0, len=buttonsArray.length; i<len; ++i)
		{
			if(buttonsArray[i] && buttonsArray[i].align && buttonsArray[i].align == 'left')
			{
				this.leftFooterArea.appendChild(this.buildButton(buttonsArray[i]));
			}
			else
			{
				this.rightFooterArea.appendChild(this.buildButton(buttonsArray[i]));
			}
		}
		footer.appendChild(this.leftFooterArea);
		footer.appendChild(this.rightFooterArea);
		return footer;
	},
	buildTitle:function(title,options)
	{
		options = options || {};
		var h2 = QBuilder('h2');
		var bundle = [h2];
		if(typeof title == 'string')
		{
			h2.innerHTML = title;
			bundle = [h2];
		}
		else if(typeof title.push == 'function') //isarray
		{
			//passing in an array gives you the most control over the title. you must make your own h2 if you want an h2
			bundle=title;
		}
		else
		{
			h2 = QBuilder('h2', null, [title]);
			bundle = [h2];
		}
		var inner = QBuilder('div', {className:'Q_WindowHeaderInner'}, bundle);
		var header = QBuilder('div', {},[
			inner
		]);
		if (options.closeButton && (this.options.forceCloseButton || !this.options.buttons || (this.options.buttons && this.options.buttons.length < 2)))
		{
			header.appendChild(QBuilder('div',{clickcallback:'Q_Window.closeWindow',p1:this.windowName, instanceId:this.id,className:'Q_WindowCloseSQ'},[QBuilder('div',{bubbleup:true,className:'Q_WindowCloseSQInner'})]));
		}

		if(this.options.draggable)
		{
			inner.setAttribute('downcallback','Qualtrics.Draggable.dragNode(Q_Window_'+this.id+')');
			$(inner).addClassName('Draggable');
			h2.setAttribute('downcallback','Qualtrics.Draggable.dragNode(Q_Window_'+this.id+')');
			$(h2).addClassName('Draggable');
		}
		return header;
	},
	buildIframeCover:function()
	{
		this.iFrameCover = QBuilder('iframe',{className:'Q_WindowIframeCover', src:'/WRQualtricsShared/blank.html'});
		var windowHeight = window.innerHeight;
		if (!windowHeight || windowHeight == 0)
			windowHeight = document.body.clientHeight;

		$(this.iFrameCover).setStyle({opacity:0, zIndex:this.zIndex-2, backgroundColor:'blue', position:'absolute', left:'1px', top:'0px', width:'100%', height:windowHeight+'px'});
		return this.iFrameCover;
	},
	disableScroll:function()
	{
		if ($('pageDiv'))
		{
			if (!document.body.scrollDisabled)
			{
				var scrollInfo = QualtricsTools.getScrollInfo();
				var xscroll = 0-scrollInfo[0];
				var yscroll = 0-scrollInfo[1];

				$(document.body).setStyle({overflow:'hidden'});

				var scrollBarWidth = this.getScrollBarWidth();
				//all browsers: compensate for the missing scrollbar
				if(scrollBarWidth)
				{
					scrollBarWidth += 'px';
					//if there are scrollbars then put a margin so the page doesnt jump over
					$(document.body).setStyle({marginRight:scrollBarWidth});
				}
				document.body.scrollDisabled = true;

				//if we need to do something else once we disable the scroll
				if (this.onDisableScroll)
				{
					this.onDisableScroll(scrollBarWidth);
				}
			}
		}
	},
	enableScroll:function()
	{
		if ($('pageDiv'))
		{
			var chopped = Q_Window.getChopOffset();
			var x = chopped && chopped[0] || 0;
			var y = chopped && chopped[1] || 0;

			$(document.body).setStyle({overflow:'visible'});
			$(document.documentElement).setStyle({overflow:'visible'});

			$(document.body).setStyle({marginRight:'0px'});
			$('pageDiv').setStyle({position:'', top:'', left:''});
			if(y || x)
			{
				var scrollY = 0-(Number(y));
				var scrollX = 0-(Number(x));
				if(scrollY || scrollX)
				{
					window.scrollTo(scrollX, scrollY);
				}
			}
			Q_Window.setChopOffset(null);
			document.body.scrollDisabled = false;
			document.body.scrollTop = document.body.scrollTop+1;
			document.body.scrollTop = document.body.scrollTop-1;

			//If we need to do something else once we enable the scroll
			if (this.onEnableScroll)
			{
				this.onEnableScroll();
			}
		}
	},
	getScrollBarWidth:function()
	{
		// Create the measurement node
		var scrollDiv = QBuilder('div', {style:"width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;"});
		document.body.appendChild(scrollDiv);

		// Get the scrollbar width
		var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

		// Delete the DIV
		document.body.removeChild(scrollDiv);
		return scrollbarWidth;
	},
	render:function()
	{
		if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 7)
		{
			document.body.appendChild(this.buildIframeCover());
		}
		var overlayOptions = {zIndex:this.zIndex-1, id:this.windowName};
		if(this.options.overrideOverlayWidth)
		{
			var scrollOffsets = document.viewport.getScrollOffsets();
			overlayOptions.dim = {width:scrollOffsets[0]+document.body.scrollWidth+'px'};
		}
		if(this.options.overlayOpacity !== undefined)
		{
			overlayOptions.opacity = this.options.overlayOpacity;
		}
		if(window.Q_Overlay && !this.options.hideOverlay)
		{
			if(this.overlayClose)
			{
				this.overlayObj = new Q_Overlay(Object.extend(overlayOptions, {onClick:this.getCloseFunction()}));
			}
			else
			{
				this.overlayObj = new Q_Overlay(overlayOptions);
			}
		}
		document.body.appendChild(this.build());
		this.center();
	},
	getResizeOffset:function(axis)
	{
		var defaultOffset = 80;
		if(axis == 'y')
		{
			var offset = 90;
			if (this.title) offset+=defaultOffset;
			return offset;
		}
		return defaultOffset;
	},
	/**
	 * Dont let the dimention get bigger than the browser
	 **/
	getForcedDimensionPreserveScroll:function(axis, max)
	{
		var axisString = 'width';
		if(axis == 'y') axisString = 'height';
		var offset = this.getResizeOffset(axis);
		var innerInnerDim = {width:this.innerElement.scrollWidth, height:this.innerElement.scrollHeight};
		if(innerInnerDim[axisString] > max-offset)
		{
			if (!this.options.disableOverflowScrolling)
			{
				this.innerElement.style['position'] = 'relative';
				this.innerElement.style['overflow'+axis.capitalize()] = 'auto';
			}
			return max-offset+'px';
		}
		return false;
	},
	/** This resizes the window to the current contents */
	resize:function()
	{
		var newHeight, newWidth;
		if(window.QualtricsTools)
		{
			var windowSize = QualtricsTools.getPageSize();
			var previousScrollTop = 0;
			//if pctHeight or pctWidth is set then we are going to set the dimensions as
			//a percentage of the total window size
			if (this.pctHeight || this.pctWidth)
			{
				if (this.pctHeight)
				{
					newHeight = String(Math.round(this.pctHeight * windowSize[3]-80));
				}
				if (this.pctWidth)
				{
					newWidth = String(Math.round(this.pctWidth * windowSize[2]));
				}
			}
			if(!this.pctHeight)//just so we dont waste cpu
			{
				if (this.autoHeight)
				{
					//store the current scrollTop so we can preserve it
					previousScrollTop = this.innerElement.scrollTop;
					$(this.innerElement).setStyle({height:'auto'});
					if(this.minHeight && this.innerElement.offsetHeight < this.minHeight)
					{
						$(this.innerElement).setStyle({height:this.minHeight+'px'});
					}
				}
				//make sure it doesnt go beyond the window boundries
				var forcedHeight = this.getForcedDimensionPreserveScroll('y', windowSize[3]);
				if(forcedHeight)
				{
					newHeight = forcedHeight;
				}
			}
			if(!this.pctWidth)//just so we dont waste cpu
			{
				if (this.autoWidth)
				{
					$(this.innerElement).setStyle({width:'auto'});
					if(this.minWidth && this.innerElement.offsetWidth < this.minWidth)
					{
						$(this.innerElement).setStyle({width:this.minWidth+'px'});
					}
				}
				var forcedWidth = this.getForcedDimensionPreserveScroll('x', windowSize[2]);
				if(forcedWidth)
				{
					newWidth = forcedWidth;
				}
			}
			//this will set the defaults if no changes need to be made
			newHeight = newHeight || this.height;
			newWidth = newWidth || this.width;

			//set the final calculated dimensions.
			if(newHeight && newHeight != 'auto' && newHeight.startsWith && !newHeight.startsWith('-'))
			{
				var h = newHeight;
				if(!String(h).endsWith('px'))
				{
					h+='px';
				}
				$(this.innerElement).setStyle({height:h});
				if(previousScrollTop)
				{
					this.innerElement.scrollTop = previousScrollTop;
				}
			}
			if(newWidth && newWidth != 'auto' && newWidth.startsWith && !newWidth.startsWith('-'))
			{
				var w = newWidth;
				if(!String(w).endsWith('px'))
				{
					w+='px';
				}

				$(this.innerElement).setStyle({width:w});
			}

			this.calculatedHeight = newHeight;
			this.calculatedWidth = newWidth;

			if (this.options.onResize)
				this.options.onResize();
		}
	},
	setupEvents:function()
	{
		Event.observe(document, 'keypress', this.keyPress);
	},
	destroyEvents:function()
	{
		Event.stopObserving(document, 'keypress', this.keyPress);
	},
	keyPress:function(evt)
	{
		if(evt.keyCode == Event.KEY_ESC)
		{
			Q_Window.closeWindow();
		}
	},
	/**
	 * alias for Q_Window.destroy()
	 */
	close:function()
	{
		this.destroy();
	},
	/**
	* Q_Window.destroy
	* closes and cleans up the window.
	* @param {Boolean} opt_enabledScroll - optional. give it false if you dont want the scroll bars back. defaults to true.
	*/
	destroy:function(opt_enableScroll)
	{
		if(this.element)
		{
			if(this.onClose)
			{
				try
				{
					//this will execute a raw function or a dotsyntax expression
					if(Qualtrics.Event.execute(this.onClose) === false)
					{
						//prevent window from closing if onClose returns false
						//return true from onClose to close the window
						return false;
					}
				}
				catch(e)
				{
					console.log('Error in onclose event', e);
				}
			}
			this.destroyEvents();
			Q_Window.removeFromRegistry(this.id);
			if(this.contentParent)
			{
				this.contentParent.appendChild(this.content);
			}
			this.content = null;

			removeElement(this.element);
			this.element = null;
			if(this.iFrameCover)
			{
				removeElement(this.iFrameCover);
				this.iFrameCover = null;
			}
			if (this.overlayObj)
			{
				this.overlayObj.remove();
			}

			if (Q_Window.isRegistryEmpty())
			{
				if((opt_enableScroll || opt_enableScroll === undefined))
				{
					//this brings back the scroll bars.
					this.enableScroll();
				}
				Q_Window.resetZIndex();
			}
			//this window popped up above another
			else if (this.zDiff && this.zDiff > 0)
			{
				var currentZIndex = Q_Window.getCurrentZIndex();

				//this is the top window
				if (this.zIndex >= currentZIndex)
					Q_Window.setCurrentZIndex(currentZIndex-this.zDiff);
			}

			if(this.keepingCentered)
			{
				window.onresize = null;
			}

			if(this.headerDom)
			{
				this.headerDom = null;
			}

			return true;
		}
	},
	transformIntoLoading:function()
	{
		$(this.innerElement).setStyle({
			width:this.innerElement.offsetWidth+'px',
			height:this.innerElement.offsetHeight+'px',
			padding:0
		});
		this.showLoading();
		new Effect.Morph(this.innerElement,{
			transition:INQUAD,
			duration:0.3,
			style:{
				height:'60px',
				width:'350px'
			},
			afterUpdate:this.center.bind(this, null, false)
		});
	},
	showLoading:function()
	{
		deleteChildren(this.innerElement);
		var loading = QBuilder('div',{className:'candyBarLoadingImage'});
		$(loading).setOpacity(0);
		this.innerElement.appendChild(loading);
		new Effect.Opacity(loading, {
	      from: 0.0,
	      to: 1.0,
	      duration: 0.5
	   });
	},
	getCloseFunction:function()
	{
		var that = this;
		return function()
		{
			that.destroy();
		};
	},
	appendChild:function(node)
	{
		this.innerElement.appendChild(node);
	},
	setContent:function(node)
	{
		if(!node) return;
		if(typeof node == 'string')
		{
			node = QBuilder('div',null,[node]);
		}

		this.content = node;
		if (node.parentNode)
		{
			this.contentParent = node.parentNode;
		}
		this.clear();
		this.appendChild(node);

		$(node).show();
		this.setSize(this.width,this.height,false);
		this.center();
	},
	morphContent:function(options)
	{
		options = options || {};
		//allow content to take the place of options as the first param
		if(!options.content) options.content = options;
		if(options.content)
		{
			deleteChildren(this.innerElement);
			this.setContent(options.content);
			this.center();
		}
	},
	scrollBottom:function()
	{
		if (this.innerElement)
		{
			this.innerElement.scrollTop = this.innerElement.scrollHeight;
		}
	},
	scrollTop:function()
	{
		if (this.innerElement)
		{
			this.innerElement.scrollTop = 0;
		}
	},
	getContent:function()
	{
		return this.innerElement;
	},
	clear:function()
	{
		deleteChildren(this.getContent());
	},
	/**
	 * @param {window} parentWindowObj - this is not a qwindow but a browser window.
	 **/
	setIframeParent:function(parentWindowObj)
	{
		this.iframeParent = parentWindowObj;
	},
	/**
	* Q_Window.center
	* this is used outside of Q_Window so thats why you might want to pass in an el
	*/
	center: function(el, opt_skipResize)
	{
		if(this.beforeCenter)
		{
			//you can plug in a function to get run right before the center happens.
			this.beforeCenter();
		}
		if(opt_skipResize !== false)
		{
			this.resize();
		}


		if(!el)
		{
			if(!this.element)
			{
				return;
			}
			el = this.element;
		}
		var dim = Element.getDimensions(el);
		var scrollInfo = QualtricsTools.getScrollInfo();
		var pageDim = QualtricsTools.getPageSize();


		var browserWidth = pageDim[2];
		var browserHeight = pageDim[3];
		if(window.alternateQWindowOverflow)
		{
			//if the window has an alternateOverflow that means that its an iframe that is contained within a
			//qwindow or something that has its own scroll bars. so lets return the position of those
			//scroll bars instead of the window which would always be 0, 0
			scrollInfo = [window.alternateQWindowOverflow.scrollLeft, window.alternateQWindowOverflow.scrollTop];
			browserHeight = window.alternateQWindowOverflow.offsetHeight;
		}
		var center = (browserWidth/2)-(dim.width/2)+scrollInfo[0];
		var middle = (browserHeight/2)-(dim.height/2)+scrollInfo[1];
		try
		{
			if(this.iframeParent)
			{
				//if the qwindow is within an iframe maybe you would want to position the window relative to the parent window instead of the current window
				//first find the iframe object
				if(window.frameElement && this.iframeParent && this.iframeParent.Qualtrics) //make sure we gave access to the parent and it's us
				{
					//get where the iframe lies relative to the parent.
					var frameOffsets = Position.cumulativeOffset(window.frameElement);
					var parentScrollY = this.iframeParent.scrollInfo[1];
					if(parentScrollY)
					{
						//viewTop is the top of the browser in iframe coordinates.
						var viewTop = parentScrollY-frameOffsets.top;
						//viewHeight is the viewable area in iframe coordinates
						var viewPageHeight = this.iframeParent.clientHeight || this.iframeParent.innerHeight ||  this.iframeParent.document.documentElement.clientWidth;
						if(viewPageHeight)
						{
							//overide the middle to position the qwindow relative to the parent
							middle = Math.min(parentScrollY-frameOffsets.top + (viewPageHeight / 2) - (dim.height / 2));
						}
					}
				}
			}
		}catch(e)
		{
			//an error might happen if we dont have access to the iframe, do nothing.
		}
		center = Math.round(center)+'px';
		middle = Math.round(middle)+'px';

		$(el).setStyle({left:center,top:middle});

		if(this.keepCentered) //the if is because other classes are stealing this function and they wont have a keepCentered function
		{
			this.keepCentered();
		}
	},
	buildButton:function(buttonObj)
	{
		if (buttonObj == undefined)
		{
			return;
		}
		//Handle buttonObj string shortcuts
		if(typeof buttonObj == 'string')
		{
			var type=buttonObj, obj={}, text = null, action=null;
			if(buttonObj.indexOf('|') != -1){ //a pipe says we are going to define our own display rather than the default.
				text = buttonObj.substring(buttonObj.indexOf('|')+1);
				type = buttonObj.substring(0, buttonObj.indexOf('|'));
			}
			if(type.indexOf(':') != -1){//a colon says we are going to define our own action rather than the default.
			 	action = type.substring(buttonObj.indexOf(':')+1);
			 	type = type.substring(0, buttonObj.indexOf(':'));
			}
			type = type.toLowerCase();
			switch(type)
			{
				case 'cancel':{
					obj.text=getMessage('SiteWide','Cancel');
					obj = Object.extend(obj, {id:this.windowName+'CancelButton', icon:'cancel', click:'Q_Window.closeWindow('+this.windowName+')', className:'negative'});
					break;
				}
				case 'closewithoutsaving':{
					obj.text=getMessage('EditSection','CloseWithoutSaving');
					obj = Object.extend(obj, {id:this.windowName+'CancelButton', icon:'cancel', click:'Q_Window.closeWindow('+this.windowName+')', className:'negative'});
					break;
				}
				case 'close':{
					obj.text=getMessage('SiteWide','Close');
					obj = Object.extend(obj, {id:this.windowName+'CancelButton', icon:'cancel', click:'Q_Window.closeWindow('+this.id+')', className:'negative'});
					break;
				}
				case 'save':{
					obj = Object.extend(obj, {id:this.windowName+'SaveButton', icon:'check', text:getMessage('SiteWide','Save'), className:'positive'});
					break;
				}
				case 'ok':{
					obj = Object.extend(obj, {id:this.windowName+'OKButton', icon:'check', text:getMessage('SiteWide','OK'), className:'positive', click:'Q_Window.closeWindow('+this.id+')'});
					break;
				}
			}
			if(action)
			{
				obj.click = action;
				if(type.indexOf('save') != -1)
				{
					// disable the save button and don't add a click call back.
					if (this.options.disableSave)
					{
						obj.className += ' Disabled';
						obj.click = '';
						obj.permanentDisable = true;
					}
					else
					{
						//if the button says save at all then we are going to disable the save button
						obj.click = 'Q_Window.saveButtonHelper:'+this.windowName+'('+action+')';
					}
				}
				if(type == 'ok')
				{
					//an ok button will instantly close the window and run the action.
					obj.click = 'Q_Window.okButtonHelper:'+this.windowName+'('+action+')';
				}
				if (type == 'cancel')
				{
					obj.click = 'Q_Window.cancelButtonHelper:' + this.windowName + '(' + action + ')';
				}
			}
			if(text)
			{
				//override the default text with the custom
				obj.text = text;
			}
			buttonObj = obj;
		}

		//build the button with the buttonObj
		var className = '';
		if(buttonObj.className)
		{
			className = ' '+buttonObj.className;
		}
		var style = '';
		if(buttonObj.style)
		{
			style = ' '+buttonObj.style;
		}
		var elementType = 'a';
		if(buttonObj['button'])
		{
			elementType = 'button';
		}
		if(buttonObj.domNode)
		{
			//short circuit everything with a custom domNode builder
			var button = Qualtrics.Event.execute(buttonObj.domNode);
		}
		else
		{
			button = QBuilder(elementType, {className:'qbutton'+className+style});
		}
		if(buttonObj.icon)
		{
			button.appendChild(QBuilder('span',{className:'icon '+buttonObj.icon}));
		}
		if(buttonObj.text)
		{
			button.appendChild(document.createTextNode(buttonObj.text));
		}
		if(buttonObj.click)
		{
			button.setAttribute('clickcallback', buttonObj.click);
		}
		if(buttonObj.clickcallback)
		{
			button.setAttribute('clickcallback', buttonObj.clickcallback);
		}
		if(buttonObj.instanceid)
		{
			button.setAttribute('instanceid', buttonObj.instanceid);
		}
		var buttonIndex = 1;
		while(buttonObj['p'+buttonIndex] != undefined)
		{
			button.setAttribute('p'+buttonIndex, buttonObj['p'+buttonIndex]);
			buttonIndex++;
		}
		if(buttonObj.id)
		{
			button.id = buttonObj.id;
			this.buttonReg[button.id] = button;
		}
		if(buttonObj.type)
		{
			button.type =  buttonObj.type;
		}
		if (buttonObj.permanentDisable)
		{
			button.setAttribute('permanentDisable', buttonObj.permanentDisable);
		}

		return button;
	},
	getButton:function(id)
	{
		//Return the prototype wrapped object because IE7 doesn't support hasAttribute (which we use on the button)
		return $(this.buttonReg[id]);
	},
	isButtonDisabled:function(id)
	{
		return this.getButton(id).hasClassName('disabled');
	},
	busifyButton:function(id, message)
	{
		var button = this.getButton(id);
		if (!button)
		{
			//try to get button from buttonType
			button = this.getButton(this.windowName+id+'Button');
			if(!button)
			{
				//just get the button from the id
				button = $(id);
			}
		}
		button = $(button);
		$(button).addClassName('disabled');
		$(button).addClassName('Disabled');
		button.disabled = true;
		button.originalHTML = button.innerHTML;
		if (message)
			button.innerHTML = message;

		if (button.hasAttribute('clickcallback'))
		{
			button.setAttribute('pendingcallback', button.getAttribute('clickcallback'));
			button.removeAttribute('clickcallback');
		}

	},
	unbusifyButton:function(id, message)
	{
		var button = this.getButton(id);
		if(!button)
		{
			//just get the button from the id
			button = $(id);
		}

		if (message)
			button.innerHTML = message;

		// only "unbusify" the button if it's not permanently disabled
		if (button && !button.hasAttribute('permanentDisable'))
		{
			$(button).removeClassName('disabled');
			$(button).removeClassName('Disabled');
			button.disabled = false;
			if (button.originalHTML)
				button.innerHTML = button.originalHTML;
		}
		if (button.hasAttribute('pendingcallback'))
		{
			button.setAttribute('clickcallback', button.getAttribute('pendingcallback'));
			button.removeAttribute('pendingcallback');
		}
	},
	disableButton:function(id)
	{
		var button = this.getButton(id);
		if(button)
		{
			button.disabled = true;
			$(button).addClassName('disabled');
			if (button.hasAttribute('clickcallback'))
			{
				button.setAttribute('pendingcallback', button.getAttribute('clickcallback'));
				button.removeAttribute('clickcallback');
			}
		}
	},
	enableButton:function(id)
	{
		var button = this.getButton(id);
		// only "enable" the button if it's not permanently disabled
		if(button && !button.hasAttribute('permanentDisable'))
		{
			button.disabled = false;
			$(button).removeClassName('disabled');
			if (button.hasAttribute('pendingcallback'))
			{
				button.setAttribute('clickcallback', button.getAttribute('pendingcallback'));
				button.removeAttribute('pendingcallback');
			}
		}
	},
	reenableButton:function(buttonType)
	{
		var id = this.windowName+buttonType+'Button';
		this.unbusifyButton(id);
	},

	/**
	* this is used by the save:action button shortcut. it will automatically disable the button and execute whatever action is specified.
	* @param {String} action - whatever action you want to run
	*/
	saveButtonHelper:function(action)
	{
		var button = $(this.windowName+'SaveButton');
		if(button && !button.disabled)
		{
			button.originalHTML = button.innerHTML;	//Save original HTML for restoring later inside reenable
			button.innerHTML = this.customSavingMessage||getMessage('SiteWide','Saving')+'...';

			button.disabled=true;
			button.addClassName('Disabled');
			QualtricsCPTools.executeDotSyntax(action);
		}
	},
	okButtonHelper:function(action)
	{
		this.destroy();
		QualtricsCPTools.executeDotSyntax(action);
	},
	cancelButtonHelper:function(action)
	{
		this.destroy();
		QualtricsCPTools.executeDotSyntax(action);
	},
	keepCentered:function()
	{
		this.keepCentering = true;

		//we only make 1 resize watcher to handle all windows on the page.
		//becuse otherwise prototype will leak memory everytime we open and close one.
		if(!Q_Window.resizeWatcher)
		{
			Q_Window.resizeWatcher = Event.observe(window, 'resize', function(evt){


				//unset the cached page size
				Qualtrics.Cache.unset('PageSize');
				//center windows centers all the windows that should be centered.
				Q_Window.centerWindows();
			});
		}
	},
	//maintain compatibility with prototype.windows
	showCenter:function()
	{
		this.center();
	},
	/** returns the current size of the window */
	getSize: function()
	{
		return {width: this.width, height: this.height};
	},
	//set the size of the window
	setSize:function(width, height,opt_resize)
	{
		this.width = String(width);
		this.height = String(height);

		if (!this.preservePctHeightAndWidth)
		{
			this.pctWidth = null;
			this.pctHeight = null;
		}
		var that = this;
		['height', 'width'].map(function(s){
			if (String(that[s]).endsWith('%'))
			{
				that['pct'+s.capitalize()] = parseInt(that[s].substr(0,that[s].indexOf('%')),10)/100;
				//that[s] = 'auto';
			}
			else if(that[s] !== 'auto' && !String(that[s]).endsWith('px'))
			{
				//that[s] = that[s]+'px';
			}
			that['auto'+s.capitalize()] = (that[s] == 'auto');
		});
		if(opt_resize !== false)
			this.resize();
	},
	getInnerDimensions:function()
	{
		return $(this.innerElement).getDimensions();
	},
	setTitle:function(title)
	{
		var closeButton = this.closeButton;
		this.updateHeader(this.buildTitle(title,{closeButton:closeButton}));
	},
	replace:function(options)
	{
		//Set up our skeleton
		var skeleton = new Q_Window({
			title:'A',
			buttons:['close'],
			hidden:true,
			skeleton:true,
			hideOverlay:true
		});
		//set up our new window & hide it to start
		options.hidden = true;
		options.hideOverlay = true;
		var win = new Q_Window(options);

		//give our overlay to the new window
		win.overlayObj = this.overlayObj;
		delete this.overlayObj;

		//set the skeleton width, height, top, left
		var dims = this.getInnerDimensions();
		skeleton.setSize(dims.width, dims.height);
		$(skeleton.element).setStyle({
			top:this.element.style.top,
			left:this.element.style.left
		});

		skeleton.unHide((function(skeleton, win)
		{
			//morph our skeleton to the size of our window
			var dims = win.getInnerDimensions();
			new Effect.Morph(skeleton.element, {
				style:'top:' + win.element.style.top + '; left:' + win.element.style.left,
				duration:0.3
			});
			new Effect.Morph(skeleton.innerElement,{
				style:{
					width:dims.width + 'px',
					height:dims.height + 'px'
				},
				duration:0.3,
				afterFinish:(function(skeleton, win)
				{
					win.unHide();
					skeleton.hide(skeleton.destroy.bind(skeleton, false));
				}).curry(skeleton, win)
			});
		}).curry(skeleton, win));
		this.hide(this.destroy.bind(this, false));

		//return our new window
		return win;
	},
	hide:function(opt_afterFinish)
	{
		$(this.element).fade({
			duration:0.4,
			afterFinish: opt_afterFinish || function(effect) {
				effect.element.className += ' Hide';
			}
		});
	},
	unHide:function(opt_afterFinish)
	{
		$(this.element).setOpacity(0);
		$(this.element).removeClassName('Hide');
		$(this.element).appear({
			duration:0.2,
			afterFinish:opt_afterFinish
		});
	}
};

/**
* Q_Overlay
*/
window.Q_Overlay = Class.create();
Q_Overlay.reg = [];
Q_Overlay.getInstance = QualtricsTools.getInstanceHelper(Q_Overlay.reg, '_id');
Q_Overlay.removeAll = function()
{
	var i = Q_Overlay.reg.length;
	while(i--)
	{
		Q_Overlay.reg[i].remove();
	}
};
Q_Overlay.prototype = {
	_id:null,
	overlayName:null,
	initialize:function(options)
	{
		options = options || {};
		this.options = options;
		Q_Overlay.reg.push(this);
		this._id = QualtricsTools.createNewId('QO');
		var opacity = options.opacity;
		var overlayId = "Overlay";
		if(options.id){
			overlayId = options.id;
		}
		this.overlayName = overlayId;

		//I added the Overlay_ prefix because its to hard to distingish popups from overlays in ie6. Hopefully nobody needs it.
		var objOverlay = QBuilder('div',{id:this._id, className:'Overlay Overlay_'+this.overlayName, style:"display:none"});
		if(options.onClick)
		{
			objOverlay.onclick = options.onClick;
		}

        if(options.keepMenuOpen)
        {
			//we have to put it on the body cause the other listeners are on the document
            Event.observe(document.body, 'mousedown',this.mouseDownHandler);
        }

		if(options.onClose)
		{
			//this will run whenver the overlay is removed (by click or otherwise);
			this.onClose = options.onClose;
		}

		//parentId is an alias for append
		if(options.parentId){
			options.append = options.parentId;
		}
		//append defines the parent element
		if(options.append){
			$(options.append).appendChild(objOverlay);
		}else{
			document.body.appendChild(objOverlay);
			//$('body').appendChild(objOverlay);
		}
		if ($('pageDiv'))
		{
			$('pageDiv').addClassName('HideOnOverlay');
		}
		var arrayPageSize = getPageSize();
		Element.setStyle(objOverlay, {height:arrayPageSize[1]+'px'});
		if(options.dim){
			if(options.dim.width){
				Element.setStyle($(objOverlay), {width:options.dim.width});
			}
			if(options.dim.height){
				Element.setStyle(objOverlay, {height:options.dim.height});
			}
			if(options.dim.x){
				Element.setStyle($(objOverlay), {left:options.dim.x+'px'});
			}
			if(options.dim.y){
				Element.setStyle($(objOverlay), {top:options.dim.y+'px'});
			}
		}
		if(options.zindex) options.zIndex = options.zindex; //old code uses lowercase for somereason. TODO:find and fix this
		if(options.zIndex){
			Element.setStyle($(objOverlay), {zIndex:options.zIndex});
		}

		if(options.color){
			Element.setStyle($(objOverlay), {backgroundColor:options.color});
		}

		$(objOverlay).show();
		if (opacity !== undefined)
		{
			$(objOverlay).setStyle({opacity:opacity});
			objOverlay.style.opacity = opacity; /* fix for ie9, prototype doesnt seem to do the opacity very well anymore*/
		}
		this.domNode = objOverlay;

		objOverlay = null;

		this.manageMultipleOverlays();
	},
	manageMultipleOverlays:function()
	{
		if(this.options.dontManageOverlays)
		{
			return;
		}
		if(Q_Overlay.reg.length)
		{
			for(var i =0, len=Q_Overlay.reg.length; i<len; ++i)
			{
				if(i < len-1)
				{
					Q_Overlay.reg[i].domNode && $(Q_Overlay.reg[i].domNode).setStyle({backgroundColor:'transparent'});
				}
				else
				{
					Q_Overlay.reg[i].domNode && $(Q_Overlay.reg[i].domNode).setStyle({backgroundColor:''});
				}
			}
		}
	},
	getPosition:function()
	{
		for(var i =0, len=Q_Overlay.reg.length; i<len; ++i)
		{
			if(Q_Overlay.reg[i]._id == this._id)
			return i;
		}
	},
	/**
	* Q_Overlay.remove
	*/
	remove:function(options)
	{
        Event.stopObserving(document.body, 'mousedown',this.mouseDownHandler);

		if(this.onClose)
		{
			this.onClose();
		}
		if(this.domNode){
			removeElement(this.domNode);
			this.domNode = null;
		}
		var pos = this.getPosition();
		Q_Overlay.reg.splice(pos, 1);
		if(!Q_Overlay.reg.length)
		{
			if ($('pageDiv'))
				$('pageDiv').removeClassName('HideOnOverlay');
		}
		this.manageMultipleOverlays();
	},
    mouseDownHandler:function(evt)
    {
        if(!evt)
            evt = window.event;

		//we don't use Event.stop(evt) because it prevents the default action which we may want
		evt.cancelBubble = true;
		if (evt.stopPropagation)
			evt.stopPropagation();
    }
};

/**
 * Q_PopoverWindow
 *
 * This is like a QWindow, except that it stays anchored to a particular element instead of floating
 * in the center of the page.
 */
window.Q_PopoverWindow = Class.create(Q_Window, {
	initialize:function($super, windowName, options, var_args)
	{
		$super(windowName, options);

		var windowBackgroundColor = '#ebebeb';

		// anchor the window to some element
		if (options.anchor)
		{
			var dims = Element.getDimensions(options.anchor);

			// build the anchor
			var manageLink = QBuilder('a',{className:'ManageDataSource'}, getMessage('Reporting','ManageOtherFilters'));
			var anchorDiv = QBuilder('div', {}, [
				manageLink
			]);
			$(anchorDiv).setStyle({
				display:'block',
				position:'absolute',
				backgroundColor:windowBackgroundColor,
				style:'padding:5px',
				textAlign:'center',

				right:0,
				top:(-1 * dims.height)+'px',
				width:dims.width+'px',
				height:dims.height+'px'
			});
			if (this.options.anchor.firstChild)
			{
				$(manageLink).setStyle({
					lineHeight: $(this.options.anchor.firstChild).getStyle('line-height'),
					whiteSpace: $(this.options.anchor.firstChild).getStyle('white-space'),
					color: $(this.options.anchor.firstChild).getStyle('color'),
					textDecoration: $(this.options.anchor.firstChild).getStyle('text-decoration')
				});
			}
			this.element.appendChild(anchorDiv);
			$(this.element).setStyle({
				backgroundColor: windowBackgroundColor
			});
		}

		$(this.element).removeClassName('Q_WindowBorder');
		$(this.element).addClassName('Q_Popover');
	},
	center:function($super, el, opt_skipResize)
	{
		$super(el, opt_skipResize);

		if (this.options.anchor)
		{
			// position the window
			var dims = Element.getDimensions(this.options.anchor);
			var pos = Element.cumulativeOffset(this.options.anchor);

			var width = Element.getDimensions(this.element).width;

			pos.top += (dims.height + 5);
			pos.left -= (width - dims.width);
			$(this.element).setStyle({
				top: pos.top+'px',
				left: pos.left+'px'
			});
		}

		this.fitToScreen();
	},
	setContent:function($super, content)
	{
		$super(content);
		this.fitToScreen();
	},
	fitToScreen:function()
	{
		var windowSize = $(this.element).getDimensions();
		var pageDim = QualtricsTools.getPageSize();
		var browserWidth = pageDim[2];
		var browserHeight = pageDim[3];

		var bottomPadding = 150; // px

		var currentTop = parseInt($(this.element).getStyle('top'));
		if (currentTop + windowSize.height > browserHeight)
		{
			var restrictedHeight = (browserHeight - currentTop - bottomPadding);
			$(this.innerElement).setStyle({
				height: restrictedHeight+'px'
			});
		}

	}
});
/**
* here are some examples of how to use menu defs
*

1: just a callback to a function that contains a def
'someclass.somefunction(someparam)'

2: an ajax request that returns a def
{
	ajax:{
		action:"GetQuestionList",
		parameters:{SurveyID:"SV_84do9S0L912Xc"},
		preparser:"Qualtrics.PipedText.getMenuDefFromQuestionList"
	}
}

3: this is strait hardcoded def. (this is what 1 & 2 should return)
{
	items:[
		{
			display:'something',
			action:'some action',
			tag:'1',//this is a number or short string to help identify the item, an example would be a choiceId or a questionId
			icon:false,
			className:'check',
			submenu:{
				items:[
					{

					}
				]
			}
		}
	],
	position:vertical,
	alignment:auto,
	direction:auto,
	togglecheck:true
	togglecheckexclusive:true
}

4: this is an easy way to show a loading animation
{
	loading:true
}

5: this is an easy way to just show a message in the menu
{
	string:'something'
}


*/

/**
* Qualtrics.Menu is the static class and interface to the Menuing system.
* It does not support prebuilt menus because all menus should be built and rendered just in time.
*/
Qualtrics.Menu = {
	menuPaneStack:[],
	/**
	* Qualtrics.Menu.buildMenuButton:
	* this builds a default menu button, you do not have to use if you want a weird button. just call the showMenu function yourself.
	* @param {String} title - the text of the button
	* @param {Mixed} menuCallBack - This how you get the menu contents. It is very flexible. See Qualtrics.Menu.showMenu for more details.
	* @param {Object} options - {
	*					selectMenu:{Boolean} - if you want the menu to behave like a select menu. default is false.
	*					initialValue:{Mixed} - for use with selectMenu.
	*					autoSelect:{Boolean} - for use with selectMenus, will pick the first item in the def and select it.
	*					autoSelectCallback:{Boolean} - optional - if you provide a callback you can pick what item gets autoselected! just return the value you want.
	* }
	* @return {HTMLAnchorElement} the button.
	*/
	buildMenuButton:function(title, menuCallBack, options)
	{
		options = options || {};
		var buttonId = (options && options.buttonId || options.id) || QualtricsTools.createNewId('BTN');
		var innerTitle = QBuilder('span',{});
		this.innerTitleDom = innerTitle;
		if(title === null && (options.initialValue !== undefined || options.autoSelect))
		{
			//if we are given a null title and we have an initialValue we can look in the menuDef for a match.
			//note this will not always work because sometimes a menuDef is behind an ajax request.
			//we need to pass along the original options to the menu pane so it works like the real menu, but we also need to add an onLoad
			//so that the menuPane knows to update the button on an ajax load.
			var buttonMenuPaneOptions = Object.extend({headless:true, onLoad:'Qualtrics.Menu.loadTitleFromMenuDef('+buttonId+', $menuPane, '+options.autoSelect+')', allowAbort:false}, options);

			//we need to instatiate a MenuPane to parse the def
			var menuPane = new Qualtrics.MenuPane(menuCallBack, null, null, buttonMenuPaneOptions);
			//we have to build the menu so the menuPane has a menuDef.
			menuPane.buildMenu(menuCallBack);
			var menuDef = menuPane.menuDef;
			var initialValue;

			if(menuDef.items)
			{
				if(options.initialValue !== undefined)
				{
					initialValue = options.initialValue;
				}
				else if(options.autoSelect)
				{
					//auto select a default value
					initialValue = this.getDefaultValue(menuDef, menuPane);

					//run a selectcallback if its defined.
					var itemDef = Qualtrics.Menu.getItemDefByValue(initialValue, menuDef);
					var selectionNode = undefined;

					menuPane.runSelectCallBack(menuPane, itemDef, selectionNode);
				}
				title = Qualtrics.Menu.getMenuDisplayByValue(initialValue, menuDef, true);

			}
			else if(menuDef.loading)
			{
				title = QBuilder('span',{className:'Loading'});
			}
			//destroy the menuPane so it doesnt cause problems later.
			menuPane.destroy();
		}
		if (title == '')
		{
			$(innerTitle).update('&nbsp;');
		}
		else
		{
			if(options.displayAsText)
			{
				var textnode = document.createTextNode(title);
				innerTitle.innerHTML = '';
				innerTitle.appendChild(textnode);
			}
			else if((options.buttonTruncate || options.truncate) && window.QualtricsCPTools && typeof title == 'string')
			{
				var truncatedTitle = QualtricsCPTools.middleTruncate(title.stripTags(), options.buttonTruncate || options.truncate);
				$(innerTitle).update(truncatedTitle);
			}
			else
			{
				$(innerTitle).update(title);
			}
		}

		var className;
		if(options.className)
		{
			className = ' '+options.className;
		}
		else
		{
			className = '';
		}
		var callbacktype = options.callbacktype || 'downcallback';
		var p3 = '';

		//we need to make sure its a string
		if(typeof options != 'string')
		{
			p3 = Object.toJSON(options);
		}

		var button;
		var b;

		var highlight = '';
		if(options.highlight)
			highlight = QBuilder('span',{className:'HighlightTop', bubbleup:'true'});

		if(!options.menuButtonCallback)
		{
			options.menuButtonCallback = 'Qualtrics.Menu.showMenu';
		}
		innerTitle.id = 'ButtonInner_'+buttonId;
		if(options.theme)
		{
			button = QBuilder('a',{p1:menuCallBack, p2:'$el', p3:p3, p4:'$evt', preventDrag:'true', id:buttonId, className:'ThemedMenuButton menuButton_'+options.theme+className},[
				highlight,
				b = QBuilder('b',{bubbleup:'true', preventDrag:'true'},[
					options.icon !== false?QBuilder('span',{className:'icon'}):'',
					options.misc !== false?QBuilder('span',{className:'misc'}):'',
					innerTitle
				])
			]);
			button.setAttribute(callbacktype, options.menuButtonCallback);
		}
		else
		{
			var iconDom = '';
			if(options.iconDom)
			{
				if(typeof options.iconDom == 'string')
				{
					iconDom = Qualtrics.Event.executeDotSyntax(options.iconDom);
				}
				else if(typeof options.iconDom == 'object')
				{
					iconDom = options.iconDom;
				}
			}
			//all these b tags have special borders that give the button little rounded edges.
			button = QBuilder('a',{id:buttonId, className:'menuButton'+className},[
				highlight,
				QBuilder('b',{preventDrag:'true'},[
					QBuilder('b',{preventDrag:'true'},[
						b = QBuilder('b',{p1:menuCallBack, p2:'$el', p3:p3, p4:'$evt', preventDrag:'true'},[
							options.icon !== false?QBuilder('span',{className:'icon'},[iconDom]):'',
							innerTitle
						])
					])
				])
			]);
			b.setAttribute(callbacktype, options.menuButtonCallback);
		}
		button.updateTitle = Qualtrics.Menu.getUpdateButtonFunction(buttonId);
		b.updateTitle = button.updateTitle;

		button.callbackNode = b; //so we can quickly access the furthest down b node

		//so we can change the callback of a button on the fly.
		button.updateCallback = function(b, type, c){b.setAttribute(type, c)}.curry(b, callbacktype);

		b.aNode = button; //so we can quickly grab the a tag
		if(options.menuItemSelectCallback)
		{
			button.setAttribute('menuitemselectcallback', options.menuItemSelectCallback);
		}

		if(options.initialValue !== undefined)
		{
			this.currentValue = options.initialValue;
			button.setAttribute('currentvalue', options.initialValue);
		}
		return button;
	},
	buildColorMenuButton:function(colorPickerOptions)
	{
		colorPickerOptions = colorPickerOptions || {};
		//convert the limited color picker options to menu options with a colorPicker name space.
		var menuOptions = {
			colorPickerColor:colorPickerOptions.color,
			colorPickerCallback:colorPickerOptions.action,
			checkForFixed:colorPickerOptions.checkForFixed!==undefined?colorPickerOptions.checkForFixed:true,//default to true
			showNone:colorPickerOptions.showNone || true,
			noneMessage:colorPickerOptions.noneMessage
		};
		menuOptions.className = 'SelectMenuButton ColorMenuButton';
		return this.buildMenuButton(this.buildColorTitle(menuOptions), 'Qualtrics.Menu.getColorMenuDef('+menuOptions.colorPickerColor+', $options)', menuOptions);
	},
	buildColorTitle:function(options)
	{
		var color = options.colorPickerColor || 'transparent';
		var title = '';
		//optionally show words
		if(options.buttonLabel)
		{
			title = options.buttonLabel;
		}
		var swatch = QBuilder('div', {className:'ColorMenuSwatch', bubbleup:true},[QBuilder('div',{className:'SwatchBorder', bubbleup:true})]);
		if(options.colorPickerColor)
		{
			$(swatch).setStyle({backgroundColor:color});
		}
		return QBuilder('div',{bubbleup:true},[
			QBuilder('div',{className:'ColorMenuSwatchContainer', bubbleup:true}, [swatch]),
			QBuilder('span',{className:'ColorMenuLabel', bubbleup:true},[title])
		]);
	},
	getColorMenuDef:function(selectedColor, options)
	{
		return {
			items:[
				{
					domNode:'Qualtrics.Menu.getColorPickerDom($options)'
				}
			]
		};
	},
	getColorPickerDom:function(options)
	{
		QModules.loadModule('colorpicker.js');
		var colorPicker = new ColorPicker({
			color: options.colorPickerColor,
			useTransparent: true,
			onColorPick: options.colorPickerCallback
		});
		var cpNode = colorPicker.buildColorPicker();
		var additionalItems = document.createDocumentFragment();
		if(options.showNone)
		{
			additionalItems.appendChild(QBuilder('a',{className:'MenuItemLink', mouseupcallback:colorPicker.getSelfFunction('resetColor')},options.noneMessage||getMessage('SiteWide','Reset')));
		}
		return QBuilder('div',{className:'ColorPickerMenu'},[
			cpNode,
			additionalItems
		]);
	},
	/**
	 * returns a closure that update the button text
	 * we do this as its own function so we dont enclose everything from the buildMenuButton method
	 * this way we can just enclose just the single string we need(buttonId)
	 * reducing the chance of a memory leak.
	 **/
	getUpdateButtonFunction:function(buttonId)
	{
		return function(htmlContent)
		{
			Qualtrics.Menu.updateButtonTitle(buttonId, htmlContent);
		};
	},

	updateButtonTitle:function(id, htmlContent)
	{
		var buttonInner = $('ButtonInner_'+id) || this.innerTitleDom;
		if(buttonInner)
			buttonInner.innerHTML = htmlContent;
	},
	loadTitleFromMenuDef:function(buttonId, menuPane, autoSelect)
	{
		var buttonNode = $(buttonId);
		var menuDef = menuPane.menuDef;
		var value = buttonNode.callbackNode.getAttribute('currentvalue');
		if((value === undefined || value === null || value === 'null') && autoSelect)
		{
			//select the first value
			var value = this.getDefaultValue(menuDef, menuPane);

			if(value !== undefined)
			{
				//get the itemDef from the value
				var itemDef = Qualtrics.Menu.getItemDefByValue(value, menuDef);
				var selectionNode = undefined;
				//run a selectcallback if its defined.
				menuPane.runSelectCallBack(menuPane, itemDef, selectionNode);
			}
		}
		var title = Qualtrics.Menu.getMenuDisplayByValue(value, menuDef, true);
		Qualtrics.Menu.updateButtonTitle(buttonId, title);
	},
	getDefaultValue:function(menuDef, menuPane)
	{
		if(menuPane.options.autoSelectCallback)
		{
			//run the autoSelectCallback to get the default value
			return Qualtrics.Event.executeDotSyntax(menuPane.options.autoSelectCallback, null, null, null, {'$menuDef':menuDef}, [menuDef]);
		}
		else
		{
			//just choose the first value in the items
			if(menuDef && menuDef['items'])
			{
				return menuDef['items'][0].value;
			}
		}
	},
	getItemDefByValue:function(val, def)
	{
		if(def['items'])
		{
			for(var i=0, len=def['items'].length; i<len; ++i)
			{
				if(def['items'][i].value == val)
				{
					return def['items'][i];
				}
			}
		}
		return null;
	},
	/**
	 * returns the display for a menu item by value.
	 * This is useful if you have a selectMenu:true menu that you need to render
	 * and you stored the value but dont have a title.
	 **/
	getMenuDisplayByValue:function(val, def, opt_selectedDisplay)
	{
		if(def['items'])
		{
			for(var i=0, len=def['items'].length; i<len; ++i)
			{
				if(def['items'][i].value == val)
				{
					var selectedDisplay = (opt_selectedDisplay) ? def['items'][i].selectedDisplay : false;
					return selectedDisplay || def['items'][i].display || def['items'][i].label;
				}
			}
		}
		return val;
	},
	/**
	 * There are 2 ways of making a selectMenu, you can use this special select menu class
	 * you must assign a hardcoded list in the options array or it will not work.
	 *
	 * If you want something more flexible you can use use a regular menu with the options {selectMenu:true, initialValue:'somevalue'} and assign a 'value' property to each menuDef item
	 * making a regular menu function as a select menu is useful if you want a select menu from an ajax menu def or something.
	 **/
	buildSelectMenuButton:function(initialValue, fieldName, options)
	{
		var buttonId = fieldName+'_Button';
		options = options || {};
		var list = options.list || {};
		var className = options.className?'SelectMenuButton '+options.className:'SelectMenuButton';

		//assign a default if none is provided
		if(!initialValue && Object.keys(list).length && !options.prompt)
		{
			initialValue = Object.keys(list)[0];
		}
		var menuButtonOptions = Object.extend(options,{
			menuType:'SelectMenuPane',
			className:className,
			buttonId:buttonId,//this sets the button id to what we say instead of a default.
			fieldName:fieldName,
			list:list,
			useArrayIndex: options.useArrayIndex,
			initialValue:initialValue,
			p1:fieldName,
			p2:buttonId, //this sends the buttonId to the click callback
			p3:'$options'//this passes on this full list of options to the buildAjaxMenu callback
		});

		var value = initialValue;

		//use the value if a key is provided as the initialValue

		if (list[initialValue])
		{
			if(typeof list[initialValue] == 'object')
			{
				var html = list[initialValue].label || list[initialValue];
				if(typeof html == 'object')
				{
					value = html.value;
				}
			}
			else
			{
				value = list[initialValue];
			}
		}
		if(value === null && options.prompt)
		{
			value = options.prompt;
		}
		var button = Qualtrics.Menu.buildMenuButton(value,'Qualtrics.Menu.buildSelectMenu', menuButtonOptions);

		//you can use an existing field or if none exists the button will make one for you.
		//it needs to be defered because sometimes you create these before you render them!
		Qualtrics.Menu.setupMenuButtonInput.curry(initialValue, fieldName, button).defer();


		return button;
	},
	buildNumericMenuButton:function(options)
	{
		options = options || {};
		options.range = options.range || [10, 20, 50, 100, 200, 500, 1000, 2000, 5000];
		options.value = options.value || options.range[0];
		options.min = options.min || 0;
		options.max = options.max || undefined;
		options.unlimitedValue = options.unlimitedValue || 'Unlimited';
		options.allowCustom = options.allowCustom || false;

		return Qualtrics.Menu.buildMenuButton(null, 'Qualtrics.Menu.getNumericMenuDef($options, $el)', {
			initialValue:options.value,
			selectMenu:true,
			className:'SelectMenuButton',
			menuItemSelectCallback:options.menuItemSelectCallback,
			numericOptions:options
		});
	},
	getNumericMenuDef:function(options, button)
	{
		var items = [];
		for (var i=0, len=options.numericOptions.range.length; i<len; ++i)
		{
			if (options.numericOptions.min && options.numericOptions.range[i] < options.numericOptions.min) continue;
			if (options.numericOptions.max && options.numericOptions.range[i] > options.numericOptions.max) continue;
			items.push({
				display:number_format(options.numericOptions.range[i], 0, '', ','),
				value:options.numericOptions.range[i]
			});
		}
		if (!options.numericOptions.max) // when there's no max we can show an 'Unlimited' option
		{
			items.push({
				display:getMessage('ServerAdminSection', 'Unlimited'),
				value:options.unlimitedValue
			});
		}
		if (options.numericOptions.allowCustom)
		{
			var buttonId = button ? QualtricsTools.fastUp(button, 'menuButton').id : '';
			items.push({
				type:'TextInput',
				action:'Qualtrics.Menu.validateNumericMenuValue($val, '+buttonId+', '+options.numericOptions.menuItemSelectCallback+', '+options.numericOptions.min+', '+options.numericOptions.max+')',
				label:'Custom' + (options.numericOptions.max ? ' (up to ' + number_format(options.numericOptions.max, 0, '', ',') + ')' : ''),
				validation:'Number',
				focus:true
			});
		}
		return {items:items};
	},
	validateNumericMenuValue:function(value, buttonId, callback, min, max)
	{
		if (!Number(value)) return;
		if (Number(min) && Number(value) < Number(min)) return;
		if (Number(max) && Number(value) > Number(max)) return;

		var button = $(buttonId);
		if (button)
		{
			button.updateTitle(value);
			button.callbackNode.setAttribute('currentvalue', value);
		}
		Qualtrics.Event.executeDotSyntax(callback, false, false, false, {
			'$value': value
		});
	},
	setupMenuButtonInput:function(initialValue, fieldName, button)
	{
		if(!$(fieldName))
		{
			var input = QBuilder('input',{type:'hidden', id:fieldName, name:fieldName, value:initialValue});
			if (initialValue === null && input.getAttribute('value') == 'null')
				input.value = null;
			if(button && button.firstChild && button.firstChild.nodeType == 1) //dont try to append to a textNode
				button.firstChild.appendChild(input);
		}
		else
		{
			//make sure an initial value is set
			if(!$(fieldName).value) $(fieldName).value = initialValue;
		}
	},
	/**
	* Qualtrics.Menu.buildSelectMenu:
	*/
	buildSelectMenu:function(fieldName, buttonId, options)
	{
		options = Qualtrics.Menu.processOptions(options);
		var menuList = Qualtrics.Menu.buildSelectMenuList(fieldName, buttonId, options.list, options.useArrayIndex);
		if (options.search)
			menuList.search = options.search;
		return menuList;
	},
	/**
	* Qualtrics.Menu.buildSelectMenuList
	* @param {object|array} the list to build the menu from. an object should be a key/value pair, and an array will use the value for both the key and the value. (unless opt_useArrayIndex is true)
	* @param {boolean} opt_useArrayIndex - if true and you are using an array as a list, then it will use the index (the key) of an array as the value instead of its value.
	*/
	buildSelectMenuList:function(fieldName, buttonId, list, opt_useArrayIndex)
	{
		console.warn('buildSelectMenuList is deprecated use selectMenu:true on a regular menu');
		var callbackNode = $(buttonId).callbackNode;
		var currentValue = ($(fieldName) && $(fieldName).value) || callbackNode && callbackNode.getAttribute('currentvalue');
		//figure out if the list is an array
		var isArray = false;

		if(list.push && typeof list.push == 'function')
		{
			isArray = true;
		}

		if(list && !Qualtrics.isEmpty(list))
		{
			var items = [];
			for(var listId in list)
			{
				var key = listId;
				if(isArray && !opt_useArrayIndex)
				{
					//for arrays we will use the value as both the key and the display.
					key = list[listId];
				}
				var itemOptions = {};

				if(typeof list[listId] == 'object')
				{
					itemOptions = list[listId];
				}
				var html = itemOptions.label || list[listId];
				var listItem = html;

				var className = '';
				if(typeof html == 'function')
				{
					continue;
				}
				if(typeof html == 'object')
				{
					if(html.className)
					{
						className = ' '+html.className;
					}
					html = html.value;
				}
				var checked = false;
				if(listId == currentValue) checked = true;
				if(isArray && !opt_useArrayIndex)
				{
					//if we are using an array as a list and we are using the values as the keys then we check against the values instead of the keys
					if(list[listId] == currentValue) checked = true;
				}
				var item = {
					display:html,
					className:className,
					value:key,
					checked:checked,
					parameters:{
						p1:fieldName,
						p2:buttonId,
						p3:key,
						p4:list[listId]
					}
				};

				if (typeof listItem == 'object')
				{
					//it its an object we are just going to do a strait menu def item passthru
					item = listItem;
				}

				//allow for custom actions
				if(list[listId].action)
				{
					item.action = list[listId].action;
				}
				items.push(item);

			}
			return {items:items, togglecheckexclusive:true};
		}
		else
		{
			return {string:getMessage('SiteWide','NoResults')};
		}
	},
	/**
	 * Qualtrics.Menu.showMenu
	 */
	showMenu:function(menuBuilder, parentButton, options, evt)
	{
		if(evt)
		{
			Event.stop(evt); //to stop the menu text getting selected if the mousedown and drag
		}

		if(Qualtrics.Menu.skipNextOpen && Qualtrics.Menu.skipNextOpen == menuBuilder)
		{
			Qualtrics.Menu.skipNextOpen = false;
			return;
		}
		var alreadyOpenMenuPane = Qualtrics.Menu.findMenu(menuBuilder);
		//we need to check to see if there already is a menu and if it is open because it could be an headless instance used to populate the button.
		if(alreadyOpenMenuPane && alreadyOpenMenuPane.isOpen())
		{
			//if the menu is already open then dont open it again
			//this will have the effect of closing the menu if you click the menu button again.
			return;
		}
		options = this.processOptions(options);
		var opt_parentMenu = options.parentMenu; //this will be null most of the time, which is why it's not a main param.
		if(parentButton && parentButton.aNode)
		{
			$(parentButton.aNode).addClassName('HasActiveMenu');
		}
		if(options.checkForFixed)
		{
			options.fixed = this.isFixed(parentButton);
		}
		if (options.menuType)
		{
			return new Qualtrics[options.menuType](menuBuilder, parentButton, opt_parentMenu, options, evt);
		}

		return new Qualtrics.MenuPane(menuBuilder, parentButton, opt_parentMenu, options, evt);
	},
	isFixed:function(element)
	{
		if (element.parentNode)
		{
			return QualtricsTools.isFixed(element);
		}
		return false;
	},
	findMenu:function(menuBuilder)
	{
		for(var i=0, len=Qualtrics.Menu.menuPaneStack.length; i<len; ++i)
		{
			if(Qualtrics.Menu.menuPaneStack[i].menuBuilder == menuBuilder)
			{
				return Qualtrics.Menu.menuPaneStack[i];
			}
		}
	},
	removeMenuPaneFromStack:function(menuPane)
	{
		var i = menuPane.getStackIndex();
		//This makes sure we are removing the correct menu from the stack.
		//In rare cases, the event is fired twice and too many menus were being removed from the stack
		if(Qualtrics.Menu.menuPaneStack[i] && Qualtrics.Menu.menuPaneStack[i].id == menuPane.id)
			Qualtrics.Menu.menuPaneStack.splice(i, 1);
	},
	/**
	* Qualtrics.Menu.getActiveMenuPane
	* returns the last menuPane that was opened
	*/
	getActiveMenuPane:function()
	{
		if(!Qualtrics.Menu.menuPaneStack.length)
		{
			return null;
		}
		return Qualtrics.Menu.menuPaneStack[Qualtrics.Menu.menuPaneStack.length-1];
	},
	/**
	* Qualtrics.Menu.getRootMenuPane
	* returns the first menuPane that was opened
	*/
	getRootMenuPane:function()
	{
		if(!Qualtrics.Menu.menuPaneStack.length)
		{
			return null;
		}
		return Qualtrics.Menu.menuPaneStack[0];
	},
	/**
	* Qualtrics.Menu.processVelocity
	* this is called every 100ms by the velocimeter.
	* if their horizontal velocity is less than 2px per 100ms then we are going to hide the active submenu.
	* OR if there is a submenu that was suppressed by fast horizontal movement, and now the movement has slowed
	* then we need to show that suppressed submenu.
	* @param {Array.<Number>} velocity - the x,y mouse velocity. eg: if they are moving strait up at 50px per 100ms it will be [0, -50]
	*/
	processVelocity:function(velocity)
	{
		//figure out what the active menu is (the parent of the outermost submenu)
		var activeSubMenuParentIndex = Qualtrics.Menu.menuPaneStack.length-2;
		var activeSubMenuIndex = Qualtrics.Menu.menuPaneStack.length-1;
		if(activeSubMenuParentIndex < 0) activeSubMenuParentIndex = 0;
		var activeParent = Qualtrics.Menu.menuPaneStack[activeSubMenuParentIndex];
		var activeSubMenu = Qualtrics.Menu.menuPaneStack[activeSubMenuIndex];
		if(!activeParent)
		{
			//if there is no menu then auto shut this thing down
			if(window.QualtricsCPTools)
				QualtricsCPTools.velocimeter.stop();
			Qualtrics.Menu.velocityProcessor = null;
			return;
		}
		var dir = activeSubMenu.forcedDirection || activeSubMenu.direction;
		if(dir == 'right' && velocity[0] < 2 || dir == 'left' && velocity[0] > -2)
		{
			activeParent.traveling = false;
		}
		else
		{
			activeParent.traveling = true;
			//they are moving their mouse horizontally so we are going to not hide the menu.
			//and traveling is true so we arent going to show any other menus either.
		}
		if(!activeParent.traveling && activeParent.hideSubMenuOnLowVelocity && activeParent.menuUl)
		{
			activeParent.hideSubMenu();
		}
		else if(activeParent.suppressedSubMenu && !activeParent.traveling)
		{
			//There is a suppressedSubMenu which means that they moused over a menu item that was supposed
			//to show a submenu. But they were traveling horizontally so it was suppressed.
			//They have now stopped moving their mouse, so we can now show the menu that was suppressed.

			//showing the menu will nullify the suppressedSubMenu so it wont get shown again
			activeParent.getSubMenuShowClosure(activeParent.suppressedSubMenu.menu, activeParent.suppressedSubMenu.button, activeParent.suppressedSubMenu.options)();
		}
	},
	processOptions:function(options)
	{
		options = options || {};
		if (typeof options == 'string')
		{
			try{
				options = options.evalJSON();
			}catch(e){
				console.error(e);
			}
		}
		return options;
	},
	/**
	* Qualtrics.Menu.documentDownHandler
	* checks to see if the mouse is inside the menu or the submenu if there is one.
	* if its OUTSIDE a menu then its just going to close the menu.
	* if its INSIDE the menu then it will do nothing. the mouse up events are responsible for closing the menu at that point. see: QMenu.flashSelectionAndDestroyMenu
	* @param {Event} evt - the mousedown Event
	*/
	documentDownHandler:function(evt)
	{
		if(!Qualtrics.Menu.documentObserver)
		{
			//if the observer has been removed then the mousedown is no longer useful. IE9 forgets this. Fixes bug #63706
			return;
		}
		//update the mousePos so that touch devices can figure out what was clicked
		var posX = evt.pageX;
		var posY = evt.pageY;

		// Check for Android touch event
		if(evt.touches && evt.touches[0] && evt.touches[0].pageX && evt.touches[0].pageY)
		{
			posX =  evt.touches[0].pageX;
			posY =  evt.touches[0].pageY;
		}
		window.mousePos = [posX, posY];
		if(Qualtrics.Menu.menuPaneStack.length)
		{
			//We close all menus if they didn't click on any menus in the menuPaneStack
			var clickedEl = Event.element(evt);

			var clickedMenu = clickedEl && $(clickedEl).up && $(clickedEl).up('#QMenu');
			if (clickedEl && clickedEl.id == 'QMenu')
			{
				clickedMenu = clickedEl;
			}

						//they clicked on something that was not a menu so just close all open menus
			if (!clickedMenu)
			{
				Qualtrics.Menu.destroyAllMenus();
				clearOverRegistry();
				return;
			}

			var menuClicked = null,
				menusToClose = [],
				menus = Qualtrics.Menu.menuPaneStack;

			//we need to propogate the fixed option for all submenus
			var isFixed = false;
			for (var i = 0, ilen = menus.length; i < ilen; ++i)
			{
				var menuPane = menus[i];
				menuPane.options.fixed = isFixed = !!(isFixed || menuPane.options.fixed || (menuPane.menuDef || {}).fixed);
			}

			//we loop backwards and close all panes that weren't clicked on
			for(i = menus.length; i--;)
			{
				var menuPane = menus[i],
					menu = menuPane.menuDom;

				if(!!menu && menu == clickedMenu)
				{
					menuClicked = menuPane;

					//we break assuming all menus created after this one have been pushed onto our menus to close array
					break;
				}
				else if(menuPane.menuUl && Event.element(evt) == menuPane.menuUl.openedByNode)
				{
					//they clicked on the button that opened the menu
					menusToClose.push(menuPane);
				}
				//if we get here then close the menu
				else if(Event.isLeftClick(evt))
				{
					if(menuPane.skipNextClose)
						menuPane.skipNextClose = false;
					else
						menusToClose.push(menuPane);
				}
			}

			if(menusToClose.length)
			{
				//we have more than 1 menu open but we only want to close specific menus
				//we only do this if its a menuWithinMenu menu
				for(var i=0,len=menusToClose.length; i<len; ++i)
				{
					if(menusToClose[i].options.menuWithinMenu && menusToClose[i] != menuClicked.parentMenu)
					{
						menusToClose[i].destroy(true);
					}
				}
				clearOverRegistry();
			}
		}
	},
	/**
	* Qualtrics.Menu.destroyAllMenus
	* destroys the outermost submenu and then recurses up the parents.
	*/
	destroyAllMenus:function()
	{
		var menus = Qualtrics.Menu.menuPaneStack;
		for(var i = menus.length; i--;)
		{
			if(menus[i])
				menus[i].destroy(true);
		}
	},
	unsuspendMenu:function(menuId)
	{
		var menuPane = Qualtrics.MenuPane.getInstance(menuId);
		if(menuPane){
			menuPane.setSuspend(false);
		}
	},
	destroyMenu:function(menuId)
	{
		var menuPane = Qualtrics.MenuPane.getInstance(menuId);
		if(menuPane){
			menuPane.destroy(true);
		}
	},
	deactivateArrowMode:function()
	{
		for(var i=Qualtrics.Menu.menuPaneStack.length-1; i > -1; --i)
		{
			Qualtrics.Menu.menuPaneStack[i].deactivateArrowMode();
		}
	},
	/**
	* Qualtrics.Menu.handleKeyDown
	*/
	handleKeyDown:function(evt, opt_allowOnInputs)
	{
		var el = Event.element(evt);
		{
			if(el.nodeName == 'INPUT' && !opt_allowOnInputs)
			{
				return;
			}
		}

		var keyActions = {
			40:'down',
			38:'up',
			39:'right',
			37:'left',
			13:'enter',
			27:'escape',
			8:'escape', //Backspace
			46:'escape' //Delete key
		};

		if (Qualtrics.Menu.getActiveMenuPane() && keyActions[evt.keyCode])
			Qualtrics.Menu[keyActions[evt.keyCode]](evt);
	},
	/**
	* Qualtrics.Menu.down
	*/
	down:function(evt)
	{
		if(evt)
		{
			Event.stop(evt);
		}
		var menuPane = Qualtrics.Menu.getActiveMenuPane();
		var item = menuPane.getActiveMenuItem();
		var noneWereSelected = false;
		if(!item)
		{
			if(Qualtrics.Menu.getActiveMenuPane().menuUl)
			{
				noneWereSelected = true;
				item = Qualtrics.Menu.getActiveMenuPane().menuUl.firstChild;
			}
		}

		if(item && (noneWereSelected || item.nextSibling))
		{
			var current;
			if (noneWereSelected)
				current = item;
			else
				current = item.nextSibling;

			var nextVisibleSibling = current;
			while (!current.visible() && (current.nextSibling))
			{
				if($(current.nextSibling).hasClassName('Separator') && current.nextSibling.nextSibling)
				{
					current = current.nextSibling.nextSibling;
				}
				else
				{
					current = current.nextSibling;
				}
				nextVisibleSibling = current;
			}
			if (nextVisibleSibling.visible())
				menuPane.selectItem(nextVisibleSibling);
		}
	},
	up:function(evt)
	{
		if(evt)
		{
			Event.stop(evt);
		}

		var menuPane = Qualtrics.Menu.getActiveMenuPane();
		var item = menuPane.getActiveMenuItem();
		var noneWereSelected = false;
		if (!item)
		{
			var noneWereSelected = true;
			if(Qualtrics.Menu.getActiveMenuPane().menuUl)
			{
				menuPane.selectItem(Qualtrics.Menu.getActiveMenuPane().menuUl.lastChild);
			}
		}

		if(noneWereSelected || !item.previousSibling)
		{
			menuPane.focusSearch();
		}
		else
		{
			var current;
			if (noneWereSelected)
				current = item;
			else
				current = item.previousSibling;

			var prevVisibleSibling = current;
			while (!current.visible() && (current.previousSibling))
			{
				if($(current.previousSibling).hasClassName('Separator') && current.previousSibling.previousSibling)
				{
					current = current.previousSibling.previousSibling;
				}
				else
				{
					current = current.previousSibling;
				}
				prevVisibleSibling = current;
			}
			if (prevVisibleSibling.visible())
				menuPane.selectItem(prevVisibleSibling);
			else
				menuPane.focusSearch();
		}
	},
	right:function(evt)
	{
		var menuPane = Qualtrics.Menu.getActiveMenuPane();
		var item = menuPane.getActiveMenuItem();
		if(item)
		{
			var link = $(item).down && $(item).down();
			if(item && item.hasSubMenu)
			{
				if(link.getAttribute('submenu'))
				{
					menuPane.getDynamicSubMenuClosure(link.getAttribute('submenu'), link)();
					if(evt)
					{
						Event.stop(evt);
					}
				}
			}
			else
			{
				//act like a down if it has no submenu
				//Qualtrics.Menu.down();
			}
		}
	},
	left:function(evt)
	{
		var menuPane = Qualtrics.Menu.getActiveMenuPane();
		if(menuPane.parentMenu)
		{
			var parentLink = menuPane.parentButton;
			menuPane.destroy();
			if(parentLink && parentLink.parentNode.tagName == 'LI')
			{
				menuPane.selectItem.bind(menuPane, parentLink.parentNode).delay(1);
			}
			if(evt)
			{
				Event.stop(evt);
			}
		}
		else
		{
			//act like an up for non submenus
			//Qualtrics.Menu.up();
		}
	},
	enter:function(evt)
	{
		var menuPane = Qualtrics.Menu.getActiveMenuPane();
		var item = menuPane.getActiveMenuItem();
		menuPane.flashSelectionAndDestroyMenu();
		menuPane.artificiallyExecuteMenuItem(item);
	},
	escape:function(evt)
	{
		var menuPane = Qualtrics.Menu.getActiveMenuPane();

		//focus on the button if they escape, there is a chance it is an input from an auto suggest
		if (menuPane.parentButton.focus)
			menuPane.parentButton.focus();

		//if we need to select an input or something after the user escapes the menu such as in QComboBox
		if (menuPane.options.escapeCallback)
			Qualtrics.Event.execute(menuPane.options.escapeCallback);

		menuPane.destroy(true);
	},
	drawOutline:function()
	{
		var parentNode = $('pageDiv') || document.body;
		if(!Qualtrics.Menu.outlineContainer)
		{
			Qualtrics.Menu.outlineContainer = QBuilder('div',{className:'MenuOutlineContainer'});
		}
		if(!Qualtrics.Menu.outlineContainer.parentNode)
		{
			parentNode.appendChild(Qualtrics.Menu.outlineContainer);
		}

		Qualtrics.Menu.outlineContainer.innerHTML = '';
		for(var i=0,len=Qualtrics.Menu.menuPaneStack.length; i < len; ++i)
		{
			var m = Qualtrics.Menu.menuPaneStack[i];

			var bg = QBuilder('div',{className:'MenuOutline'});
			m.menuOutlineDom = bg;
			Qualtrics.Menu.outlineContainer.appendChild(bg);
			m.positionOutline();
		}
	},
	/**
	* Qualtrics.Menu.getAjaxData
	* behaves just like new Ajax.request() but will cache responses.
	* @param {String} url - the ajax url to use.
	* @param {Object} ajaxDef.parameters - any paramters and required by the ajax action
	* @param {Function} ajaxDef.onComplete - what you want to run after the ajax completes
	* @param {Number} opt_delay - number of milliseconds to delay the ajax, (this lets the server request be prevented if another request comes in before the delay is reached)
	* @param {String} source - id for this request, so we can clear the cache by id
	* @param {Boolean} allowAbort - whether we want to allow the active ajax request to finish
	*/
	getAjaxData:function(url, ajaxDef, opt_delay, source, allowAbort)
	{
		ajaxDef = ajaxDef || {};
		//as long as the current activeAjaxRequest allows itself to be aborted, abort. if not, let finish. such is the case
		//in loading a menu title from an ajax request.
		if(Qualtrics.Menu.activeAjaxRequest && allowAbort)
		{
			Qualtrics.Menu.activeAjaxRequest.abort();
		}
		//make the cache if it does not yet exist
		//if(!Qualtrics.Menu.ajaxDataCache)
		//{
		//	Qualtrics.Menu.ajaxDataCache = {};
		//}

		//setup the uniqueId to distiguish one ajax request from another
		//var uniqueId = url;
		//if(ajaxDef.parameters)
		//{
			//we need to make sure that the parameters are included in the uniqueId. or it wouldnt be very unique.
		//	uniqueId = uniqueId+'_'+$H(ajaxDef.parameters).keys().join('|')+'_'+$H(ajaxDef.parameters).values().join('|');
		//}

		//if our request is cached we are going to just run the onComplete defered so it acts like a really fast ajax request
		//if(Qualtrics.Menu.ajaxDataCache[uniqueId])
		//{
			//if(ajaxDef.onComplete)
			//{
			//	ajaxDef.onComplete.curry({responseText:Qualtrics.Menu.ajaxDataCache[uniqueId]}).defer();
			//}
			//return;
		//}
		if(Qualtrics.Menu.activeAjaxTimer)
		{
			//cancel any queued ajax requests
			clearTimeout(Qualtrics.Menu.activeAjaxTimer);
		}
		var executeAjax = function(){
			Qualtrics.Menu.activeAjaxTimer = null;
			//Qualtrics.Menu.ajaxDataCache[uniqueId] = '#loading#'
			Qualtrics.Menu.activeAjaxRequest = new Ajax.CachedRequest(url,{
				source: source,
				parameters:ajaxDef.parameters,
				onComplete:function(transport){
					if (ajaxDef.onComplete)
					{
						ajaxDef.onComplete(transport);
					}

					Qualtrics.Menu.activeAjaxRequest = null;
				},
				onFailure:function(transport)
				{
					console.error('ajax fail');
					//Qualtrics.Menu.ajaxDataCache[uniqueId] = '#failed#';
				}
			});
		};
		//we need to delay the ajax just so we dont request and abort a bunch of pointless stuff if someone swipes arross menu full of ajax submenus.
		if(opt_delay)
		{
			Qualtrics.Menu.activeAjaxTimer = setTimeout(executeAjax, opt_delay);
		}
		else
		{
			executeAjax();
		}
	},
	getMultiAjaxData:function(requests, ajaxDef, opt_delay, allowAbort)
	{
		ajaxDef = ajaxDef || {};
		//if any other ajax requests are waiting to come back, abort them as long as they allow themselves to be aborted
		//for example, don't abort if we're loading a title for the menu
		if(Qualtrics.Menu.activeAjaxRequest && Qualtrics.Menu.activeAjaxRequest.abort && allowAbort)
		{
			Qualtrics.Menu.activeAjaxRequest.abort();
		}
		if(Qualtrics.Menu.activeAjaxTimer)
		{
			//cancel any queued ajax requests
			clearTimeout(Qualtrics.Menu.activeAjaxTimer);
		}
		var executeAjax = function(){
			Qualtrics.Menu.activeAjaxTimer = null;
			//Qualtrics.Menu.ajaxDataCache[uniqueId] = '#loading#'
			Qualtrics.Menu.activeAjaxRequest = new Ajax.MultipleCachedRequest(requests,{
				onComplete:function(transport){
					if (ajaxDef.onComplete)
					{
						ajaxDef.onComplete(transport);
					}
					Qualtrics.Menu.activeAjaxRequest = null;
				},
				abort:function()
				{

				}
			});
		};
		if(opt_delay)
		{
			Qualtrics.Menu.activeAjaxTimer = setTimeout(executeAjax, opt_delay);
		}
		else
		{
			executeAjax();
		}
	},
	/**
	* Qualtrics.Menu.keepMenuOpen();
	* prevents the menu from closing.
	* any function that is called by the menu can call this to keep the menu from closing itself.
	*/
	keepMenuOpen:function()
	{
		//we dont want these selection events to double up.
		//if(QMenu.selectionNode)
		//{
		//	Event.stopObserving(QMenu.selectionNode, 'mouseup', QMenu.destroyMenu);
		//}
		//stop the timer than closes the menu.
		if(Qualtrics.Menu.menuCloseTimer)
		{
			clearTimeout(Qualtrics.Menu.menuCloseTimer);
		}
	},
	/**
	* Qualtrics.Menu.toggleCheck();
	* toggles the check class on an LI element.
	* @param {HTMLLiElement} li - the li menu item.
	* @param {Object} - options object.
	@ @param {Boolean} - options.selectOne. if set to true will turn on exclusive checking. (uncheck all the siblings)
	*/
	toggleCheck:function(li, options)
	{
		if(li){
			if(options && options.selectOne){
				if(li.getAttribute('menugroup'))
				{
					//restrict the unchecking to only items matching the menu group
					options.group = li.getAttribute('menugroup');
				}
				Qualtrics.Menu.uncheckAll(li.parentNode, options);
				$(li).addClassName('check');
			}else{
				if($(li).hasClassName('check')){
					$(li).removeClassName('check');
				}else{
					$(li).addClassName('check');
				}
			}
		}
	},
	/**
	* Qualtrics.Menu.toggleCheckByEvent:
	* this will toggle a check mark for an item in a menu BY EVENT.
	* there is another toggleCheck in the results section which works by id.
	*/
	toggleCheckByEvent:function(evt, options)
	{
		if(evt)
		{
			evt.cancelBubble= true;
			var li = (Event.findElement(evt, 'li'));
			Qualtrics.Menu.toggleCheck(li, options);
		}
	},
	nodeHasGroup:function(node, groups)
	{
		for(var i=0,len=groups.length; i<len; ++i)
		{
			var valid = false;
			//check to make sure the li group is found within an array of groups
			if(node.getAttribute('menugroup') == groups[i])
			{
				return true;
			}
		}
		return false;
	},
	/**
	* Qualtrics.Menu.uncheckAll();
	* unchecks all LI elements in the UL
	* @param {HTMLUlElement} - the menu UL
	*/
	uncheckAll:function(ul, options)
	{

		if(ul){
			var childs = $(ul).immediateDescendants();
			for(var i=0,len=childs.length; i<len; ++i){
				var li = childs[i];
				if(options && options.group)
				{
					if(li.getAttribute('menugroup') != options.group)
					{
						continue;
					}
				}
				if(options && options.groups)
				{
					if(!Qualtrics.Menu.nodeHasGroup(li, options.groups))
					{
						continue;
					}
				}
				$(li).removeClassName('check');
			}
			childs=null;
		}
	},
	positionMenus:function(opt_updateButtonInfo)
	{
		for(var i=0, len=Qualtrics.Menu.menuPaneStack.length; i<len; ++i)
		{
			var menuPane = Qualtrics.Menu.menuPaneStack[i];
			//it doesnt make any sense to position (or more likely reposition) multiple menus that are positioned based on the current mouse position.
			//so only do it if its not mousePosition
			if(!menuPane.options.mousePosition)
			{
				menuPane.positionMenu(null, opt_updateButtonInfo);
			}
		}
	},
	hideMenuOnMouseOut:function()
	{
		var menu = $('QMenu');
		if(menu)
		{
			$(menu).setStyle({opacity:0.85});
			menu.onmouseout = Qualtrics.Menu.beginHideMenuSequence;
			menu.onmouseover = Qualtrics.Menu.cancelHideMenuSequence;
		}
	},
	beginHideMenuSequence:function()
	{
		var menu = $('QMenu');
		if(menu)
		{
			Qualtrics.Menu.fadeEffect = setTimeout(Qualtrics.Menu.destroyAllMenus, 500);
		}
	},
	cancelHideMenuSequence:function()
	{
		if(Qualtrics.Menu.fadeEffect)
		{
			clearTimeout(Qualtrics.Menu.fadeEffect);
		}
	},
	refreshMenu:function(i)
	{
		var a = i && Qualtrics.Menu.menuPaneStack[i] || Qualtrics.Menu.getActiveMenuPane();

		if(a)
		{
			a.refreshMenu();
		}
	},
	refreshAllMenus:function()
	{
		for(var i=Qualtrics.Menu.menuPaneStack.length-1; i>-1; --i)
		{
			Qualtrics.Menu.menuPaneStack[i].refreshMenu();
		}
	},
	openMenuHelper:function(evt)
	{
		if(Qualtrics.Menu.menuPaneStack.length)
		{
			//if there is an open menu set a flag so the menu doesnt open on the next click
			Qualtrics.Menu.skipNextOpen = Qualtrics.Menu.menuPaneStack[0].menuBuilder;
		}
	}
};

/**
* Qualtrics.MenuPane is the menu pane manager. It contains no user methods
* It is used by the static class Qualtrics.Menu and by itself to create submenus.
* all menuPanes have a this.parentButton
* if a menuPane has a this.parentMenu then its a submenu.
*/
Qualtrics.MenuPane = Class.create();
Qualtrics.MenuPane.getInstance = QualtricsTools.getInstanceHelper(Qualtrics.Menu.menuPaneStack, 'id');
Qualtrics.MenuPane.getInstanceByName = QualtricsTools.getInstanceHelper(Qualtrics.Menu.menuPaneStack, 'menuPaneName');
/**
* @param {Boolean} options.useOverlay - set to true if you need an overlay instead of just a document click observer. this is useful if you are dealing with iframes.
* @param {Boolean} options.menuWithinMenu - set to true if you don't want to close all open menus automatically before this menu is displayed AND you want to skip the first menu destroy.
* @param {Boolean} options.allowMultipleMenus - set to true if you don't want to close all open menus automatically before this menu is displayed
*/
Qualtrics.MenuPane.prototype = {
	type:'MenuPane',
	destroyed:false,//this is used in QAutoSuggest to figure out if a menu has been destroyed.
	direction:null,
	alignment:null,
	parentMenu:null, //not a submenu by default
	parentButton:null, //this should always be set to whatever triggered the menu,
	arrowSelectedItem:null, //an item that has been selected with arrowkeys as opposed to mousing over it,
	closeSubMenuOnMouseOut:false, //set to true if you don't like submenus staying open after you mouse out of them,
	onClose:null, //set to a function that you want to run when the root menu is closed
	fieldName:null,//this can point to a field that recieves values from a selectMenu
	needsMouseOverEventObserver:null,//if you set this to true you can use menupanemouseover callbacks inside the menupane
	paginate:false, //Set to true if the submenu in question uses pagination
	perpage:null,
	startIndex:0,
	searchTerm:null, //This will persist Search boxes when using an Ajax search
	startMousePos:null,
	menuPaneName:null,
	suspend:false,
	initialize:function(menuBuilder, parentButton, opt_parentMenu, options, opt_evt)
	{
		if(typeof options == 'string')
		{
			options = options.evalJSON();
		}
		this.id = QualtricsTools.createNewId('MP');
		options = this.options = options || {};
		this.menuBuilder = menuBuilder;
		this.parentMenu = opt_parentMenu;
		this.parentButton = parentButton;

		this.buttonInfo = {};

		if(this.parentButton)
		{
			this.getButtonInfo();

			if(this.parentButton.getAttribute('currentvalue') !== undefined)
			{
				this.currentValue = this.parentButton.getAttribute('currentvalue');
				//convert the string null to an actual null.
				if(this.currentValue === 'null')
				{
					this.currentValue = null;
				}
			}
		}
		if(options.initialValue && !this.currentValue)
		{
			this.currentValue = options.initialValue;
		}
		//store the mouse position of when the menu opened
		//a menu click is only valid if they have moved their mouse a sufficient amount
		this.startMousePos = [window.mousePos[0], window.mousePos[1]];

		if(this.options.fieldName)
		{
			this.fieldName = this.options.fieldName;
		}
		if(!this.parentMenu && !this.options.menuWithinMenu && !this.options.allowMultipleMenus && !options.headless)
		{
			//make sure there are no menus before we create a root menu
			Qualtrics.Menu.destroyAllMenus();
		}
		if(this.options.menuWithinMenu)
		{
			//the previous menu is going to close our menu right after it opens when it runs through the documentDownHandler
			//so setting this flag will just skip the close.
			//I wish I could figure out a more elegent solution to this problem.
			this.skipNextClose = true;
		}
		//add this menuPane to the menu stack
		Qualtrics.Menu.menuPaneStack.push(this);


		//construct the menu (build and setup and encapsulate)
		if(!options.headless && (this.options.asynchronous))
		{
			this.constructAsynchronousMenu(menuBuilder, this.options, opt_evt);
		}
		else
		{
			this.constructMenu(menuBuilder, this.options, opt_evt);
		}


		this.direction = this.options.direction || this.getAutoDirection();
		this.alignment = this.options.alignment || this.getAutoAlignment();

		//headless menus are only instantiated to parse their definitions
		//they are not rendered.
		if(!options.headless)
		{
			//put it on the page and position it
			this.insertMenu();

			if(this.needsMouseOverEventObserver)
			{
				Event.observe(this.menuDom, 'mouseover',this.distributeMouseOvers.bind(this));
			}
			if(this.options.onMenuOpen)
			{
				Qualtrics.Event.executeDotSyntax(options.onMenuOpen, null, null, null, {'$menuPane':this, '$menuPaneId':this.id});
			}
			if(this.menuDef && this.menuDef.onMenuOpen)
			{
				Qualtrics.Event.executeDotSyntax(this.menuDef.onMenuOpen, null, null, null, {'$menuPane':this, '$menuPaneId':this.id});
			}
		}
	},
	distributeMouseOvers:function(evt)
	{
		evt = evt || window.event;
		Qualtrics.Event.baseDistributerReader(evt, Event.element(evt), 'menupanemouseover', this.mouseOverObject || this);
	},
	insertMenu:function()
	{
		//put the menu on the page (if it isn't already)
		if(this.menuDom)
		{
			var parentNode = this.options.parentNode || $('pageDiv') || document.body;
			if(this.options.relative)
			{
				$(this.parentButton).setStyle({position:'relative'});
				parentNode = this.parentButton;
			}

			if(parentNode !== this.menuDom.parentNode)
			{
				parentNode.appendChild(this.menuDom);
			}

			this.setupSubMenus();

			//position the menu
			this.positionMenu();

			if(this.searchInputDom)
			{
				QualtricsTools.focusInput(this.searchInputDom, 0);
			}
			//set up the observers to remove the menu
			//we are either going to just put a mousedown on the document observer OR make an overlay.
			//an overlay will be more reliable but slower, so choose wisely.
			//also note that it will only set 1 up for all active menus and submenus.
			this.setupRemoveObserver.bind(this).defer();
		}
	},
	setupRemoveObserver:function()
	{
		if(!Qualtrics.Menu.documentObserver && !Qualtrics.Menu.overlayObj)
		{
			if(this.options.useOverlay)
			{
				Qualtrics.Menu.overlayObj = new Q_Overlay({
					parentId:'pageDiv',
					zindex:1999997,
					opacity:0,
					dontManageOverlays:true,
					onClick:function(){
						Qualtrics.Menu.overlayObj.remove();
					},
					onClose:function(){
						Qualtrics.Menu.destroyAllMenus.defer();
						clearOverRegistry();
					}
				});
			}
			else
			{
				Qualtrics.Menu.documentObserver = Event.observe(document,'mousedown', Qualtrics.Menu.documentDownHandler);
				Qualtrics.Menu.documentTouchObserver = Event.observe(document,'touchstart', Qualtrics.Menu.documentDownHandler);
			}
		}
	},
	/**
	 * load the real menu defered and return a loading graphic.
	 **/
	constructAsynchronousMenu:function(menuBuilder, opt_options, opt_evt)
	{
		this.menuDom = QBuilder('div',{className:'RoundedShadow',id:'QMenu'},[QBuilder('ul',{className:'Loading'},[
			QBuilder('li',{className:'Loading'})
		])]);
		//only 1 at a time
		if(Qualtrics.Menu.asyncMenuTimout)
		{
			clearTimeout(Qualtrics.Menu.asyncMenuTimout);
			Qualtrics.Menu.asyncMenuTimout = null;
		}
		Qualtrics.Menu.asyncMenuTimout = this.showAsynchronousMenu.bind(this).delay(0.2);
		return this.menuDom;
	},
	showAsynchronousMenu:function(menuBuilder, opt_options, opt_evt)
	{
		this.replaceMenuDefinition(menuBuilder);
	},
	/**
	* Qualtrics.MenuPane.constructMenu
	* @param {Mixed} menuBuilder
	* @param {Object} opt_options - options
	* @param {Event} opt_evt - was pass the event through in case the buildMenu script wants to use the $evt param to check modifier keys
	* @return {DomNode} - the menu pane dom
	**/
	constructMenu:function(menuBuilder, opt_options, opt_evt)
	{
		var menu = this.buildMenu((menuBuilder || this.menuBuilder), opt_options, opt_evt);
		if(menu)
		{
			if(this.parentButton)
			{
				$(this.parentButton).addClassName('ActiveSubMenu');
			}
			if(this.parentMenu)
			{
				this.menuDom = menu;
				//add the active submenu classes to the parent menu
				this.addClassNames();
				//we add HasActiveSubMenu to the parent UL so it doesn't do hovers while a submenu is active.
				$(this.parentMenu.menuUl).addClassName('HasActiveSubMenu');
			}
			else
			{
				//encapsuate the root menu inside of a QMenu div (this gives our menu its default styles)
				var className = '';

				if (this.options.className)
				{
					className = this.options.className;
				}
				if(this.menuDef && this.menuDef.className)
				{
					className += ' '+this.menuDef.className;
				}
				if(this.options.outline)
				{
					className += ' DarkShadow';
				}
				else
				{
					className += ' RoundedShadow';
				}

				//If it is coming from evaluateAjaxMenu, it could be returning this.menuDom again, so we just strip it of it's children and add it to this identical div'
				if(menu.id == 'QMenu' && menu.firstChild)
					menu = menu.firstChild;

				this.menuDom = QBuilder('div',{className:className,id:'QMenu'},[menu]);
			}
			if(this.options.relative)
			{
				//ie wont give us our zindex if the menu button is lower than the menu.
				$(this.parentButton).setStyle({zIndex:$(this.menuDom).getStyle('zIndex')|| 2000000});
				$(this.menuDom).addClassName('RelativelyPositioned'); //this is so we can fix an IE7 bug
			}
			if(!this.menuUl)
			{
				//if there is no ul then find the UL of the menu and cache it for later use. (we assume there a UL somewhere in the menu)
				if(this.menuDom.tagName == 'UL')
				{
					this.menuUl = this.menuDom;
				}
				else
				{
					this.menuUl = $(this.menuDom).down('ul');
				}
			}
		}
		return this.menuDom;
	},
	getButtonInfo:function(opt_update)
	{
		if(opt_update || !this.buttonInfo || !this.buttonInfo.height || !this.buttonInfo.width || !this.buttonInfo.top || !this.buttonInfo.left)
		{
			if(this.parentButton && this.parentButton.offsetHeight != undefined && this.parentButton.offsetWidth != undefined)
			{
				this.buttonInfo = Object.extend({height:this.parentButton.offsetHeight, width:this.parentButton.offsetWidth},this.getButtonPos());
			}
		}
		return this.buttonInfo;
	},
	refreshMenu:function(opt_clearCache)
	{
		if(opt_clearCache)
		{
			Ajax.CachedRequest.clearCache();
		}
		this.replaceMenuDefinition(this.menuBuilder);
	},
	addClassNames:function()
	{
		if(this.parentMenu)
		{
			$(this.menuDom).addClassName('QSubMenu');
		}
		if (this.options.className)
		{
			$(this.menuDom).addClassName(this.options.className);
		}
		if(this.options.outline)
		{
			$(this.menuDom).addClassName('DarkShadow');
		}
		else
		{
			$(this.menuDom).addClassName('RoundedShadow');
		}
	},
	getRootMenu:function()
	{
		var root = this;
		while(root.parentMenu)
		{
			root = root.parentMenu;
		}
		return root;
	},
	getAppropriateOffset:function()
	{
		//if the menu is positioned relative we return the cumulative offset but if its positioned absolute we return the regular offset
		return this.options.relative?Position.cumulativeOffset(this.menuDom):{left:this.menuDom.offsetLeft, top:this.menuDom.offsetTop};
	},
	getCumulativeOffset:function()
	{
		//we are going to manually figure this out to account for borders on all the parent menus. cumulativeOffset doesn't handle it very well in ie.
		var offset = this.getAppropriateOffset();

		var root = this;
		while(root.parentMenu)
		{
			root = root.parentMenu;
			var border = root.getBorderWidth();
			var currentOffset = root.getAppropriateOffset();
			offset.left += currentOffset.left+border;
			offset.top += currentOffset.top+border;
			if(Qualtrics.Browser.IE)
			{
				offset.left -=1;//lame
				offset.top -=1;//lame
			}
		}
		return offset;
	},
	getBorderWidth:function()
	{
		if(window.getComputedStyle){
			var border = getComputedStyle(this.menuDom, '').getPropertyValue('border-top-width');
		} else {
			var border = this.menuDom.currentStyle.borderWidth;
		}
		return Number(border.substring(0, border.length-2));
	},
	getStackIndex:function()
	{
		return Qualtrics.Menu.menuPaneStack.indexOf(this);
	},
	buildMenu:function(menuBuilder, opt_options, opt_evt)
	{
		if(typeof menuBuilder == 'string')
		{
			if(menuBuilder.startsWith('{'))
			{
				this.menuDom = this.evaluateMenuDefinition(menuBuilder, opt_options);
			}
			else if(menuBuilder.endsWith(')') && (menuBuilder.indexOf("'") != -1 || menuBuilder.indexOf('"') != -1))
			{
				//if they are passing params with quotes then we need to do eval. because the dotsyntax parser cant handle quotes. yet.
				console.warn('buildMenu had to resort to eval, try to avoid this');
				this.menuDom = this.buildMenu(eval(menuBuilder), opt_options);
			}
			else if(menuBuilder.indexOf('.') != -1)
			{
				var paramIndex = 1;
				var params = null;
				while(paramIndex !== null)
				{
					 var param = this.options['p'+paramIndex];
					 if(param !== undefined)
					 {
						if(!params) params = [];
						//there is a param at the index so maybe theres another one also.
						params.push(param);
						paramIndex++;
					 }
					 else
					 {
						//we are out of params.
						paramIndex = null;
					 }
				}
				var ctrlKeyPressed = false;
				var altKeyPressed = false;
				if(opt_evt)
				{

					ctrlKeyPressed = opt_evt.metaKey || opt_evt.ctrlKey;
					altKeyPressed = opt_evt.altKey;
				}
				this.menuDom = this.buildMenu(Qualtrics.Event.executeDotSyntax(menuBuilder, this.options.instanceid, null,params,{
				'$options':this.options,
				'$el':this.parentButton,
				'$evt':opt_evt,
				'$parentMenu':this.parentMenu,
				'$menuPane':this,
				'$menuPaneId':this.id,
				'$ctrlKey':ctrlKeyPressed,
				'$altKey':altKeyPressed
				}),opt_options);

			}
			else
			{
				//DEPRECATED LEGACY CODE
				//must be an id of an dom node already built and on the page somewhere
				//this is to support legacy menus and is a very bad way to use menus. DONT DO THIS!
				console.warn('legacy menu');
				if($(menuBuilder))
				{
					var ul = $(menuBuilder);
					if(!Qualtrics.Menu.prebuiltMenuCache)
					{
						Qualtrics.Menu.prebuiltMenuCache = {};
					}
					//store the ul, because we are going to need to use it again after we destroy it later.
					Qualtrics.Menu.prebuiltMenuCache[menuBuilder] = ul;
					this.menuDom = ul;
				}
				else if(Qualtrics.Menu.prebuiltMenuCache && Qualtrics.Menu.prebuiltMenuCache[menuBuilder])
				{
					this.menuDom = Qualtrics.Menu.prebuiltMenuCache[menuBuilder];
				}

			}
		}
		else if(typeof menuBuilder == 'function')
		{

			if(this.options.scope)
			{
				//run the function in the specified scope
				this.menuDom = this.buildMenu(menuBuilder.call(this.options.scope, this.options.p1, this.options.p2), opt_options);
			}
			else
			{
				//just run it in the global scope (pass a binded menuBuilder it if you want to change the scope)
				this.menuDom = this.buildMenu(menuBuilder(), opt_options);
			}
		}
		else if(typeof menuBuilder == 'object')
		{
			//Assume that if it is not a dom node it is a menu definition
			if (!menuBuilder.tagName)
			{
				this.menuDom = this.evaluateMenuDefinition(menuBuilder, opt_options);
			}
			else
			{
				//if a dom node is passed we are going to assume that its a submenu and its already built and attached to our menu tree
				//NOTE:this is for submenus, not prebuilding your menus. don't prebuild your menus please. menus should be built just in time.
				this.menuDom = menuBuilder;
			}
		}
		if(this.menuDom)
		{
			this.observeMenuUp(this.menuDom);
		}
		return this.menuDom;
	},
	getCheckedItems:function()
	{
		var menuDef = this.menuDef;
		var liNodes = this.menuUl.childNodes;
		var checkedItems = [];
		for(var i=0,len=liNodes.length; i<len; ++i)
		{
			var li = liNodes[i];
			var link = li.firstChild;
			if(link && link.getAttribute)
			{
				var itemIndex = link.getAttribute('itemindex');
				if($(li).hasClassName('check'))
				{
					var itemCopy = Object.toJSON(menuDef.items[itemIndex]).evalJSON();
					itemCopy.index = itemIndex;
					checkedItems.push(itemCopy);
				}
			}
		}
		return checkedItems;
		//var menuDef = this.getMenu
	},
	/**
	* This is used to maintain support for legacy menus,
	* it converts old responses from qsuggests to the new menu def format.
	*/
	createMenuDefFromFlatObject:function(obj)
	{
		var items = [];
		for(var key in obj)
		{
			items.push({display:obj[key], value:key});
		}
		return {items:items};
	},
	onSuperMenuSelect:function(value, itemDef, opt_key)
	{
		if(!this.superMenuInfo)
		{
			this.superMenuInfo = {};
		}
		this.superMenuInfo.value = value;
		this.superMenuInfo.selectedItem = itemDef;
		if(opt_key)
		{
			this.superMenuInfo.key = opt_key;
		}
		this.refreshMenu(true);
	},
	evaluateMenuDefinition:function(def, options)
	{
		def = def || {}; //make sure we have something to work with
		options = options || {}; //make sure we have something to work with
		if(typeof def == 'string')
		{
			if(!def.startsWith('{'))
			{
				return this.evaluateMenuDefinition(Qualtrics.Event.executeDotSyntax(def.callback));
			}
			try{
				def = def.evalJSON();
			}catch(e)
			{
				console.error('Could not evaluate JSON of Menu Def; setting to empty.');
				def = {};
			}
		}
		if(def.menuPaneName)
		{
			this.menuPaneName = def.menuPaneName;
		}
		if(def.ajax)
		{
			return this.evaluateAjaxMenu(def);
		}
		if(def.multiAjax)
		{
			return this.evaluateMultipleAjaxMenu(def);
		}

		this.menuDef = def;

		//store how many items we had before we process the definition.
		this.originalItemCount = 0;
		if(def.items)
		{
			this.originalItemCount = def.items.length;
		}
		//this is used to process dynamic definitions (like an ajax def) before items are added
		//360 invite auto completer uses this to add a link to the bottom of the list.
		if(this.options.processDefinition)
		{
			def = this.options.processDefinition(def, this.options);
		}
		//check to see if there is anything in the def

		if(Object.values(def).length)
		{
			var menuAttributes = {};

						//if they want to keep the menu open no matter what
						if(def.keepmenuopen)
						{
								this.options.keepmenuopen = def.keepmenuopen;
						}
						if(def.addMouseOverObserver)
			{
				this.needsMouseOverEventObserver = true;
			}
			if(def.menuClass)
			{
				menuAttributes.className = def.menuClass;
			}
			if(this.options.menuClass)
			{
				menuAttributes.className = this.options.menuClass;
			}
			if(def.className)
			{
				menuAttributes.className = def.className;
			}
			if(def.id)
			{
				menuAttributes.id = def.id;
			}

			this.menuUl = QBuilder('ul',{className:'QMenuList'});
			if(def.width)
			{
				this.menuUl.style.width = def.width+'px';
			}
			if(def.className)
			{
				this.menuUl.className = def.className;
			}
			//header stuff
			var header = document.createDocumentFragment();
			if(def.superMenu)
			{
				var superMenuDisplay = def.superMenu.display || '';
				if(this.superMenuInfo && this.superMenuInfo.selectedItem && this.superMenuInfo.selectedItem.display)
				{
					superMenuDisplay = this.superMenuInfo.selectedItem.display;
				}
				header.appendChild(QBuilder('div',{className:'SuperMenuContainer'},[
					QBuilder('div',{className:'SuperMenuPositioner'},[
						Qualtrics.Menu.buildMenuButton(superMenuDisplay,def.superMenu.menu,{
							selectMenu:true,
							menuWithinMenu:true,
							menuItemSelectCallback:'Qualtrics.MenuPane.onSuperMenuSelect:'+this.id+'($value, $item, '+def.superMenu.key+')'
						}),
						QBuilder('div',{className:'BottomHighlight'}),
						QBuilder('div',{className:'clear'})
					])
				]));
			}
			if(def.title)
			{
				this.headerDom = this.buildHeader(QBuilder('h2',{},[def.title]));
			}
			if(def.header)
			{
				this.headerDom = this.buildHeader(def.header);
			}
			if(this.headerDom)
			{
				header.appendChild(this.headerDom);
			}
			if(def.search)
			{
				var autoClear = getMessage('SiteWide','Search')+'...';
				//custom autoclear if there is a search text and its not the search term
				if (def.searchText && this.searchTerm != def.searchText)
					autoClear = def.searchText;

				var searchInput = QBuilder('input',{type:'text', className:'TextBox AutoClearMessage', keyupcallback:'Qualtrics.MenuPane.search:'+this.id+'($val, $el, $evt)', autoclear:autoClear, value:this.searchTerm || autoClear});
				this.searchInputDom = searchInput;
				var searchDom = QBuilder('div',{className:'MenuSearch'},[
					QBuilder('div',{},[
						QBuilder('span',{className:'Icon'}),
						this.searchInputDom
					])
				]);
				header.appendChild(searchDom);

				//now you can use your arrow/enter keys to select menu items. The search stays put until they delete it all.
				Event.observe(this.searchInputDom,'keydown', function(evt){
					try
					{
						if (evt){
							if (evt.keyCode == Event.KEY_ESC) //esc will hold the menu in place as you are searching
							{
								if (searchInput.value == '')
								{
									searchInput.addClassName('AutoClearMessage');
									searchInput.value = autoClear;
								}
								Qualtrics.Menu.escape();
							}
							else if (evt.keyCode == Event.KEY_DOWN)
							{
								Event.stop(evt);
								searchInput.blur();
								Qualtrics.Menu.down();
							}
							else if (evt.keyCode == Event.KEY_RETURN)
							{
								Event.stop(evt);
								searchInput.blur();
								Qualtrics.Menu.enter();
							}
						}
					}
					catch (e)
					{
						console.error(e);
					}
				});
			}

			if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 8)
			{
				//just set an arbitrary width on ie7 other wise the search box will push the menu out to full screen
				if(this.searchInputDom)
				{
					$(this.searchInputDom).setStyle({width:'200px'});
				}
			}
			this.menuDom = QBuilder('div',menuAttributes,[
				QBuilder('div',{className:'OverflowWrapper'},[
					header,
					this.menuUl
				])
			]);

			/**
			* you can use the menuDef property 'domNode' to define a function (as a dotSyntax string) that returns an arbitrary dom node to be used as the menu.
			* This allows you to have custom menus, but ALSO use some of the dynamic menu options that are available when using a menuDef.
			**/
			if(def.domNode)
			{
				var domNode = Qualtrics.Event.executeDotSyntax(def.domNode);
				if(domNode)
				this.menuDom = domNode;
				if(def.width)
				{
					this.menuDom.style.width = def.width+'px';
				}
			}
			if(def.height)
			{
				this.options.height = def.height;
			}
			if(def.items)
			{

				this.addMenuItems(def.items,options);
			}
			if(def.loading)
			{
				this.menuUl.appendChild(QBuilder('li',{className:'Loading'}));
			}
			else if(this.paginate) // Else if, because we don't want to put the pagination if it's still loading
			{
				this.menuDom.appendChild(this.buildPagination(def.count));
			}
			if(def.string)
			{
				this.menuUl.appendChild(QBuilder('li',null,[QBuilder('a',{className:'MenuItemLink'},def.string)]));
			}

			this.observeMenuUp(this.menuDom);
		}

		this.menuIsEvaluated();
		if(this.options.connector)
		{
			this.menuDom.appendChild(QBuilder('div',{className:'MenuConnector'},[
				QBuilder('div',{className:'A'}),
				QBuilder('div',{className:'B'})
			]));
		}
		return this.menuDom;
	},
	buildPagination:function(count)
	{
		var prev = '', next = '';
		if (this.startIndex > 0)
			prev = QBuilder('a',{className:'Pagination left',clickcallback:'Qualtrics.MenuPane.prevPage:'+this.id}, getMessage('SiteWide', 'PaginatePrevious'));
		if (this.startIndex + this.perpage < count)
		{
			next = QBuilder('a',{className:'Pagination right',clickcallback:'Qualtrics.MenuPane.nextPage:'+this.id}, getMessage('SiteWide', 'PaginateNext'));
		}
		return QBuilder('div',{className:'Pagination'},[
			prev,
			next,
			QBuilder('div',{className:'clear'})
		]);
	},
	buildHeader:function(content)
	{
		var domNode;
		if(typeof content == 'string')
		{
			var parsedExpression = content.replace('$menuPaneId', this.id);
			//we make the dotSyntax evaluation silent since they could be wanting a string, not an evaluated function!
			domNode = Qualtrics.Event.executeDotSyntax(parsedExpression,null,null,null,null,null,true) || content;
		}
		else
		{
			//assume they are passing a strait dom
			//this might break things, menu definitions are better as strict json.
			domNode = content;
		}
		return QBuilder('div',{className:'Header MenuHeader'},[domNode]);
	},
	updateHeader:function(content)
	{
		deleteChildren(this.headerDom);
		if(typeof content == 'string')
		{
			this.headerDom.innerHTML = content;
		}
		else
		{
			this.headerDom.appendChild(content);
		}
	},
	menuIsEvaluated:function()
	{
		//check to see if someone wants to run something special
		if(this.onShowMenu)
		{
			this.onShowMenu(this.options);
		}
	},
	evaluateAjaxMenu:function(def)
	{
		if(!def.ajax)
		{
			return false;
		}
		var delay = def.delay || false;
		if(this.parentMenu)
		{
			//we delay submenus to give them a chance to be canceled before we actually make a server request
			delay = 200;
		}
		if(!def.ajax.parameters)
		{
			def.ajax.parameters = {};
		}
		var action = def.ajax.action;


		var url = def.ajax.url;
		var queryParams = def.ajax.queryParams;

		//check to see if we need to do a cross site url.
		//if they start it with http we are going to need to call a same domain url that proxies the request.
		if(url && url.startsWith && url.startsWith('http'))
		{
			action = 'WebService';
			def.ajax.parameters.url = def.ajax.url;
			url = URLTools.getCleanAjaxURL(action, null, queryParams);
		}
		else if(action)
		{
			url = URLTools.getAjaxURL(action, null, queryParams);
		}

		if (def.paginate && !this.paginate)
		{
			this.paginate = true;
			this.perpage = def.perpage;
		}
		if (this.paginate)
		{
			def.ajax.parameters.start = this.startIndex;
			def.ajax.parameters.perpage = this.perpage;
		}
		if (!this.searchTerm)
			var loadingDom = this.evaluateMenuDefinition({loading:true, fixed:def.ajax.fixed, className:def.className});
		else
		{
			def.ajax.parameters.Search = this.searchTerm.toLowerCase();
		}

		var source = undefined;
		if(def.ajax.parameters && def.ajax.parameters.PageItemID)
		{
			source = def.ajax.action + def.ajax.parameters.PageItemID;
		}
		var params = def.ajax.parameters || {};
		if(this.superMenuInfo)
		{
			//if they have selected something from a super menu lets automatically pass
			//it along to any ajax menus.
			var superMenuKey = this.superMenuInfo.key || 'superMenuValue';
			params[superMenuKey] = this.superMenuInfo.value;
		}
		var allowAbort = true;
		if(this.options.allowAbort === false)
		{
			allowAbort = false;
		}
		Qualtrics.Menu.getAjaxData(url,{
			parameters:params,
			onComplete:this.getAjaxComplete(loadingDom, def.ajax)
		},delay, source, allowAbort);
		if (loadingDom)
			return loadingDom;
		else
			return this.menuDom;
	},
	evaluateMultipleAjaxMenu:function(def)
	{
		if(!def.multiAjax)
		{
			return false;
		}
		var delay = def.delay || false;
		if(this.parentMenu)
		{
			//we delay submenus to give them a chance to be canceled before we actually make a server request
			delay = 200;
		}
		var loadingDom = this.evaluateMenuDefinition({loading:true});
		var allowAbort = true;
		if(this.options.allowAbort === false)
		{
			allowAbort = false;
		}
		Qualtrics.Menu.getMultiAjaxData(def.multiAjax.requests,{
			onComplete:this.getMultiAjaxComplete(loadingDom, def.multiAjax)
		},delay, allowAbort);
		return loadingDom;
	},
	addMenuItems:function(items,options)
	{
		options = options||{};
		if(items.length)
		{
			for(var i=0,len=items.length; i<len; ++i)
			{
				if(items[i])
					this.addMenuItem(items[i], i);
			}
		}
		else if (!this.menuDef || !this.menuDef.loading)
		{
			var emptyString = options.empty || getMessage('SiteWide','NoResults');
			this.menuUl.appendChild(QBuilder('li',{className:'Empty Disabled'}, [QBuilder('a',{className:'MenuItemLink'},[emptyString])]));
		}
	},
	addMenuItem:function(item, index)
	{
		var link = null;
				var liParams = {};
		if(item.domNode)
		{
			var paramMap = {
				'$options':this.options
			};
			//you can specify a custom domNode to insert as an item
			if(!this.options.headless) //dont do this for headless menus its just a waste of time building domnodes for something that will never get shown.
			{
				var domNode = Qualtrics.Event.executeDotSyntax(item.domNode, null, null, null, paramMap);

				//I want the disabled class name but not any of the others for a dom node
				if(item.disabled)
					liParams.className = 'Disabled';

				if(domNode)
				{
					link = domNode;

					if(item.action)
					{
						domNode.setAttribute('mouseupcallback',this.getItemCallback(item, index));

					}
					if(item.downcallback)
					{
						//alow the itemDef to override the downcallback
						domNode.setAttribute('downcallback',item.downcallback);
					}
					else
					{
						//stop the event to stop page selecting if shift is down. bug #86949
						domNode.setAttribute('downcallback','Event.stop($evt)');
					}


					if(item.bubbleup)
					{
						var descendants = $(domNode).descendants();
						for(var i=0,len=descendants.length; i<len; ++i)
						{
							descendants[i].setAttribute('bubbleup', true);
						}
					}
				}

				if(item.onmouseover)
				{
					link.setAttribute('menupanemouseover', item.onmouseover);
					this.needsMouseOverEventObserver = true;

					if(item.mouseOverObject)
						this.mouseOverObject = item.mouseOverObject;
				}
				if(item.keepmenuopen)
				{
					liParams['keepmenuopen'] = true;
				}
			}
		}
		if(item.type == 'TextInput')
		{
			link = this.addTextInputItem(item);
		}
		if(!link)
		{
			var icon = this.getItemIcon(item);
			var display = this.getItemDisplay(item);
			var value = this.getItemValue(item);
			var className = this.getItemClass(item);
			var parameters = this.getItemParameters(item, index);
			if(item.separator)
			{
				link = display;
			}
			if(!link)
			{
				var tag = '', rightTag = '';
				if(item.tag)
				{
					tag = QBuilder('span',{className:'Tag'},[item.tag]);
				}
				if(item.rightTag)
				{
					rightTag = QBuilder('span',{className:'RightTag'},[String(item.rightTag)]);
				}
				//we need to add the display using innerHTML to render any entities
				if(item.htmlContent)
				{
					link = QBuilder('a',parameters,[icon, tag]);
					link.innerHTML = link.innerHTML+item.htmlContent;
					if(rightTag)
					{
						link.appendChild(rightTag);
					}
				}
				else
				{
					var elements = [icon, tag];
					if (Object.isArray(display))
						elements = elements.concat(display);
					else
						elements.push(display);
					if(rightTag)
					{
						elements.push(rightTag);
					}
					if(item.rightTagDom)
					{
						var rightTagDom = item.rightTagDom;
						if(rightTagDom)
						{
							elements.push(Qualtrics.Event.executeDotSyntax(rightTagDom, null, null, null, paramMap));
						}
					}
					link = QBuilder('a',parameters,elements);
				}
			}
			if(item.blockContent)
			{
				link = QBuilder('div', parameters,[icon]);
				$(link).addClassName('BlockMenuItem');
			}

			if(className){
				liParams.className = className;
			}
			if(item.id)
			{
				liParams.id = item.id;
			}
			if(item.group)
			{
				liParams['menugroup'] = item.group;
			}
			if(item.keepmenuopen)
			{
				liParams['keepmenuopen'] = true;
			}
			if(item.onmouseover)
			{
				link.setAttribute('menupanemouseover', item.onmouseover);
				this.needsMouseOverEventObserver = true;

				if(item.mouseOverObject)
					this.mouseOverObject = item.mouseOverObject;
			}
			//stop the event to stop page selecting if shift is down. bug #86949
			if(link && link.setAttribute)
			{
				if(item.downcallback)
				{
					//alow the itemDef to override the downcallback
					link.setAttribute('downcallback', item.downcallback);
				}
				else
				{
					link.setAttribute('downcallback','Event.stop($evt)');
				}
			}
						//don't show the submenu if the item is disabled
			if(item.submenu && !item.disabled)
			{
				var subMenuDef = item.submenu;
				if(typeof subMenuDef == 'object')
				{
					subMenuDef = Object.toJSON(subMenuDef);
				}
				link.setAttribute('submenu', subMenuDef);
			}
		}

		this.menuUl.appendChild(QBuilder('li',liParams,[
			link
		]));
	},
	addTextInputItem:function(item)
	{
		var input = QBuilder('input',{type:'text', className:'TextBox'});
		var label = '';
		if(item.action)
		{
			input.setAttribute('keyentercallback','Qualtrics.Menu.destroyAllMenus; '+item.action);
			if(item.realTime)
			{
				input.setAttribute('keyupcallback', item.action);
			}
		}
		if(item.validation)
		{
			input.setAttribute('validation', item.validation);
		}
		if(item.display)
		{
			input.setAttribute('autoclear', item.display);
			$(input).addClassName('AutoClearMessage');
			input.value = item.display;
		}
		if(item.label)
		{
			label = QBuilder('label', {}, item.label);
		}
		if(item.value != undefined)
		{
			input.value = item.value;
		}
		if(item.focus)
		{
			 QualtricsTools.focusInput.curry(input).defer();
		}

		return QBuilder('div',{className:'MenuInputContainer'},[label, input]);
	},
	updateMenuUl:function(def)
	{
		deleteChildren(this.menuUl);
		if(def.ajax)
		{
			return this.evaluateAjaxMenu(def);
		}
		this.addMenuItems(def.items);
	},
	/** Returns a menu item from the menuDef based off of the id */
	getMenuItemById: function(itemId)
	{
		for (var i=0; i < this.menuDef.items.length; i++)
		{
			if (this.menuDef.items[i].id == itemId)
				return this.menuDef.items[i];
		}
	},

	/** Returns an array of items to get to the current menu and selectionNode (if one has been selected).
	 * If the menu is not a submenu then it will return just the current selection node (if no there is no selectionNode
	 * the array will be empty). If the menu is a submenu then it will return an array of the selected items to get
	 * to this menu.
	 * @param {bool} opt_idOnly Returns only id of the item in the array, otherwise it returns the item.
	 * @return {array} An array of items to get to the current menu / selectionNode
	 */
	getMenuItemPath:function(opt_idOnly)
	{
		var id;
		var parent = this;
		var path = [];

		//if we have a selectionNode add that item first
		if (this.selectionNode)
		{
			if (opt_idOnly)
				path.push(this.selectionNode.id);
			else
				path.push(this.getMenuItemById(this.selectionNode.id));
		}

		while (parent != null)
		{
			if (parent.parentButton && parent.parentMenu)
			{
				if (opt_idOnly)
					path.push(parent.parentButton.id);
				else
					path.push(parent.parentMenu.getMenuItemById(parent.parentButton.id));
			}

			parent = parent.parentMenu;
		}

		//we just added everything on the array in reverse order, so lets reverse the array and return it
		return path.reverse();

	},
	getItemClass:function(item)
	{
		var checked = item.checked;
		if(this.options.selectMenu)
		{
			if(this.currentValue === null || item.value === null)
			{
				//if any values are null then we want to do a type match
				if(this.currentValue === item.value)
				{
					//turn the check on
					checked = true;
				}
			}
			else if(this.currentValue == item.value)
			{
				//if no values are null then String(1) will match Number(1)
				//we have a lot of this because values pass through a dom attribute
				//and get converted to a string to get here.

				//turn the check on
				checked = true;
			}


		}
		if(this.options.showChecks === false)
		{
			checked = false;
		}
		var className = (item.className || '');
		if(item.separator)
		{
			className += ' Separator';
		}
		if(checked)
		{
			className += ' check';
		}
		if(item.disabled)
		{
			className += ' Disabled';
		}
		return className;
	},
	getItemParameters:function(item, index)
	{
		if (item.params)
		{
			//this is for backward compatibility with the old qmenu format
			item.parameters = item.params;
		}
		var parameters = {};
		if(!parameters.className)
		{
			parameters.className = '';
		}
		parameters.className += ' MenuItemLink';
		var clickcallback = this.getItemCallback(item, index);
		if(clickcallback)
		{
			parameters.mouseupcallback=clickcallback;
			parameters.touchendcallback=clickcallback;
			if (Qualtrics.Browser.IE6)	//Only include bogus HREF on menu items for browsers that actually need it
			{
				parameters.href='javascript:void(0)';
			}
		}


		if (item.parameters)
		{
			Object.extend(parameters,item.parameters);
		}
		if(item.defer)
		{
			parameters.defer = item.defer;
		}
		if(item.uncheckGroup)
		{
			parameters.uncheckGroup = item.uncheckGroup;
		}
		if(this.menuDef && this.menuDef.togglecheck)
		{
			parameters['togglecheck'] = 'true';
		}
		if(this.menuDef && this.menuDef.togglecheckexclusive != undefined || this.options.selectMenu)
		{
			if (this.menuDef.togglecheckexclusive || this.options.selectMenu)
				parameters['togglecheckexclusive'] = 'true';
			else
				parameters['togglecheckexclusive'] = 'false';

		}
		else if(item.checked != undefined) //if check is true or false then flip it instantly, this might not be desired in some cases but it seems like it will make the interface better in most cases.
		{
			parameters['togglecheck'] = 'true';
		}
		parameters['itemindex'] = index;
		return parameters;
	},
	getItemCallback:function(item, index)
	{
		var callback = '';
		var value = this.getItemValue(item);
		//parse variables with the correct values
		if (item.action)
		{
			callback = item.action;
		}
		callback = callback.replace('$menuPaneId', this.id);
		callback = callback.replace('$value', value);
		return callback;
	},
	getItemIcon:function(item)
	{
		if (item.icon !== false && this.menuDef.icon !== false)
		{
			if (typeof item.icon != 'boolean' && typeof item.icon != 'undefined')
				return QBuilder('span',{className:'icon '+item.icon});
			else
				return QBuilder('span',{className:'icon'});
		}
		else
		{
			return '';
		}
	},

	getItemDisplay:function(item, opt_selectedDisplay)
	{
		if(item.separator)
		{
			return '-';
		}
		var display = item.display;
		if(opt_selectedDisplay && item.selectedDisplay)
		{
			//selected display will change the buttonText when its selected but not affect the menu.
			display = item.selectedDisplay;
		}
		if(!item.display && (item.display != 0 || item.display != '0'))
		{
			display = item.label;
		}
		if(typeof display  == 'number')
			display = String(display);
		if(this.processItemDisplay)
		{
			//the class has been extended with a processor
			display = this.processItemDisplay(display, item);
		}
		if(this.options.itemDisplayProcessor && item.display)
		{
			//the options say we need to run all items with a display through a processor
			//this will be a dotsyntax string expression pointing to a function
			display = Qualtrics.Event.executeDotSyntax(this.options.itemDisplayProcessor, null, null, null, {'$display':display});
		}
		if(display === undefined || display === null)
		{
			display = '';
		}
		var truncate = item.truncate || this.menuDef.truncate || this.options.truncate || false;
		if(truncate && window.QualtricsCPTools && display.stripTags)
		{
			//make sure we remove tags before we truncate or we will be sad
			display = QualtricsCPTools.middleTruncate(display.stripTags(), truncate);
		}
		//if you have an empty string as the display it should show a non-breaking space
		return (!display)?'\xa0':display;
	},
	getItemValue:function(item)
	{
		var value = '';
		if(item.value);
			value = item.value;
		return value;
	},
	search:function(s, el, evt)
	{

		if(evt && evt.keyCode > 36 && evt.keyCode < 41 || evt.keyCode == Event.KEY_RETURN)
		{
			return;
		}
		var sCopy = s;
		s = s.toLowerCase();
		if (this.searchTerm && sCopy == this.searchTerm)
			return;
		var cleared = '';
		if(el.getAttribute('autoclear'))
		{
			cleared = el.getAttribute('autoclear').toLowerCase();
			if(s == cleared)
			{
				s = undefined;
			}
		}
		//we cant have any submenus open while searching
		this.hideSubMenu();
		var filtered = false;
		//first check to see if we have a custom search def
		//if we have a custom one we are actually going get a new menu definition and use its items array to build a special menu
		if(s && this.menuDef.search && this.menuDef.search !== true)
		{
			if (typeof this.menuDef.search == 'string' && this.menuDef.search.startsWith('{"ajax'))
			{
				var searchAjax = Qualtrics.parseJSON(this.menuDef.search);
				if(!searchAjax.ajax.parameters)
					searchAjax.ajax.parameters = {};

				searchAjax.ajax.parameters.Search = s;
				this.searchTerm = sCopy;
				this.startIndex = 0;
				this.customFilteredMenu = true; //this is so we know to change the menu back if they clear their search
				this.evaluateAjaxMenu(searchAjax);
			}
			else
			{
				var filterDef = Qualtrics.Event.executeDotSyntax(this.menuDef.search, null, null, null, {'$search':s});
				if(filterDef.items)
				{
					this.customFilteredMenu = true; //this is so we know to change the menu back if they clear their search
					this.replaceItemsWithNewDef(filterDef);
				}
				filtered = true;
			}
		}
		else
		{
			this.searchTerm = null;
			//just filter the regular menu dom tree
			if(this.customFilteredMenu)
			{
				//we need to restore the original menu def first
				this.replaceItemsWithNewDef(this.menuDef);
			}
			//just filter the existing menu
			filtered = this.filterMenu(s, el, evt);
		}
		this.positionMenu();
		//refresh the outline if there is one
		this.positionOutline();
		if(filtered)
		{
			Qualtrics.Menu.down();
		}
	},
	filterMenu:function(s, el, evt)
	{
		if(this.menuUl)
		{
			var children = $(this.menuUl).childElements();
			for(var i=0,len=children.length; i<len; ++i)
			{
				if (!children[i].firstChild) // Ignore loading DOMs, when unfiltering Ajaxed windows
					continue;
				var text = children[i].firstChild.textContent || children[i].firstChild.innerText || '';
				text = text.toLowerCase();
				if(s && s.length > 0 && (children[i].hasClassName('Disabled') || text.indexOf(s) == -1))
				{
					children[i].hide();
				}
				else
				{
					children[i].show();
				}
			}
		}
	},
	/**
	* replaces menu items with items from an abitrary menu def.
	* note that this.menuDef will still point to the original menu def that is not being used.
	*/
	replaceItemsWithNewDef:function(menuDef)
	{
		this.searchMenuDef = menuDef;
		Qualtrics.Menu.deactivateArrowMode(); //this isn't going to work with the new menuUl so turn it off
		deleteChildren(this.menuUl);
		this.addMenuItems(menuDef.items);
		this.subMenuSetupComplete = false;
		this.setupSubMenus();

		var pagination = $(this.menuDom).down('.Pagination');
		if (pagination) // We have a paginated menu - make sure to show/hide the pagination as needed
		{
			$(pagination).remove();
		}
		if(this.paginate && menuDef.count > this.perpage)
		{
			this.menuDom.appendChild(this.buildPagination(menuDef.count));
		}


	},
	getAjaxComplete:function(loadingDom, ajaxOptions)
	{

		var that = this;
		ajaxOptions = ajaxOptions||{};

		return function(transport)
		{

			try{
				if(that.searchTerm || (loadingDom && loadingDom.offsetWidth) || that.options.onLoad) //this is a little hack to make sure that the loadingDom is still on the page.
				{
					var response = transport.responseText;

					if(ajaxOptions.preparser)
					{

						var params = [response];
						var paramMap = {
							$response:response,
							$ajaxParams:transport.request.parameters,
							$menuDef:that.menuDef,
							$parentMenu:that.parentMenu
						};
						if (ajaxOptions.preparams) // You can specify additional parameters to pass through to the function
						{
							for (var param in ajaxOptions.preparams)
								params.push(ajaxOptions.preparams[param]);
						}

						response = Qualtrics.Event.executeDotSyntax(ajaxOptions.preparser, null, null, null, paramMap, params);

					}
					if(ajaxOptions.postparser)
					{
						var params = [response];
						var paramMap = {
							$response:response,
							$ajaxParams:transport.request.parameters,
							$menuDef:that.menuDef,
							$parentMenu:that.parentMenu
						};
						response = Qualtrics.Event.executeDotSyntax(ajaxOptions.postparser, null, null, null, paramMap, params);
					}

					if (that.searchTerm)
					{
						that.replaceItemsWithNewDef(response);
					}
					else
					{
						if(that.options.onLoad)
						{
							//there is no dom but the menuPane has an onLoad
							//it must be running in headless mode to just update the button.
							that.evaluateMenuDefinition(response);
							Qualtrics.Event.executeDotSyntax(that.options.onLoad, null, null, null,{
								'$menuDef':that.menuDef,
								'$menuPane':that
							});
						}
						else
						{
							that.replaceMenuDefinition(response);
						}
					}
				}

			}catch(e)
			{
				console.error('cant parse menu def: '+ e, e);
			}
		};
	},
	getMultiAjaxComplete:function(loadingDom, ajaxOptions)
	{
		var that = this;
		ajaxOptions = ajaxOptions||{};
		return function(transport)
		{
			try{
				if(that.searchTerm || loadingDom.offsetWidth || that.options.onLoad) //this is a little hack to make sure that the loadingDom is still on the page.
				{
					var response = transport.responseText;
					if(ajaxOptions.preparser)
					{

						var params = [response];
						var paramMap = {
							$response:response,
							$ajaxParams:transport.request.parameters,
							$menuDef:that.menuDef,
							$parentMenu:that.parentMenu
						};
						if (ajaxOptions.preparams) // You can specify additional parameters to pass through to the function
						{
							for (var param in ajaxOptions.preparams)
								params.push(ajaxOptions.preparams[param]);
						}
						response = Qualtrics.Event.executeDotSyntax(ajaxOptions.preparser, null, null, null, paramMap, params);
					}
					if(ajaxOptions.postparser)
					{
						var params = [response];
						var paramMap = {
							$response:response,
							$ajaxParams:transport.request.parameters,
							$menuDef:that.menuDef,
							$parentMenu:that.parentMenu
						};
						response = Qualtrics.Event.executeDotSyntax(ajaxOptions.postparser, null, null, null, paramMap, params);
					}

					if (that.searchTerm)
					{
						that.replaceItemsWithNewDef(response);
					}
					else if(that.options.onLoad)
					{
						that.evaluateMenuDefinition(response);
						Qualtrics.Event.executeDotSyntax(that.options.onLoad, null, null, null,{'$menuDef':that.menuDef, '$menuPane':that});
					}
					else
					{
						that.replaceMenuDefinition(response);
					}
				}

			}catch(e)
			{
				console.error('cant parse menu def: '+ e);
			}
		};
	},
	isOpen:function()
	{
		if(this.menuDom && this.menuDom.offsetWidth)
		{
			return true;
		}
		return false;
	},
	replaceMenuDefinition:function(newMenuDef)
	{

		var forcedPosition = null;
		if(this.options.mousePosition)
		{
			forcedPosition = {
				top:this.top,
				left:this.left,
				right:this.right
			};
		}
		var that = this;
		//make the new ul
		var oldDom = that.menuDom;
		var newDom = that.constructMenu(newMenuDef, {empty: getMessage('SiteWide','NoResults')});

		//make sure there is a dom. constructMenu calls of lot of function some of which might actually removeAllMenus so we might end up with nothing.
		if(newDom)
		{
			if(oldDom && oldDom.parentNode)
			{
				oldDom.parentNode.insertBefore(newDom, oldDom);
				newDom.id = oldDom.id;
			}
			else
			{
				this.insertMenu();
			}
			if(that.parentMenu)
			{
				that.addClassNames();
				that.setupSubMenuEvents();
			}
			//this has quite possibly changed so setup the new position
			that.positionMenu(forcedPosition);

			that.deactivateArrowMode();
			//manually setup the submenus again
			that.subMenuSetupComplete = false;
			that.setupSubMenus();
			if(that.searchInputDom && !this.searchTerm)
			{
				 QualtricsTools.focusInput(that.searchInputDom, 0);
			}
		}
		if(oldDom && oldDom != newDom) // With Searching + Pagination, newDom weirdly equals oldDom and would try to wipe itself out
		{
			oldDom.onmouseup = null; //for mem leaks
			removeElement(oldDom);
		}
	},
	/**
	* Qualtrics.MenuPane.setupSubMenus
	* traverses the menu and finds items with nested UL elements.
	* the UL elements are hidden.
	* then mouse events are assigned to trigger their submenus.
	*/
	setupSubMenus:function(opt_forceAgain)
	{
		if(this.subMenuSetupComplete && !opt_forceAgain)
		{
			return;
		}
		this.subMenuSetupComplete = true;
		if(this.menuUl)
		{
			var ul = this.menuUl;
			var children = $(ul).childElements();

			var widestItem = 0;

			for(var i=0, len=children.length; i<len; ++i)
			{
				var foundSub = null;
				var link = $(children[i]).down && $(children[i]).down();

				if(link)
				{
					var width = link.offsetWidth;
					if(width > widestItem)
					{
						widestItem = width;
					}

					var submenuOptions = {
						mouse:true //deactivate arrow mode
					};
					if(this.options.outline)
					{
						//we propagate outlines to the submenus
						submenuOptions.outline = this.options.outline;
					}

					//its important to pass this along to a submenu sometimes. like in piped text.
					if (link.getAttribute('menuclass'))
					{
						submenuOptions.className = link.getAttribute('menuclass');
					}

					if (this.options.fixed)
					{
						submenuOptions.fixed = this.options.fixed;
					}

					// Allow submenus to not be loaded Asynchronously
					if (this.options.classicSubMenu)
					{
						submenuOptions.classicSubMenu = this.options.classicSubMenu;
					}

					if(link.getAttribute('submenu'))
					{
						//we have a dynamic submenu
						foundSub = true;
						link.onmouseover = this.getDynamicSubMenuClosure(link.getAttribute('submenu'), children[i], submenuOptions);
						//the mouseout is set by the mouseover
					}
					else if (!link.hasClassName('Pagination'))
					{
						//perhaps a static submenu
						var subMenu = $(link).next();
						if(subMenu)
						{
							foundSub = true;
							link.onmouseover = this.getSubMenuShowClosure(subMenu, children[i], submenuOptions);
							$(subMenu).hide();
							$(subMenu).addClassName('QSubMenu');
						}
					}
					if(foundSub)
					{
						this.hasSubMenus = true;
						children[i].hasSubMenu = true; //add a submenu flag to the LI for arrow key navigation
						link.appendChild(QBuilder('span', {className:'ArrowIcon'}));
						$(children[i]).addClassName('HasSubMenu');
					}
					else
					{
						link.onmouseover = this.getSubMenuHideClosure({mouse:true});
					}
				}
			}
			if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 8)
			{
				var paddingOffset = null;//55; //there is 55 px of padding which we want to subtract from our width or we will be too wide.
				for(var i=0, len=children.length; i<len; ++i)
				{
					var link = $(children[i]).down && $(children[i]).down();
					if(link)
					{
						if(paddingOffset === null)
						{
							//calculate padding for just the first item cause its a bit intensive
							var paddingLeftRight = [$(link).getStyle('paddingLeft'), $(link).getStyle('paddingRight')].invoke('replace', 'px', '');
							paddingOffset = Number(paddingLeftRight[0])+Number(paddingLeftRight[1]);
						}
						//fix ie7 not having uniform item widths
						if (widestItem && paddingOffset && !link.hasAttribute('NoIE7SetW'))
						{
							$(link).setStyle({minWidth:(widestItem-paddingOffset)+'px'});
						}
					}
					if(children[i].className.indexOf('Separator') != -1)
					{
						//fix ie7 not having uniform item widths
						$(children[i]).setStyle({minWidth:(widestItem-paddingOffset)+'px'});
					}
				}
			}
			if(this.hasSubMenus)
			{
				if(!Qualtrics.Menu.velocityProcessor && window.QualtricsCPTools)
				{
					//set the parent to watch for low velocity item exits
					Qualtrics.Menu.velocityProcessor = QualtricsCPTools.velocimeter.add(Qualtrics.Menu.processVelocity);
				}
			}
		}
	},
	getAutoDirection:function()
	{
		if(this.options.mousePosition)
		{
			var pageSize = getPageSize();
			return (mousePos[0] > pageSize[0]/2) ? 'left' : 'right';
		}
		if(this.menuDef && this.menuDef.direction)
		{
			return this.menuDef.direction;
		}
		var page = $('center')|| document.body;
		var pageWidth = $(page).getWidth();
		var pagePos = Position.cumulativeOffset(page);
		var pageCenter = pagePos[0]+((pagePos[0]+pageWidth)/2);
		if(this.buttonInfo.left < pageCenter)
		{
			return 'right';
		}
		return 'left';
	},
	getAutoAlignment:function()
	{
		if(this.direction == 'left')
		{
			return 'right';
		}
		else
		{
			return 'left';
		}
	},
	/**
	* Qualtrics.MenuPane.positionMenu
	**/
	positionMenu:function(opt_forcePosition, opt_updateButtonInfo)
	{
		if(opt_updateButtonInfo)
		{
			//blow the button info cache
			this.getButtonInfo(true);
		}
		//forcedDirection is for other systems to know if the direction was changed on the fly
		this.forcedDirection = null; //reset forced direction so if they make their browser window bigger, they will be able to see the menu as it was intended

		if (this.options.positionCallback)
		{
			var position = this.options.positionCallback();
			if (position.width && position.width != 'auto')
			{
				$(this.menuDom).setStyle({width:position.width + 'px'});
			}
			if(position.y && position.x)
			{
				var topPos = position.y;
				$(this.menuDom).setStyle({top:topPos+'px', left:position.x+'px'});
				return;
			}
		}

		var pageSize = getPageSize();

		if(this.parentMenu)
		{
			$(this.menuDom).show();
		}

		//we want to make sure the menus is at least as wide as the menu button. only do it for buttons (not img)
		var buttonTag = (this.parentButton || {}).nodeName;
		if(buttonTag !== 'IMG' && this.menuDom.offsetWidth < this.buttonInfo.width && !this.parentMenu)
		{
			$(this.menuDom).setStyle({width:this.buttonInfo.width+'px'});
		}

		var menuWidth = this.menuDom.offsetWidth; //must be called after submenu show()
		//position a root menu
		var topPos = this.buttonInfo.top+this.buttonInfo.height-1;
		var leftPos = this.buttonInfo.left+1;
		var leftCenter = leftPos;
		var rightPos = leftPos+this.buttonInfo.width-menuWidth;
		var rightCenter = rightPos;
		var centerPos = leftPos; //center doesnt work unless we are vertical
		if(this.options.mousePosition)
		{
			if (this.options.forceMousePosition)
			{
				topPos = this.options.forceMousePosition.y+1;
				leftPos = this.options.forceMousePosition.x+1;
				rightPos = this.options.forceMousePosition.x-menuWidth-1;
			}
			else
			{
				topPos = window.mousePos[1]+1;
				leftPos = window.mousePos[0]+1;
				rightPos = window.mousePos[0]-menuWidth-1;
			}
		}
		this.options.fixed = this.options.fixed || (this.menuDef && (this.menuDef.fixed || this.menuDef.checkForFixed && Qualtrics.Menu.isFixed(this.parentButton)));

		if(this.options.fixed)
		{
			//This is an IE7/8 fix where the buttonInfo.top is not 0 like it should be
			if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 9 && this.buttonInfo.top < 0)
			{
				topPos = this.buttonInfo.height - 1;
			}

			$(this.menuDom).addClassName('Fixed');
		}

		if(this.options.position == 'horizontal')
		{
			leftPos = this.buttonInfo.left+this.buttonInfo.width;
			topPos = this.buttonInfo.top;
			centerPos = leftPos;
			rightPos = this.buttonInfo.left-menuWidth;
		}
		else if(this.options.position == 'vertical')
		{
			leftPos = this.buttonInfo.left+this.buttonInfo.width;
			centerPos = this.buttonInfo.left-(menuWidth/2)+(this.buttonInfo.width/2);
			topPos = this.buttonInfo.top + this.buttonInfo.height;
			rightPos = this.buttonInfo.left-menuWidth;
			leftCenter = this.buttonInfo.left - (menuWidth/2);
			rightCenter = leftCenter + this.buttonInfo.width;
		}
		else if(this.options.position == 'horizontal-right')
		{
			leftPos = this.buttonInfo.left+this.buttonInfo.width;
			centerPos = leftPos;
			rightPos = this.buttonInfo.left-menuWidth;
			topPos = this.buttonInfo.top + (this.buttonInfo.height/2) - (this.menuDom.offsetHeight/2);

		}
		if(this.direction == 'up')
		{
			topPos = this.buttonInfo.top - this.menuDom.offsetHeight;
			if(this.options.connector)
			{
				//compensate for the connector
				topPos -= 10;
			}
		}
		else
		{
			if (this.options.connector)
			{
				//compensate for the connector
				topPos += 10;
				//tell connector to flip
				$(this.menuDom).addClassName("Direction_down");
			}
		}

		if(this.options.connectorPosition)
		{
			if(this.options.connectorPosition === 'left')
			{
				leftPos += 11;
				topPos -= 10;
				$(this.menuDom).addClassName("Direction_right");
			}
		}

		if(this.parentMenu)
		{
			//submenus need special positioning. the parentButton isn't precise enough because there might be a scrollbar. We must do 2 things:
			//1. look at the menuUl for the width instead of just the button because that will include the added width from the scrollbar
			//2. offset any scrolled content from the top.

			//subtract any ul scrollOffsets
			topPos -= this.parentMenu.menuUl.scrollTop;
			leftPos = this.parentMenu.menuUl.offsetWidth;
			rightPos = 0-menuWidth;
		}
		if(this.options.relative)
		{
			//if the menu has been appended inside the button then we don't have to do much.
			//the menu should already be in the correct spot.
			leftPos = 0;
			topPos = this.buttonInfo.height;
			rightPos = 0-menuWidth+this.buttonInfo.width;
		}
		//see if we need to force a direction. (if the menu is going off the page)
		if(opt_forcePosition)
		{
			var f = opt_forcePosition;
			if(f.top)
			{
				topPos = f.top;
			}
			if(f.left)
			{
				leftPos = f.left;
			}
			if(f.right)
			{
				rightPos = f.right;
			}
		}
		if(this.menuDef && this.menuDef.offsetRight)
		{
			rightPos -= this.menuDef.offsetRight;
			leftPos += this.menuDef.offsetLeft;
		}

		if(this.alignment == 'left')
		{
			$(this.menuDom).setStyle({top:topPos+'px', left:leftPos+'px'});
		}
		else if(this.alignment == 'center-left')
		{
			$(this.menuDom).setStyle({top:topPos+'px', left:leftCenter+'px'});
		}
		else if(this.alignment == 'center-right')
		{
			$(this.menuDom).setStyle({top:topPos+'px', left:rightCenter+'px'});
		}
		else if(this.alignment == 'center')
		{
			//center it
			$(this.menuDom).setStyle({top:topPos+'px', left:centerPos+'px'});
		}
		else
		{
			//use rightPos
			$(this.menuDom).setStyle({top:topPos+'px', left:rightPos+'px'});
		}
		//store the positions that we ended up with for posterity
		this.top = topPos;
		this.left = leftPos;
		this.right = rightPos;

		var cumulativeOffset = this.getCumulativeOffset(); //the absolute position of the menu on the page

		var breathingRoom = 40; //we need to account for some extra room for scroll bars and drop shadows and stuff. we never want to cause a horizontal scroll bar
		if(this.direction == 'right' && cumulativeOffset.left+menuWidth > (pageSize[0]-breathingRoom))
		{
			//the direction is set to right, but there is no room, so force left.
			//Make sure the menu isn't going off the page
			rightPos = Math.max(this.buttonInfo.width-cumulativeOffset.left,rightPos);
			this.forcedDirection = 'left';//the velocity meter looks at this
			$(this.menuDom).setStyle({top:topPos+'px', left:rightPos+'px'});
		}
		else if(this.direction == 'left' && cumulativeOffset.left < 0)
		{

			//the direction is set to left, but there is no room, so force right.
			this.forcedDirection = 'right'; //the velocity meter looks at this
			$(this.menuDom).setStyle({top:topPos+'px', left:leftPos+'px'});

		}

		if(this.options.height)
		{
			this.clipMenu(this.options.height);
		}
		//see if we need scroll bars
		this.adjustMenu({leftPos:leftPos,rightPos:rightPos,topPos:topPos});
		if(this.options.outline)
		{
			Qualtrics.Menu.drawOutline();
		}
		if(this.options.positionOverRide)
		{
			Qualtrics.Event.executeDotSyntax(this.options.positionOverRide, null, null, null, null, [this.menuDom]);
		}
	},
	adjustMenu:function(options)
	{
		options = options||{};
		var leftPos = options.leftPos||0;
		var rightPos = options.rightPos||0;
		var topPos = options.topPos||0;

		var pageSize = getPageSize();
		var cumulativeOffset = this.getCumulativeOffset(); //the absolute position of the menu on the page
		//see if we need scroll bars
		var viewHeight = pageSize[3];

		var viewBottom = scrollInfo[1]+viewHeight;
		var menuTop = this.menuDom.offsetTop;

		var menuHeight = this.menuDom.offsetHeight;

		var padding = 24; //this is how much we want between our menus and the edge of the screen
		var menuTop = cumulativeOffset.top;
		if(this.options.fixed)
		{
			//the menu is going to be positioned fixed so the top is only going to represent the viewable browser
			//we need it to represent the top from the very top of the page.
			//so lets add the scrollTop
			menuTop += scrollInfo[1];
		}


		var clippedY = menuTop+menuHeight-viewBottom;

		//var totalWidth = Math.abs(cumulativeOffset.left)+(this.menuDom.offsetWidth);

		if(clippedY > 0 )
		{

			var adjustedTop = null;
			var adjustedLeft = null;
			//if we are on the same vertical space as the button we are going to have problems covering up the button
			//so try putting it above the button first
			if(leftPos < this.buttonInfo.left+this.buttonInfo.width-10) //add 10 pixel margin of error
			{
				//we are going to cover up the button unless we intervene
				var buttonHeadRoom = this.buttonInfo.top-scrollInfo[1];

				if(this.options.fixed)
				{
					buttonHeadRoom = this.buttonInfo.top;
				}
				if(menuHeight < buttonHeadRoom)
				{
					//we have room to put the menu above the button so lets do that.
					if(!this.options.relative) //it doesn't work very well with relative buttons so lets just forget it and render off the page
					{
						adjustedTop = this.buttonInfo.top-menuHeight;
						/*if(this.options.fixed)
						{
							//this code is stupid and we dont need it now that the menus are actually positioned fixed.
							buttonHeadRoom = adjustedTop += scrollInfo[1];
						}*/
					}
				}
				else
				{
					if(!this.options.dontAdjustHorizontally)
					{
						//we have no space on the top or the bottom for this menu, lets move the menu over to the right enough to not cover up the button
						if(this.direction == 'right')
						{
							adjustedLeft = leftPos + this.buttonInfo.width;
						}
						else
						{
							adjustedLeft = rightPos - (this.buttonInfo.width);
						}
					}
				}
			}

			if(!adjustedTop)
			{
				//try to reduce this clipping as much as we can by moving the menu up.
				var remainder = 0;//remainder is what we couldnt fit on the screen.
				var headRoom = cumulativeOffset.top;
				if(!this.options.fixed)
				{
					headRoom-=scrollInfo[1];
				}
				if(this.options.dontAdjustHorizontally)
				{
					//we didnt move the menu out of the way of the button so we need clip more space for the button
					clippedY += this.buttonInfo.height;

				}
				if(clippedY > headRoom)
				{
					remainder = clippedY-headRoom; //we cant fit this on the screen so this much will have to scroll.
					clippedY = headRoom;
				}
				adjustedTop = topPos-clippedY;

				if(remainder > 0)
				{
					//we must scroll also
					var domNode = this.menuUl || this.menuDom;
					var listHeight = domNode.offsetHeight;
					var maxHeight = listHeight-remainder;
					this.clipMenu(maxHeight-(padding*2));
					//we are going to need padding on the top to even the menu out.
					adjustedTop += padding;
				}
				else
				{
					//if there is no scrolling then we want padding on the bottom
					adjustedTop -= padding;
				}
			}

			//redo the top and the left if we have recalculated

			if(adjustedTop)
			{
				$(this.menuDom).setStyle({top:(adjustedTop)+'px'});
			}
			if(adjustedLeft)
			{
				var menuWidth = this.menuDom.offsetWidth;
				if(pageSize[2] < menuWidth)
				{

					$(this.menuDom).setStyle({width:(pageSize[2]-adjustedLeft-10)+'px'});
					$(this.menuDom).down().setStyle({width:((pageSize[2]-adjustedLeft)-10)+'px', overflowX:'auto'});
				}

				$(this.menuDom).setStyle({left:(adjustedLeft)+'px'});
			}

		}
		else if (pageSize[2] < this.menuDom.offsetWidth)
		{
			//we have no space on the top or the bottom for this menu, lets move the menu over to the right enough to not cover up the button
			if(this.direction == 'right')
			{
				adjustedLeft = leftPos + this.buttonInfo.width;
			}
			else
			{
				adjustedLeft = rightPos - (this.buttonInfo.width);
			}

			$(this.menuDom).setStyle({width:(pageSize[2]-adjustedLeft-10)+'px', left:(adjustedLeft)+'px'});
			$(this.menuDom).down().setStyle({width:((pageSize[2]-adjustedLeft)-10)+'px', overflowX:'auto'});
		}


	},
	clipMenu:function(height)
	{

		if(this.menuUl)
		{
			$(this.menuUl).setStyle({height:height+'px', overflowX:'visible', overflowY:'scroll', position:'relative'}); //position:relative is to fix the ie6 overflow relative bug
		}
		else if(this.menuDom)
		{
			//we dont have a ul it must be a custom menu
			$(this.menuDom).setStyle({height:height+'px', overflowX:'visible', overflowY:'scroll'});
		}
	},
	getButtonPos:function()
	{
		if(this.options.customPositionCallback)
		{
			var rm = Qualtrics.Event.getDotSyntaxParts(this.options.customPositionCallback);
			return rm.method.apply(rm.root,[this.parentButton]);
		}
		if(this.parentMenu)
		{
			var topPos = this.parentButton.offsetTop;
			//submenus are position relative to the parent so we dont need a cumulative. just a single offset.
			return {left:this.parentButton.offsetLeft, top:topPos};
		}
		//return the cumulative offset of the parentButton
		var pos = Position.cumulativeOffset(this.parentButton);

		var scrollOffsets = QualtricsTools.cumulativeScrollOffset(this.parentButton);

		pos[0] -= scrollOffsets[0];
		pos[1] -= scrollOffsets[1];
		if(Qualtrics.Browser.IE && this.menuDef && this.menuDef.fixed)
		{
			pos[0] += scrollInfo[0];
			pos[1] += scrollInfo[1];
		}

		return {left:pos[0], top:pos[1]};
	},
	positionOutline:function()
	{
		if(this.menuOutlineDom)
		{
			var bg = this.menuOutlineDom;
			var m = this;
			var offset = m.getCumulativeOffset();
			bg.style.left = offset.left+'px';
			bg.style.top = offset.top+'px';
			bg.style.width = m.menuDom.offsetWidth+'px';
			bg.style.height = m.menuDom.offsetHeight+'px';
		}

		if($(Qualtrics.Menu.outlineContainer) && this.options.fixed || (this.menuDef && this.menuDef.fixed))
		{
			$(Qualtrics.Menu.outlineContainer).addClassName('Fixed');
		}
		else if ($(Qualtrics.Menu.outlineContainer))
		{
			//this doesnt get rebuilt so we need to make sure it doesnt have fixed if its not appropriate
			$(Qualtrics.Menu.outlineContainer).removeClassName('Fixed');
		}
	},
	/**
	 * if you pass in an itemIndex it will just return the item node associated with that itemIndex.
	 **/
	getActiveMenuItem:function(opt_itemIndex)
	{
		var menu = this.menuUl;
		if(this.arrowMode)
		{
			if(this.arrowSelectedItem)
			{
				this.selectionNode = this.arrowSelectedItem;
				return this.selectionNode;
			}
		}
		//mouse mode
		if(menu)
		{
			var menuTopScroll = this.menuDom.scrollTop;
			$(menu).cleanWhitespace();
			var childs = menu.childNodes;
			var selectionNode = null;
			if(opt_itemIndex !== undefined && childs[opt_itemIndex])
			{
				//we have been instructed to return a specific item node.
				return childs[opt_itemIndex];
			}
			for(var i = 0, len=childs.length; i<len; ++i)
			{
				if ($(childs[i]).cumulativeOffset)
				{
					var offset = $(childs[i]).cumulativeOffset();
					if(menu.scrollTop)
					{
						offset[1] -= menu.scrollTop;
					}
					//if we are fixed, we need to add scroll offsets
					if (this.options.fixed || (this.menuDef || {}).fixed)
					{
						offset.left = offset[0] += scrollInfo[0];
						offset.top = offset[1] += scrollInfo[1];
					}
					var strangeBottomOffset = 1;//we need to add an offset to the bottom of each li for some reason. you can click the bottom pixel and get an error otherwise.
					var isWithinChild = (mousePos[0]>offset[0] && mousePos[0]<offset[0]+childs[i].offsetWidth && mousePos[1]>(offset[1]-menuTopScroll) && mousePos[1]<(offset[1]+childs[i].offsetHeight-menuTopScroll+strangeBottomOffset));

					if(isWithinChild)
					{
						selectionNode = childs[i];
						this.selectionNode = selectionNode; //this is so we can find the selection later without making any closures.
						return this.selectionNode;
					}
				}
			}
		}
	},
	/**
	* Qualtrics.MenuPane.observeMenuUp();
	* assigns the mouseup event.
	* @param {HTMLDivElement} menuNode - the menu div.
	*/
	observeMenuUp:function(menuNode)
	{
		if(!menuNode.mouseUpObserver)
		{
			menuNode.mouseUpObserver = true;
			menuNode.onmouseup = this.flashSelectionAndDestroyMenu.bind(this);
		}
		if(!menuNode.touchEndObserver)
		{
			menuNode.touchEndObserver = true;
			menuNode.ontouchend = this.flashSelectionAndDestroyMenu.bind(this);
		}
	},
	/**
	* Qualtrics.MenuPane.flashSelectionAndDestroyMenu
	* this is called by the menu mouseups
	* it gives the user immediate feedback (flashing the menu item) that they succesfully clicked the menu item.
	* its nice to have the menus perform this so the function that is performed doesnt have to worry about feedback.
	* and it will be consistent feedback throughout the system.
	*
	* this also handles special attributes you can give your LI elements.
	* they are:
	* togglecheck - will toggle a check icon.
	* togglecheckexclusive - will turn on a check for the clicked LI. and turn OFF any other checked siblings
	* keepmenuopen - will not close the menu. this is useful if you want them to be able to click the menu item multiple times in succession (like choice moving in the edit section)
	*
	* @param {Event} evt - the mousedown Event
	*/
	flashSelectionAndDestroyMenu:function(evt, options)
	{
		if(!evt) evt = window.event;
		options = options || {};

		var shouldRunSelectionFunctions = true;

		if(evt)
		{
			if(!evt.keyCode && evt.type !== 'touchend' && !Event.isLeftClick(evt)) //check to make sure its a left click. also ie will do an event for keyboard and a keycode event is not a left click.
			{
				return;
			}

			var clickedEl = Event.element(evt);

			if(clickedEl && !evt.keyCode)
			{
				if(clickedEl.id == 'QMenu' || clickedEl.tagName == 'UL') return; //this means they probably clicked on the menu scroll bar.
				if(clickedEl.nodeName == 'INPUT') return; //they clicked on the search or some other input.
				if(clickedEl.getAttribute('keepmenuopen')) return; //the clicked on something with the keepmenuopen attribute
				if (clickedEl.getAttribute('doNotSelectOption')) {
						shouldRunSelectionFunctions = false;
				}
				clickedEl = null;
			}
		}

		var menu = Qualtrics.Menu.getActiveMenuPane();

		// Otherwise both menu and submenu parents get called
		if (menu.id != this.id)
			return;

		var selectionNode = menu.getActiveMenuItem(options.itemIndex);
		var itemDef = {};
		var link = null;
		if(selectionNode)
		{
			if($(selectionNode).hasClassName('Disabled') || $(selectionNode).hasClassName('Pagination') || selectionNode.getAttribute('keepmenuopen'))
			{
				return;
			}
			$(selectionNode).cleanWhitespace();

			//check to see if we need to toggle check marks
			link = selectionNode.firstChild;

			if(link && link.nodeType == 1)
			{
				var itemIndex = link.getAttribute('itemindex');
				if(itemIndex !== undefined)
				{
					if (menu.searchTerm && menu.searchMenuDef && menu.searchMenuDef.items)
					{
						itemDef = menu.searchMenuDef.items[itemIndex] || {};
					}
					else if((menu.menuDef || {}).items)
					{
						itemDef = menu.menuDef.items[itemIndex] || {};
					}
				}
				//if an item is not selectable, don't worry about checks
				if (itemDef && !itemDef.notselectable && !itemDef.ignoreSelects)
				{
					if(link.getAttribute('uncheckGroup'))
					{
						var groups = link.getAttribute('uncheckGroup').split(',');
						if(selectionNode && selectionNode.parentNode)
						{
							Qualtrics.Menu.uncheckAll(selectionNode.parentNode, {groups:groups});
						}
					}
					if(link.getAttribute('togglecheck'))
					{
						QMenu.toggleCheck(selectionNode);
					}
					if(link.getAttribute('togglecheckexclusive'))
					{
						QMenu.toggleCheck(selectionNode, {selectOne:true});
					}

					if(link.getAttribute('keepmenuopen'))
					{
						return;
					}
				}
			}
			else
			{
				//they probably clicked on a separator
				return;
			}

			//flash the menu item
			$(selectionNode.firstChild).addClassName('hover'); // Added for touch devices which don't have the :hover css selector
			$(selectionNode.firstChild).addClassName('SelectionFlash');
			$(selectionNode.firstChild).removeClassName.bind(selectionNode.firstChild, 'SelectionFlash').delay(0.1);
			$(selectionNode.firstChild).removeClassName.bind(selectionNode.firstChild, 'hover').delay(0.1); // Added for touch devices which don't have the :hover css selector
		}

		if(!link || link.nodeName != 'A')
		{
			//they clicked on something other than a menu item and have requested to not close menus on such events
			//so we will not close the menu and not run any of the item select callbacks
			if(menu.options && menu.options.closeMenuOnNonMenuItem === false)
			{
				return;
			}
		}
		if(itemDef.ignoreSelects)
		{
			shouldRunSelectionFunctions = false;
		}
		var keepMenuOpen = menu.options.keepmenuopen || itemDef.keepMenuOpen;

		if(selectionNode && menu && shouldRunSelectionFunctions)
		{
			if(!keepMenuOpen)
			{
				//NOTE: you can call QMenu.keepMenuOpen after the fact to prevent the menu from actually closing.
				clearTimeout(Qualtrics.Menu.menuCloseTimer);//just to make sure we arent doubling up on timeouts here.
				//in 0.3 seconds, destroy the menu that was active at this time.
				//if something has already else destroyed it, the destroyMenu function will just ignore this command.
				Qualtrics.Menu.menuCloseTimer = Qualtrics.Menu.destroyMenu.curry(menu.id).delay(0.3);
			}
			//look for a function that we might have to run
			this.runSelectCallBack(menu, itemDef, selectionNode);

		}
		if(selectionNode && (menu.options.buttonTitleCallback || menu.options.selectMenu || (menu.menuDef || {}).selectMenu) && itemDef && !itemDef.notselectable)
		{

			menu.currentValue = itemDef.value;

			if(menu.parentButton)
			{
				menu.parentButton.setAttribute('currentvalue', menu.currentValue);
			}
			var text = menu.getItemDisplay(itemDef, true);
			if(itemDef.htmlContent)
			{
				text = itemDef.htmlContent;
			}
			if(this.options.buttonTitleCallback)
			{
				var parameterMap = {
					'$menuPane':this,
					'$originalText':text
				};
				text = Qualtrics.Event.executeDotSyntax(this.options.buttonTitleCallback,null,null,null,parameterMap);
			}
			menu.setButtonText(text);
		}
		if(itemDef.refreshMenu)
		{
			menu.refreshMenu.bind(menu).defer();
		}
		menu = null;
	},
	runSelectCallBack:function(menu, itemDef, opt_selectionNode)
	{
		if(menu.type != 'SelectMenuPane') //select menus do their own menuItemSelectCallback running and we dont want to run it twice
		{
			var selectCallBack = menu.options['menuItemSelectCallback'] || (menu.menuDef && menu.menuDef['menuItemSelectCallback']);
			var selectCallBackSyncronous = menu.options['menuItemSelectCallbackSync'] || (menu.menuDef && menu.menuDef['menuItemSelectCallbackSync']);
			if(selectCallBack || selectCallBackSyncronous)
			{

				var params = [opt_selectionNode];
				//allow $selected and $fieldName as a special keyword param when using menuitemselectcallback
				var parameterMap = {
					'$selected':opt_selectionNode,
					'$value':itemDef.value,
					'$item':itemDef,
					'$checked':itemDef.checked,
					'$menuPaneId':this.id,
					'$menuPane':this,
					'$options':this.options,
					'$menuDef':this.menuDef
				};

				if(selectCallBackSyncronous)
				{
					//if you absolutely have to have it syncronous and are not using ajax then this will do it for you.
					Qualtrics.Event.executeDotSyntax(selectCallBackSyncronous,null,null,null,parameterMap,params);
				}
				else
				{
					//this is defered by default because IE6 sometimes forgets to run it otherwise.
					Qualtrics.Event.executeDotSyntax.curry(selectCallBack,null,null,null,parameterMap,params).defer();
				}

			}
		}
	},
	artificiallyExecuteMenuItem:function(liNode)
	{
		if(liNode && $(liNode).down)
		{
			var a = $(liNode).down();
			if(a)
			{
				var clickcallback = a.getAttribute('clickcallback')||a.getAttribute('mouseupcallback');
				var instanceid = a.getAttribute('instanceid');
				var i=0, params = [];
				do{
					i++;
					var param = a.getAttribute('p'+i);
					if(param)
					{
						params.push(param);
					}
				}while(param);
				if(clickcallback)
				{
					Qualtrics.Event.executeDotSyntax(clickcallback, instanceid, null, params);
				}
			}
		}
	},
	getDynamicSubMenuClosure:function(subMenu, button, options)
	{
		options = Qualtrics.Menu.processOptions(options);
		options.right = 0;
		return this.getSubMenuShowClosure(subMenu, button, options);
	},
	/**
	* Qualtrics.MenuPane.getSubMenuShowClosure
	* returns a function that shows the subMenu.
	* note that there is a 100ms delay before the function is run.
	* This is to ensure that enough time has passed for the velocimeter to get a good mouse speed reading.
	*
	* @param {String|Function|Node} menuBuilder - the responsible for building the submenu
	* @return {Function} the function that positions and sets a submenu to display:block.
	*/
	getSubMenuShowClosure:function(menuBuilder, button, options)
	{
		var that = this;
		options = options || {};
		options.parentNode = this.menuDom; //attach the submenu to the same div that contains the root menu.
		return function(evt)
		{

			if(that.parentMenu)
			{
				//parent menus might (probably will) be set to traveling because that was their last state when that was being calculated for them
				//we dont want traveling that so, this is a good spot to make sure that any parents can be closed when the child is
				that.parentMenu.traveling = false;
			}

			//we know that the mouse is moving so now is a good time to deactivate arrow mode
			if(options.mouse)
			{
				Qualtrics.Menu.deactivateArrowMode();
			}
			//make sure that another menu has not opened (perhaps menu with the menuWithinMenu option)
			var activeMenuPane = Qualtrics.Menu.getActiveMenuPane();
			if(activeMenuPane.getRootMenu().id != that.getRootMenu().id)
			{
				//the active menu doesn't have anything to do with us so we arent going to
				//open any submenus until it is closed
				return;
			}
			if(that.activeSubMenu && that.activeSubMenu.parentButton == button)
			{
				//we are already showing this submenu, so we don't want to show it again
				//we will however stop any hides from happening
				that.hideSubMenuOnLowVelocity = false;
				that.suppressedSubMenu = null;
				return;
			}
			//we dont want the menu to be hidden
			that.hideSubMenuOnLowVelocity = false;

			that.showSubMenu.bind(that, menuBuilder, button, options)();
			//if(!that.showTimer) //don't ever commission more than 1 menu at a time to be built.
			//{
			//	that.showTimer = setTimeout(that.showSubMenu.bind(that, menuBuilder, button, options), 1);
			//}
		};
	},
	getSubMenuHideClosure:function(options)
	{
		var that = this;
		options = options || {};
		return function(evt)
		{
			that.hideSubMenuOnLowVelocity = false;//this probably isn't necessary
			that.suppressedSubMenu = null; //we don't need any suppressed menus poping out after this point
			var activeMenu= Qualtrics.Menu.getActiveMenuPane();
			if(options.mouse)
			{
				Qualtrics.Menu.deactivateArrowMode();
			}

			if(Qualtrics.Menu.asyncMenuTimout)
			{
				clearTimeout(Qualtrics.Menu.asyncMenuTimout);
				Qualtrics.Menu.asyncMenuTimout = null;
			}
			if(activeMenu && activeMenu.parentMenu)
			{
				if(activeMenu == that.activeSubMenu)
				{
					//the currently active submenu is a direct child of THIS menu,
					//so we need to give them a chance to get over to it without closing it
					activeMenu.parentMenu.hideSubMenuOnLowVelocity = true;
				}
				else
				{
					//the menu is an extended descendent so lets just close our submenu right now.
					that.hideSubMenu();
				}
			}
		};
	},
	/**
	* Qualtrics.MenuPane.getSubMenuHideSequenceClosure
	* this function doesnt actually hide the subMenu.
	* it just sets the flag that the velocimeters looks for.
	* The menu will be hidden as soon as they stop moving their mouse horizontally.
	* @param {HTMLUlElement} subMenu - the submenu UL that is to be hidden
	* @return {Function} it returns a function so we can assign it directly to an event with no memory leaks
	*/
	getSubMenuHideSequenceClosure:function(subMenu)
	{
		var menuPane = this;
		return function()
		{
			//remove the suppressedSubMenu cause we dont want it to popup anymore
			if(menuPane.suppressedSubMenu && menuPane.suppressedSubMenu.menu == subMenu)
			{
				menuPane.suppressedSubMenu = null;
			}
			//if any menus are waiting to be shown then stop them so they dont trigger after this.
			if(menuPane.showTimer)
			{
				clearTimeout(menuPane.showTimer);
				menuPane.showTimer = null;
			}
			menuPane.hideSubMenuOnLowVelocity = true;
		};
	},
	/**
	* @param {String|Function|Node} subMenu - the submenu definition
	* @param {Node} button - the li that was hovered over
	*/
	showSubMenu:function(subMenu, button, options)
	{
		options = Qualtrics.Menu.processOptions(options);
		this.showTimer = null;

		if(this.traveling)
		{
			//if we are traveling we are going to suppress the menu so it shows when they stop moving their mouse.
			this.suppressedSubMenu = {menu:subMenu, button:button, options:options};
			return false;
		}

		//we are showing a submenu so this is a good time to make sure that no suppressed submenus are going to show themselves in the future.
		this.suppressedSubMenu = null;
		//make sure no other submenus are coming out of this menu
		this.hideSubMenu();
		//create a new menupane to represent the submenu and assign it as the this menus activeSubMenu
		options.position = "horizontal";

		if(this.type == "SelectMenuPane")
		{
			//we need to preserver the correct parent node
			var parentNode = options.parentNode;
			Object.extend(options, this.options);
			if(parentNode)
				options.parentNode = parentNode;

			this.activeSubMenu = new Qualtrics.SelectMenuPane(subMenu, button, this, options);
		}
		else
		{
			// show submenus asynchronously. This will let the
			// user scan lots of intense sub menu wihout the menu
			// actually getting rendered unless they hold for a split second.
			if (!options.classicSubMenu)
				options.asynchronous = true;
			this.activeSubMenu = new Qualtrics.MenuPane(subMenu, button, this, options);
		}

		this.activeSubMenu.setupSubMenuEvents();
		if(this.arrowMode)
		{
			//if we are in arrow mode select the first item on the top of the submenu (doing this will also put the submenu in arrow mode which we want)
			Qualtrics.Menu.down(subMenu);
		}
	},
	/**
	* assigns all the events a menu will need if its a submenu
	*/
	setupSubMenuEvents:function(subMenuBuilder, menuDom, button)
	{
		if(this.parentMenu)
		{
			if(this.getRootMenu().options.closeSubMenuOnMouseOut) //off by default
			{
				//make sure that our opener has a mouseout. remember that this can be dynamically on the fly
				//so the mouseout event might not be possible until the submenu has actually been build
				this.parentButton.onmouseout = this.parentMenu.getSubMenuHideSequenceClosure(this.menuDom);
				this.menuDom.onmouseout = this.parentMenu.getSubMenuHideSequenceClosure(this.menuDom);
			}
			this.menuDom.onmouseover = this.parentMenu.getSubMenuShowClosure(this.menuBuilder, this.parentButton);
		}
	},
	/**
	* Qualtrics.MenuPane.hideSubMenu
	* actually hides the active submenu and removes the associated css classNames.
	*/
	hideSubMenu:function()
	{
		if(this.activeSubMenu)
		{
			this.activeSubMenu.destroy();
		}
	},
	/**
	* setSuspend to true will not allow the menu (or any parents) to be closed until suspend is set to false.
	**/
	setSuspend:function(v)
	{
		this.suspend = v;
		if(this.parentMenu)
		{
			this.parentMenu.setSuspend(true);
		}
	},
	/**
	* Qualtrics.MenuPane.destroy
	* cleans up the events on the menu and removes it from the page.
	*/
	destroy:function(opt_recursive)
	{
		if(this.suspend)
		{
			return false;
		}
		this.destroyed = true;
		Qualtrics.Menu.removeMenuPaneFromStack(this);
		//remove this menus part of the outline if there is one
		if(this.menuOutlineDom)
		{
			removeElement(this.menuOutlineDom);
		}
		if(this.parentButton)
		{
			$(this.parentButton).removeClassName('ActiveSubMenu');
		}
		if(this.parentMenu)
		{
			//we dont really destroy submenus we hide them
			if(this.activeSubMenu)
			{
				//if the submenu has a submenu make sure we destroy that one first
				this.activeSubMenu.destroy();
			}

			if ($(this.parentMenu.menuUl))
				$(this.parentMenu.menuUl).removeClassName('HasActiveSubMenu');
			if(this.menuDom)
			{
				$(this.menuDom).hide();
			}
			//I think we can't have persistent submenus anymore, sorry.
			if(this.menuDom)
			{
				this.menuDom.onmouseup = null; //dont leak memory
				this.menuDom.ontouchend = null; //dont leak memory
				if ($(this.menuDom).parentNode != null)
				{
					$(this.menuDom).remove();
				}
			}

			this.parentMenu.activeSubMenu = null;
			this.parentMenu.hideSubMenuOnLowVelocity = null;
			if(opt_recursive)
			{
				this.parentMenu.destroy(opt_recursive);
			}
		}
		else
		{
			//destroy a root menu
			this.selectionNode = null;
			if(!Qualtrics.Menu.menuPaneStack.length)
			{
				Event.stopObserving(document,'mousedown', Qualtrics.Menu.documentDownHandler);
				Event.stopObserving(document,'touchstart', Qualtrics.Menu.documentTouchObserver);
				Qualtrics.Menu.documentObserver = null;
				Qualtrics.Menu.documentTouchObserver = null;
				if(Qualtrics.Menu.overlayObj)
				{
					Qualtrics.Menu.overlayObj.remove();
					Qualtrics.Menu.overlayObj = null;
				}
			}
			if(this.menuDom)
			{
				this.menuDom.onmouseup = null; //dont leak memory
				if ($(this.menuDom).parentNode != null)
				{
					$(this.menuDom).remove();
				}
			}
			this.menuDom = null;
			this.menuUl = null;
			this.searchInput = null;
		}
		if(this.parentButton && this.parentButton.aNode)
		{
			$(this.parentButton.aNode).removeClassName('HasActiveMenu');
		}
		if(this.options.onMenuClose)
		{
			Qualtrics.Event.executeDotSyntax(this.options.onMenuClose, null, null, null, {'$menuPane':this, '$menuPaneId':this.id});
		}
		if(this.menuDef && this.menuDef.onMenuClose)
		{
			Qualtrics.Event.executeDotSyntax(this.menuDef.onMenuClose, null, null, null, {'$menuPane':this, '$menuPaneId':this.id});
		}
		if(this.onClose)
		{
			try{
				this.onClose();
			}catch(e)
			{
				throw(e);
			}
		}
	},
	/**
	* when you start navigating menus with arrows we need to set up a bunch of mouseover events to deactivate arrow mode and go back into mouse mode.
	* NOTE: we dont want to put these mouseover events on menus by default to stay lean.
	*/
	activateArrowMode:function()
	{
		//first thing we need to do is set mouseovers to unactivate arrow mode
		this.setupMouseModeEvents();
		this.arrowMode = true;
		$(this.menuUl).addClassName('ArrowSelectMode');
	},
	deactivateArrowMode:function()
	{
		if(this.arrowMode)
		{
			$(this.menuUl).removeClassName('ArrowSelectMode');
			this.arrowMode = false;
			this.arrowSelectedItem = null;
			if(!this.parentMenu)
			{
				this.menuUl.onmouseover = null;
			}
			this.hideSubMenu();
		}
	},
	setupMouseModeEvents:function()
	{
		if(this.menuUl && !this.parentMenu) //we only setup this mouse event for the main menu, because submenus have their own mouseovers which have this function built in.
		{
			this.menuUl.onmouseover = Qualtrics.Menu.deactivateArrowMode;
		}
	},
	/**
	* this is for clearing all arrow selected menu items
	*/
	unselectAll:function()
	{
		var children = $(this.menuUl).childElements();
		for(var i=0, len=children.length; i<len; ++i)
		{
			var li = children[i];
			li.removeClassName('ArrowSelected');
		}
	},
	/**
	* this is for arrow selecting menu items
	*/
	selectItem:function(liNode)
	{
		if(!this.arrowMode)
		{
			this.activateArrowMode();
		}
		this.unselectAll();
		this.arrowSelectedItem = liNode;
		$(liNode).addClassName('ArrowSelected');
	},
	focusSearch: function()
	{
		if (this.searchInputDom)
			this.searchInputDom.focus();
	},
	setButtonText:function(text)
	{
		var button = this.parentButton;
		if(button)
		{
			var callbackNode = '';
			var aTag = QualtricsTools.fastUp(button,'menuButton');
			if(!aTag)
			{
				if(button.nodeName == 'A')
				{
					aTag = button;
				}
				else if (button.aNode)
				{
					aTag = button.aNode;
				}
				else
				{
					//if there is no menuButton class try to find any ancestor A tag.
					aTag = $(button.up('a'));
				}
			}
			if(aTag && aTag.callbackNode)
			{
				callbackNode = aTag.callbackNode;
			}
			else
			{
				//attepmt to figure out the callbackNode
				//check to see if there is a B tag (we use b as menu structure so the last b tag will be the furthest down point in the menu before the text)
				var root = aTag || button;
				callbackNode = $(root).down('b');
				if(callbackNode)
					callbackNode = $(callbackNode).down('b')||callbackNode;
				if(callbackNode)
					callbackNode = $(callbackNode).down('b')||callbackNode;

				if(!callbackNode)
				{
					//if there is no b then just go all the way down
					var textNode = QualtricsTools.fastDown(button);
					if(textNode && textNode.nodeType == 3)
					{
						//is the a textNode
						callbackNode = textNode.parentNode;
					}
				}
			}

			if(callbackNode)
			{
				if (callbackNode.updateTitle)
					callbackNode.updateTitle(text);
				else
					callbackNode.innerHTML = text;
				//textNode[textNode.innerText?'innerText':'textContent'] = text; //this turned out to be bad for buttons with html in them
			}
		}
	},
	setupMenuButtonInput:function(initialValue, fieldName, button)
	{
		if(!$(fieldName))
		{
			var input = QBuilder('input',{type:'hidden', id:fieldName, name:fieldName, value:initialValue});
			if(button && button.firstChild)
				button.firstChild.appendChild(input);
		}
		else
		{
			//make sure an initial value is set
			if(!$(fieldName).value) $(fieldName).value = initialValue;
		}
		button.setAttribute('currentvalue', initialValue);
	},
	nextPage:function()
	{
		this.startIndex += this.perpage;
		this.hideSubMenu();
		Qualtrics.Menu.keepMenuOpen();
		this.refreshMenu();
	},
	prevPage:function()
	{
		if (this.startIndex > 0)
		{
			this.startIndex -= this.perpage;
			this.hideSubMenu();
			Qualtrics.Menu.keepMenuOpen();
			this.refreshMenu();
		}
	}
};


Qualtrics.SelectMenuPane = Class.create(Qualtrics.MenuPane,{
	type:'SelectMenuPane',
	initialize: function($super, menuBuilder, parentButton, opt_parentMenu, options)
	{
		$super(menuBuilder, parentButton, opt_parentMenu, options);
	},
	getItemCallback:function(item, itemIndex)
	{
		if(item.disabled)
		{
			return false;
		}
		return (item.action)?item.action.replace('$menuPaneId', this.id):'Qualtrics.SelectMenuPane.selectMenuItemSelect:'+this.id+'('+itemIndex+', $evt)';
	},
	/**
	* Qualtrics.SelectMenuPane.selectMenuItemSelect
	* This gets run when the clicks a selects a menu item from a selectMenu
	* it's responsible for stuff
	*/
	selectMenuItemSelect:function(itemIndex, opt_evt)
	{
		var item = this.menuDef.items[itemIndex];
		var fieldName = this.options.fieldName;
		var value = this.getItemValue(item);

		if(!value)
		{
			if (!item.unselectable)
				return;
		}
		if($(fieldName))
		{
			$(fieldName).value = value;
		}
		var button = this.parentButton;
		if(button)
		{
			button.setAttribute('currentvalue', value);
		}
		var text = this.getItemDisplay(item);
		var truncate = this.menuDef.truncate;

		if(truncate)
		{
			text.truncate(truncate);
		}
		var selectCallBack = this.options['menuItemSelectCallback'] || button.getAttribute('menuitemselectcallback');
		if(this.selectionNode && !this.options.displayAsText)
			this.setButtonText(text);

		if(selectCallBack && this.selectionNode)
		{
			var selectedNode = this.selectionNode;

			var aNode = $(selectedNode).down('a');
			if(!value)
			{
				value = aNode.getAttribute('p3');
			}
			if(!text)
			{
				text = aNode.getAttribute('p4');
			}
			var params = [this.options.buttonId, value, text];
			//allow $selected and $fieldName as a special keyword param when using menuitemselectcallback
			var parameterMap = {
				'$selected':selectedNode,
				'$value':value,
				'$label':text,
				'$fieldName':fieldName,
				'$buttonId':this.options.buttonId,
				'$menuDef':this.menuDef,
				'$item':item,
				'$itemIndex':itemIndex,
				'$evt':opt_evt
			};
			//if there are params in the callback then dont use the default params
			if(Qualtrics.Event.callbackHasParams(selectCallBack))
			{
				params = null;
			}

			Qualtrics.Event.executeDotSyntax.curry(selectCallBack,null,null,params, parameterMap).defer(); //this is defered because IE6 sometimes forgets to run it otherwise.
		}
	}
});
Qualtrics.SelectMenuPane.getInstance = QualtricsTools.getInstanceHelper(Qualtrics.Menu.menuPaneStack,'id');

/***
 * Simple static Select control
 * ***/
Qualtrics.Select = Class.create({
	initialize:function(options)
	{
		this.options = options || {};
		this.id = QualtricsTools.createNewId('SEL');
		Qualtrics.Select.reg[this.id] = this;

		this.list = this.options.list || {};
		var index = 0;
		if (this.options.value)
		{
			index = this.getValueIndex(this.options.value);
		}
		this.setIndex(index);
	},
	getValueIndex:function(val)
	{
		for (var i=0,ilen=this.list.length;i<ilen;i++)
		{
			if (val == this.list[i].value)
				return i;
		}
		return -1;
	},
	select:function(index)
	{
		if(!this.list[index].disabled)
		{
			this.setIndex(index);
			if (this.options.onSelect)
				this.options.onSelect(index, this.getValue(), this.getDisplay());
		}
	},
	setIndex:function(index)
	{
		if (index == -1)
			index = 0;
		if (this.list[index])
		{
			this.selected = index;
			if (this.button)
				this.updateTitle(this.list[index].display);
		}
	},
	updateTitle:function(display)
	{
		if(this.options.truncateButton && window.QualtricsCPTools)
		{
			display = QualtricsCPTools.middleTruncate(display, this.options.truncateButton);
		}
		this.button.updateTitle(display);
	},
	getValue:function()
	{
		return this.list[this.selected].value;
	},
	getDisplay:function()
	{
		return this.list[this.selected].display;
	},
	build:function()
	{
		this.button = Qualtrics.Menu.buildMenuButton('Select...', 'Qualtrics.Select.showMenu:'+this.id, {className:'SelectMenuButton ' + this.options.className});
		this.updateTitle(this.list[this.selected].display);
		return this.button;
	},
	showMenu:function()
	{
		var items = [];

		for (var i=0,ilen=this.list.length;i<ilen;i++)
		{
			var item = {
				display:this.list[i].display,
				action:'Qualtrics.Select.select:'+this.id+'('+i+')',
				disabled:this.list[i].disabled
			};
			if (this.selected == i)
				item.checked = true;
			items.push(item);
		}
		var menuDef = {
			items:items,
			togglecheck:true,
			togglecheckexclusive:true
		};
		return menuDef;
	}
});
Qualtrics.Select.reg = {};
Qualtrics.Select.getInstance = QualtricsTools.getInstanceHelper(Qualtrics.Select.reg);

Qualtrics.Info = {
	infoId:'',
	languages:{},
	altLanguage:'',
	content:'',
	targetURL:'',
	masterList:{},
	loadedPageInfo:false,
	activatedOverCalls:false,
	defaultMessage: null,

	/**
	 *	Loades help info for that current page
	 *	activated over calls in the global event handler
	 *	This method is called by createInfoElement if help
	 *	info is not loaded
	 */
	loadInfoForPageSection:function()
	{
		//load help tips for current page
		new Ajax.Request(URLTools.getAjaxURL('GetInfoTipsForPage'),{
			onComplete:function(transport)
			{
				var results = transport.responseText.evalJSON();

				if(results._enabled === false)
				{
					Qualtrics.User.helpTipsEnabled = 0;
					Qualtrics.HelpInfoTips._enabled = false;
				}
				else
				{
					Qualtrics.HelpInfoTips = results;
					Qualtrics.User.helpTipsEnabled = 1;

					if(!this.activatedOverCalls)
					{
						// activate hover
						Qualtrics.Event.activateOverCallbacks();
						this.activateOverCallbacks = true;
					}
				}
			}
		});

	},

	/**
	 * Adds the required info to the div to make an info button work
	 *@param {string} infoId - the unique id of the element
	 *@param {Element} el - the element to add the info button to
	 *@param {object} options - options for the creation
	 *		options.left - float left
	 *		options.right - float right
	 *		options.recurse - adds the infoId to all elements under the parent, all elments are part of the hover
	 *		optins.InlineBlock - set the display to inline block
	 *@return {Elment} returns the div with the correct class names added
	 */
	createInfoElement:function(el,infoId, options)
	{
		options = options || {};
		//load on first div creation
		if(!this.loadedPageInfo)
		{
			this.loadInfoForPageSection();
			this.loadedPageInfo = true;
		}


		if (options && options.left)
		{
			el.setAttribute('className', 'Left');
		}
		if (options && options.right)
		{
			el.setAttribute('className', 'Right');
		}
		if (options && options.recurse)
		{
			// recursivly set all children
			this.addInfoAttribute(el, infoId);
		}
		else
		{
			el.setAttribute('infoButton', infoId);
		}
		if(options && options.InlineBlock)
		{
			el.addClassName('InfoInlineBlock');
			el = QBuilder('div',{},[
									el,
									QBuilder('div', {className:'clear'})]);
		}
		return el;

	},
	/**
	 *Recursive funciton that adds the infoId to the element
	 *then calls itself on all the children
	 * @param {Element} el - element to add the infoId to
	 * @param {string} infoId - unique info id
	 */
	addInfoAttribute:function(el,infoId)
	{
		el.setAttribute('infoButton', infoId);
		var children = el.childElements();
		for(var x=0;x<children.length;x++)
		{
			this.addInfoAttribute(children[x], infoId);
		}
	},
	showButton:function(infoId, evt){
		if (!Qualtrics.User.helpTipsEnabled || !Qualtrics.HelpInfoTips || !Qualtrics.HelpInfoTips._enabled)
			return;

		// check for a default message on the element
		if (evt.target.hasAttribute('message') && this.defaultMessage === null)
		{
			this.defaultMessage = evt.target.getAttribute('message');
		}

		var myTips = Qualtrics.HelpInfoTips['ValidTips'][infoId];
		if (myTips === undefined)
		{

			/*
			 Note: There used to be code here to register new HelpTips; however, since SiteIntercept (DX),
			 was identified the only ones using HelpTips and they no longer want to create new HelpTips
			 in this fashion, the register functionality was removed from here.  Existing ones
			 still continue to work though. (JIRA: DUX-1708)
			 */

			//If there's no text for the InfoButton, don't even show it unless the user is an admin
			if (Qualtrics.User.userType != 'UT_SERVERADMIN' && this.defaultMessage === null)
				return;
		}

		var infoButton = $('InfoButton_'+infoId);
		if(!infoButton && evt)
		{
			//if we have no infoButton, make one!
			var el = Event.element(evt);
			infoButton = QBuilder('span',{bubbleup:false, className:'InfoButton', id:'InfoButton_'+infoId});
			//insert after
			if(el.nextSibling)
			{
				el.parentNode.insertBefore(infoButton, el.nextSibling);
			}
			else
			{
				el.parentNode.appendChild(infoButton);
			}
		}
		if(infoButton)
		{
			if(!infoButton.childNodes.length)
			{
				infoButton.appendChild(QBuilder('span',{className:'InfoInner', infobutton:infoId}));
			}
			infoButton = $(infoButton);
			infoButton.setAttribute('infobutton', infoId);
			infoButton.setAttribute('downcallback','Qualtrics.Info.showInfo('+infoId+', $evt, '+this.defaultMessage+')');
			infoButton.addClassName('Show');
			if (!infoButton.hasClassName('HoverFree'))
			{
				//hide the button whenever they mouse out of any element
				//we do this because if we only have the mouseout on 1 element and the browser skips it (which it might)
				//the infoButton would be visible indefinitely.
				Qualtrics.Event.addGlobalOutCallback('Qualtrics.Info.hideButton('+infoId+')');
			}
		}
	},
	hideButton:function(infoId, evt){
		var infoButton = $('InfoButton_'+infoId);
		if(infoButton)
		{
			infoButton.removeClassName('Show');
		}
	},
	showInfo:function(infoId, evt)
	{
		if (!Qualtrics.User.helpTipsEnabled)
			return;
		// if only a target open target unless multibrandadmin or above
		// check for a default message on the element
		if (this.defaultMessage === null && evt.target.hasAttribute('message'))
		{
			this.defaultMessage = evt.target.getAttribute('message');
		}

		// if only a target open target unless multibrandadmin or above
		var helpText = Qualtrics.HelpInfoTips['ValidTips'][infoId] || {};
		if( (helpText.Value == 'No help available' || helpText.Value === undefined) && helpText.targetURL != undefined && Qualtrics.User.userType != 'UT_SERVERADMIN' && this.defaultMessage === null)
		{
			this.showTargetURL(helpText.targetURL);
			return;
		}
		var menu = Qualtrics.Menu.showMenu('Qualtrics.Info.getInfoMenuDef('+infoId+')',
			Event.element(evt),
			{
				position:'vertical',
				alignment:'center',
				direction:'up',
				connector:true
			},
			evt);
		this.infoId = infoId;

		//this is a hack to get the menu to flip when it is off the top of the screen

		var infoBox =  document.getElementsByClassName('InfoBox')[0];
		var offSet = infoBox.getBoundingClientRect().top;
		if(offSet<0)
		{
			QMenu.destroyMenu();
			menu.
			menu = Qualtrics.Menu.showMenu('Qualtrics.Info.getInfoMenuDef('+infoId+')',
			Event.element(evt),
			{
				position:'vertical',
				alignment:'center',
				direction:'down',
				connector:true
			},
			evt);
		}
	},
	getInfoMenuDef:function(infoId)
	{
		var helpText = Qualtrics.HelpInfoTips['ValidTips'][infoId] || {};
		if (helpText.Value === undefined || helpText.Value === 'No help available')
		{
			// Check for a string that can be split on a comma for the default message
			if (typeof this.defaultMessage === 'string' && this.defaultMessage.indexOf('|') !== -1)
			{
				var messageParts = this.defaultMessage.split('|');
				helpText.Value = getMessage(messageParts[0], messageParts[1]);
			}
			else
			{
				helpText.Value = 'No help available'; //this will only ever be shown to Admins
			}
		}
		return this.processMenuDef(helpText);
	},
	/**
	 * Function to register the page for help info tips
	 * Then shows the helpinfo popup or allows server admins to edit
	 * Basically combines functionality of the showButton and showInfo methods
	 */
	showInfoForCustomElement:function(infoId, evt) {
		if (!Qualtrics.User.helpTipsEnabled || !Qualtrics.HelpInfoTips || !Qualtrics.HelpInfoTips._enabled)
			return;

		var myTips = Qualtrics.HelpInfoTips['ValidTips'][infoId];

		/*
		 Note: There used to be code here to register new HelpTips; however, since SiteIntercept (DX),
		 was identified the only ones using HelpTips and they no longer want to create new HelpTips
		 in this fashion, the register functionality was removed from here.  Existing ones
		 still continue to work though. (JIRA: DUX-1708)
		 */

		if (this.defaultMessage === null && evt.target.hasAttribute('message'))
		{
			this.defaultMessage = evt.target.getAttribute('message');
		}

		if(Qualtrics.User.userType == 'UT_SERVERADMIN' || myTips || this.defaultMessage !== null)
			this.showInfo(infoId, evt);
	},
	getInfoTipEditor:function()
	{
		var infoId = this.infoId;

		Element.hide($$('.InfoBox')[0]); //hide the active toolTip.
		var response = '';
		new Ajax.Request(URLTools.getAjaxURL('GetHelpInfoForEditing'),{
			parameters:{
				InfoID:infoId
			},
			asynchronous:false,
			onComplete:function(transport){
				response = transport.responseText.evalJSON();
				delete response.RequestStatus;
			}
		});

		if (response == '')
		{
			return;
		}
		else if (response.Error || response.ErrorMessage)
		{
			this.showErrorMessage('Error retrieving Help Info.');
			return;
		}

		var targetURL = response['targetURL']['Value'] || '';
		delete response.targetURL;

		var textboxes = [];
		for (var lang in response)
		{
			if (!this.languages[lang])
			{
				this.languages[lang] = {};
				this.languages[lang]['Name'] = response[lang]['Name'];
			}
			var div = QBuilder('div',{className:'infoTextLanguageEditor'},[
				QBuilder('div',{className:'LanguageName'},[
					QBuilder('span',{},response[lang]['Name']),
					QBuilder('br'),
					QBuilder('span',{},'('+lang+') ')
				]),
				QBuilder('textarea', {className:'infoTextEditor', id:'infoTextEditor_'+lang,type:'textarea',name:lang}, response[lang]['Value'] || '')
			]);
			textboxes.push(div);
		}
		textboxes.push(QBuilder('br'));
		textboxes.push(QBuilder('hr',{className:'clear'}));
		textboxes.push(QBuilder('h2',{},'Target URL'));

		var targetInputElement = QBuilder('input', {className:'infoTextEditor', id:'infoTextEditor_targetURL_'+infoId, name:'targetURL'});
		targetInputElement.value = targetURL;

		//div for targetURL
		var targetURLDiv = QBuilder('div',{className:'infoTextLanguageEditor'},[
				targetInputElement,
				QBuilder('a',{className:'qbutton neutral', clickcallback:'Qualtrics.Info.showTestTargetURL('+infoId+')'},'Test Target URL')
			]);

		textboxes.push(targetURLDiv);
		textboxes.push(QBuilder('hr',{className:'clear'}));

		new Q_Window('InfoTipEditor',{
			title:QBuilder('div', {}, [
				QBuilder('div',{},[
					QBuilder('div',{style:'float:left'},'Edit Text for \''+ infoId + '\' ToolTip'),
					QBuilder('a',{href:'javascript:void(0);', style:'float:right;', clickcallback:'Qualtrics.Info.getInfoTipMasterEditor'},
						'  View/Edit all Help Tips (System-Wide)'
					)
				]),
				QBuilder('br')
			]),
			width:'75%',
			content:QBuilder('form',{},textboxes),
			buttons:[
				{text:'Cancel', className:'negative', click:'Q_Window.closeWindow'},
				{id:'SaveButton', text:'Save', className:'positive', click:'Qualtrics.Info.save('+infoId+')'}
			]
		});
	},

	showTestTargetURL:function(infoId)
	{
		var sourceDiv = $('infoTextEditor_targetURL_'+infoId);
		var source = sourceDiv.value || '';
		//don't show empty string url'
		if (source ==='')
			return;
		this.showTargetURL(source);
	},
	/**
	 * Opens a Q_Window iframe with the source URL
	 * as the parameter passed in.
	 *
	 */
	showTargetURL:function(windowSource)
	{

		// regex check the url??

		// append &iFrame=True
		if(windowSource.indexOf('?') == -1)
		{
			windowSource+='?Q_IFrame=true';
		}
		else
		{
			windowSource+='&Q_IFrame=true';
		}
		QMenu.destroyMenu();
		var window = new Q_Window('HelpPage',{
			'url':windowSource,
			iframescrolling:true,
			width:'90%',
			height:'90%'
		});

	},
	getInfoTipMasterEditor:function(editorWindow)
	{
		var that = this;
		var error = null;
		new Ajax.Request(URLTools.getAjaxURL('GetHelpInfoMasterList'),{
			asynchronous:false,
			onComplete:function(transport){
				var masterList = transport.responseText.evalJSON();
				if (masterList.ErrorMessage || masterList.Error)
				{
					error = 'Error retrieving Help Info.';
					that.masterList = [];
				}
				else
				{
					delete masterList.RequestStatus;
					that.masterList = masterList;
				}
			}
		});

		Q_Window.closeWindow(editorWindow);
		if (error)
		{
			this.showErrorMessage(error);
			return;
		}

		if (this.altLanguage == '')
		{
			this.altLanguage = 'ES'; //have to default to something...
		}

		var table = QBuilder('table',{className:'InfoTextMasterEditor'},[
			QBuilder('tr',{className:'InfoTextMasterHeader'},[
				QBuilder('td',{className:'infoTipIdHeader'}),
				QBuilder('td',{className:'infoTipEditorHeader'},[
					QBuilder('span',{className:'languageItem'},'English')
				]),
				QBuilder('td',{className:'infoTipEditorHeader'},[
					QBuilder('select',{className:'languageItem', id:'languageSelector'})
				])
			])
		]);

		for (var tipId in this.masterList) {
			var tr = QBuilder('tr',{className:'infoTextMasterEditor'},[
				QBuilder('td',{className:'InfoTipName'},[
					QBuilder('span',{},[
						QBuilder('b',{},tipId)
					])
				]),
				QBuilder('td',{className:'InfoTextEditorCell'},[
					QBuilder('textarea', {className:'infoTextEditor', id:'infoTextEditor_EN_'+tipId,type:'textarea',name:tipId+'_EN'}, this.masterList[tipId]['EN'] || '')
				]),
				QBuilder('td',{className:'InfoTextEditorCell'},[
					QBuilder('textarea', {
						className:'infoTextAltEditor',
						id:'infoTextEditor_'+this.altLanguage+'_'+tipId,
						type:'textarea',
						name:tipId+'_'+this.altLanguage
					}, this.masterList[tipId][this.altLanguage] || '')
				])
			]);

			table.appendChild(tr);
		}
		new Q_Window('InfoTipMasterEditor',{
			title:QBuilder('div',{},[
				QBuilder('span', {}, 'Edit Help Info Tips (System-Wide)')
			]),
			width:'75%',
			content:QBuilder('form',{},[table]),
			buttons:[
				{text:'Cancel', className:'negative', click:'Q_Window.closeWindow'},
				{id:'SaveButton', text:'Save', className:'positive', click:'Qualtrics.Info.save(_master)'}
			]
		});

		for (var lang in this.languages)
		{
			if (lang != 'EN')
			{
				var opt = QBuilder('option',{value:lang},this.languages[lang]['Name']);
				if (lang == this.altLanguage) {
					opt.selected = true;
				}
				$('languageSelector').options.add(opt);
			}
		}

		$('languageSelector').observe('change',function(){
			that.changeMasterEditorLanguage();
		});
	},
	changeMasterEditorLanguage:function()
	{
		var newLanguage = $('languageSelector').getValue();
		var tempList = this.masterList;
		for (var id in tempList)
		{
			var selector = 'infoTextEditor_'+this.altLanguage+'_'+id;
			var textBox = $(selector);
			var text = textBox.getValue();
			this.masterList[id][this.altLanguage] = text;
			var newTextbox = QBuilder('textarea', {
						className:'infoTextAltEditor',
						id:'infoTextEditor_'+newLanguage+'_'+id,
						type:'textarea',
						name:id+'_'+newLanguage
					}, this.masterList[id][newLanguage] || '');
			Element.replace(textBox,newTextbox);
		}

		this.altLanguage = newLanguage;
	},
	save:function(infoId)
	{
		var formValues = {};
		if (infoId == '_master')
		{
			var tempList = this.masterList;
			for (var id in tempList)
			{
				if (Object.isArray(this.masterList[id]))
				{
					this.masterList[id] = {}; //fixes a weird bug
				}
				var selector = 'infoTextEditor_'+this.altLanguage+'_'+id;
				var text = $(selector).getValue();

				this.masterList[id][this.altLanguage] = text;
				var engSelector = 'infoTextEditor_EN_'+id;
				var engText = $(engSelector).getValue();
				this.masterList[id]['EN'] = engText;
			}
			formValues = this.masterList;
		}
		else
		{
			var infoText = {};
			for (var lang in this.languages)
			{
				infoText[lang] = $F($('infoTextEditor_'+lang));
			}
			infoText['targetURL'] = $F($('infoTextEditor_targetURL_'+infoId)) || "";

			formValues[infoId] = infoText;
		}

		var error = null;
		var that = this;
		new Ajax.Request(URLTools.getAjaxURL('EditHelpInfoTips'),{
			parameters:{
				FormValues:Object.toJSON(formValues)
			},
			onComplete:function(transport){
				var result = transport.responseText.evalJSON();
				if (result.Error || result.ErrorMessage)
				{
					error = "Error Saving Help Info Tips.";
					that.showErrorMessage(error);
				}
				else
				{
					Q_Window.closeWindow();
					//reload the valid info tips so that changes are reflected immediately
					//  without having to refresh the page.
					new Ajax.Request(URLTools.getAjaxURL('GetInfoTipsForPage'),{
						parameters:{
							IgnoreCache:true
						},
						onComplete:function(transport)
						{
							var tips = transport.responseText.evalJSON();
							Qualtrics.HelpInfoTips = tips;
						}
					});
				}
			}
		});
	},
	processMenuDef:function(text)
	{
		this.content = text.Value;
		this.targetURL = text.targetURL || '';
		return {
			domNode:'Qualtrics.Info.buildInfo',
			className:'InfoBox'
		};
	},
	buildInfo:function()
	{
		var text = this.content;
		var target = this.targetURL;
		var node = QBuilder('div',{className:'InfoContent'});
		//we need to use innerHTML to ensure that any html passed in gets rendered.
		node.innerHTML = text;

		//this is also enforced in the backend, but this just makes sure we don't even show the edit button
		if (Qualtrics.User.userType == 'UT_SERVERADMIN')
		{
			var editLink = QBuilder('div',{className:'EditInfoText'},[
				QBuilder('a',{href:'javascript:void(0);',clickcallback:'Qualtrics.Info.getInfoTipEditor'},'Edit')
			]);
			node.appendChild(editLink);
		}
		if(target !='' && target)
		{

			var helpButton = QBuilder('div',{className:'HelpButton'},[
				QBuilder('a',{className:'qbutton neutral', href:'javascript:void(0);', clickcallback:'Qualtrics.Info.showTargetURL('+target+')'}, getMessage('SiteWide','MoreInformation'))
			]);
			node.appendChild(QBuilder('hr'));
			node.appendChild(helpButton);
		}
		return QBuilder('div',{className:'HelpInfo'},[node]);
		//return node;
	},
	showErrorMessage:function(message)
	{
		new Q_Window('InfoTipEditor',{
			title:QBuilder('div', {}, 'Error'),
			content:QBuilder('div',{style:'color:red;font-weight:bold'},message),
			buttons:[
				{text:'Close', className:'negative', click:'Q_Window.closeWindow'}
			]
		});
	},

	/**
	 *Copied from 360 and put in to QMenu so all info buttons can use this
	 *Sets the enabled param in the users settings
	 */
	setHelpInfoEnabled:function(isEnabled)
	{
		var enabled = (isEnabled == 'true') ? 1 : 0; // 0 means it is enabled
		new Ajax.Request(URLTools.getAjaxURL('SetHelpInfoEnabled'),{
		parameters:{
			Enabled:enabled
		},
		onComplete:function()
		{
			//set enabled in Qualtrics.Info object
			Qualtrics.User.helpTipsEnabled = enabled;

			//info tips are not created or they are set to false
			if(!Qualtrics.HelpInfoTips || !Qualtrics.HelpInfoTips['_enabled'])
			{
				new Ajax.Request(URLTools.getAjaxURL('GetInfoTipsForPage'),{
					onComplete:function(transport)
					{
						Qualtrics.HelpInfoTips = transport.responseText.evalJSON();
						if(!Qualtrics.Info.activatedOverCalls && enabled )
						{
							Qualtrics.Event.activateOverCallbacks();
							Qualtrics.Info.activatedOverCalls = true;
						}

					}
				});
			}
		}
		});
	}
};








QMenu = {
	buildMenuButton:function(title, menuCallBack,options)
	{
		return Qualtrics.Menu.buildMenuButton(title, menuCallBack,options);
	},
	buildSelectMenuButton:function(initialValue, fieldName, options)
	{
		return Qualtrics.Menu.buildSelectMenuButton(initialValue, fieldName, options);
	},
	buildAjaxMenuButton:function(title, options)
	{

		var fieldName = options.fieldName;
		var buttonId = fieldName+'_Button';
		var opt_url = options.opt_url;
		var searchParam = null;

		if (options.searchParam)
			searchParam = options.searchParam;
		var menuOptions = {
			className:'SelectMenuButton',
			menuType:'SelectMenuPane',
			buttonId:buttonId,//this sets the button id to what we say instead of a default.
			fieldName:fieldName,
			searchParam:searchParam,
			url:opt_url,
			p1:fieldName,
			p2:buttonId, //this sends the buttonId to the click callback
			p3:'$options',//this passes on this full list of options to the buildAjaxMenu callback
			menuItemSelectCallback: options.menuItemSelectCallback || null
		};
		menuOptions.selectMenu = true;
		var button = QMenu.buildMenuButton(title,'QMenu.buildAjaxMenu', menuOptions);
		return button;
	},
	buildSelectMenu:function(fieldName, buttonId, options)
	{
		return Qualtrics.Menu.buildSelectMenu(fieldName, buttonId, options);
	},
	buildAjaxMenu:function(fieldName, buttonId, options)
	{
		var button = $(options.p2);
		var params = {};
		if(options.searchParam)
		{
			params[options.searchParam] = options.searchText;
		}
		var menuDef = {
			ajax:{
				url:options.url,
				parameters:params,
				preparser:'QMenu.parseOldAjaxList'
			}
		};
		return menuDef;
	},
	parseOldAjaxList:function(list)
	{
		list = list.evalJSON();
		var items = [];
		for(id in list['List'])
		{
			if(typeof list['List'][id] == 'function')
			{
				continue;
			}
			items.push({display:list['List'][id], value:id, icon:'false'});
		}
		return {items:items};
	},
	keepMenuOpen:function()
	{
		Qualtrics.Menu.keepMenuOpen();
	},
	showMenu:function(menuBuilder, clickedEl, options, opt_evt)
	{
		Qualtrics.Menu.showMenu(menuBuilder, clickedEl, options, opt_evt);
	},
	toggleCheck:function(li, options)
	{
		Qualtrics.Menu.toggleCheck(li, options);
	},
	/** Returns if a menu currently exists.
	 * @return {bool} true if there is a menu false if there isn't
	 */
	isMenuExists: function()
	{
		if ($('QMenu'))
			return true;
		else
			return false;
	},
	positionMenu:function()
	{
		Qualtrics.Menu.positionMenus();
	},
	mousedownHandler:Qualtrics.Menu.documentDownHandler,
	destroyMenu:Qualtrics.Menu.destroyAllMenus,
	/**
	* buildComboBoxMenu is deprecated, switch it out for a QComboBox
	*/
	buildComboBoxMenu:function(inputId, items)
	{
		console.warn('buildComboBoxMenu is deprecated');
		var menu = QBuilder('ul');
		menu.appendChild(QMenu.buildComboBoxMenuItems(inputId, items));
		return menu;
	},
	/**
	* buildComboBoxMenuItems is deprecated, switch it out for a QComboBox
	*/
	buildComboBoxMenuItems:function(inputId, items)
	{
		console.warn('buildComboBoxMenuItems is deprecated');
		var menu = document.createDocumentFragment();
		var values = Qualtrics.getArrayValues(items);
		if(values && values.length)
		{

			for(var i = 0, len=values.length; i<len; ++i)
			{
				menu.appendChild(QBuilder('li',{},[
					QBuilder('a',{className:'MenuItemLink', href:'javascript:void(0)', clickcallback:'QMenu.setComboBoxValue', p1:inputId, p2:values[i]},[
						values[i]
					])
				]));
			}
		}
		else
		{
			menu.appendChild(QBuilder('li',{style:'width:100px'},'\xa0'));//there is nothing so show an nbsp with 100px width
		}
		return menu;
	},
	/**
	* setComboBoxValue is deprecated,  switch it out for a QComboBox
	* you can define a comboboxupdatecallback that will run whenever a combobox is changed with the menu.
	*/
	setComboBoxValue:function(id, val)
	{
		console.warn('setComboBoxValue is deprecated');
		$(id).value = val;
		Qualtrics.Event.baseDistributerReader(null, $(id), 'comboboxupdatecallback');
	},
	hideMenuOnMouseOut:function()
	{
		Qualtrics.Menu.hideMenuOnMouseOut();
	},
	refreshMenu:function()
	{
		Qualtrics.Menu.refreshMenu();
		//TODO: make this work
	}
};


window.QPDFPrinter = {
	pageSizes:{
		Letter:{width:935, height: 1210},//935,1210
		Legal:{width:935, height:1541},
		A4:{width:910,height:1286}
	},
	pageSizeOffset:1,//take 1 px out of the width and the height of pages, and magically the pdf printing works. weird
	//the page margins will be taken from the size of the pages and given to padding
	pageMargin:25,
	enablePDF:true,
	//pulls all of the styles into one style tag
	getStylesheets:function()
	{
		var styleSheets = document.styleSheets;
		var ret = '<style>\n';
		for (var i=0; i<styleSheets.length; i++)
		{
			var href = styleSheets[i].href;
			var cssRules = styleSheets[i].cssRules;
			var path = '';
			if (href)
			{
				path = href.substr(0,href.lastIndexOf('/'));
				path = path.substr(0,path.lastIndexOf('/'));
			}
			for (var j=0;j<cssRules.length;j++)
			{
				var css = cssRules[j].cssText;
				if (css.indexOf('../') != -1)
				{
					css = css.replace('..',path);
				}
				ret+=css+'\n';
			}
		}
		ret +='</style>\n';

		return ret;
	},
	//returns link tags for all linked stylesheets and generates style tags for each inline stylesheet
	getStylesheetLinks:function(altWindow)
	{
		var ret = '';
		var doc = document;
		var win = window;
		if(altWindow)
		{
			win = altWindow;
			doc = win.document;
		}
		try {
			//if an error occurs, the worst case will be no css included. not ideal but it won't break ie
			var styleSheets = doc.styleSheets;

			var path = win.location.href;
			path = path.substr(0,path.lastIndexOf('/'));
			path = path.substr(0,path.lastIndexOf('/'));
			for (var i=0; i<styleSheets.length; i++)
			{
				var href = styleSheets[i].href;

				if (href)
				{
					//ie returns a relative path
					if (href.indexOf('../') != -1)
					{
						href = href.replace('..',path);
					}
					/* put this in to prevent caching of stylesheets (for debugging) */
					href += ((href.indexOf('?') != -1)?'&x=':'?=')+Math.random();
					ret += '<link rel="stylesheet" type="text/css" href="'+href+'" />\n';
				}
				else
				{
					//.rules for ie, .cssRules for all others
					var cssRules = styleSheets[i].cssRules || styleSheets[i].rules;
					ret += '<style>';
					for (var j=0;j<cssRules.length;j++)
					{
						var css = cssRules[j].cssText;
						if (css)
						{
							if (css.indexOf('../') != -1)
							{
								css = css.replace('..',path);
							}
							ret+=css+'\n';
						}
					}
					ret += '</style>';
				}
			}
		}
		catch(e)
		{
			console.error(e);
		}

		return ret;
	},
	showDialog:function(buttons, options)
	{
		if(Qualtrics.Browser.IE && Qualtrics.Browser.Version < 7)
		{
			alert('PDF creation is not currently supported in Internet Explorer 6. Please upgrade your browser.');
			return;
		}
		options = options || {};
		// Need some way of telling the pdf printer about my report layout options
		if (Qualtrics.pdfOptions)
		{
			Object.extend(options, Qualtrics.pdfOptions);
		}

		var filenameInput = QBuilder('div',{},[
			QBuilder('label',{},'File name'),
			QBuilder('input',{className:'TextBox',id: 'pdffilename',name:'pdffilename',value:options.filename})
		]);
		var poCheck = QBuilder('input',{type:'radio',id: 'pdforientationPortrait',name:'pdforientation'});
		var loCheck = QBuilder('input',{type:'radio',id: 'pdforientationLandscape',name:'pdforientation'});

		var popts = {
			'letter':QBuilder('option',{value:'Letter'},'Letter'),
			'legal':QBuilder('option',{value:'Legal'},'Legal'),
			'a4':QBuilder('option',{value:'A4'},'A4')
		};

		if(options.pageSize)
		{
			$(popts[options.pageSize]).writeAttribute('selected');
		}

		var pageSize = QBuilder('select',{id:'pdfPageSize', name:'pdfpageSize'},Object.values(popts));

		if (options.orientation == 'landscape')
		{
			loCheck.checked = true;
			loCheck.defaultChecked = true;
		}
		else
		{
			poCheck.checked = true;
			poCheck.defaultChecked = true;
		}
		var orientationInput = QBuilder('div',{id:'PDFOrientationInput'},[
			poCheck,
			QBuilder('label',{htmlFor:'pdforientationPortrait'},'Portrait'),
			loCheck,
			QBuilder('label',{htmlFor:'pdforientationLandscape'},'Landscape'),
			QBuilder('br'),
			QBuilder('label',{htmlFor:'pdfPageSize'},'Page Size'),
			pageSize

		]);
		//autoSize option:
		var autoSizeInput = '';

		if (!options.noResizeOption)
		{
			QBuilder('fieldSet',{},[
				QBuilder('input',{
					type:'checkbox',
					name:"AutoSizePDFToggle",
					id:"AutoSizePDFToggle",
					clickcallback:'QPDFPrinter.toggleAutoSize:'+this.id
				}),
				QBuilder('label',{htmlFor:"AutoSizePDFToggle"},"Do not resize content")
			]);
		}

		var panel = QBuilder('div',{className:'pdfExportOptions'},[
			filenameInput,
            autoSizeInput,
			orientationInput
		]);

		QPDFPrinter.options = options;
		var win = new Q_Window({
			id:'QPDFPrinter',
			width:'auto',
			height:'auto',
			title:options.title || 'PDF Export',
			zIndex:options.zIndex,
			buttons:buttons
		});
		win.setContent(panel);
	},
	printPDF:function(nodeList,options)
	{
		QPDFPrinter.nodeList = nodeList;
		var buttonText = options.exportButtonText ? options.exportButtonText : 'Export';
		var buttons = [
				{icon:'cancel', text:'Close', click:'QPDFPrinter.close', className:'negative'},
				{icon:'', text:buttonText, click:'QPDFPrinter.printFromDialog', className:'positive'},
				{icon:'', text:'Preview',id:'PDFPreviewButton', click:'QPDFPrinter.printPreview', className:'positive', align:"left"}

			];
		this.showDialog(buttons, options);
	},
    toggleAutoSize:function()
    {
        $('PDFPreviewButton').toggle();
        $('PDFOrientationInput').toggle();
        QPDFPrinter.options.noAutoSize = $('AutoSizePDFToggle').checked;
    },

	printPreview:function()
	{
		var win = new Q_Window({
			id:'QPDFPrinterPreview',
			width:'90%',
			height:'90%',
			title:'PDF Export',
			buttons:[
				{icon:'cancel', text:'Close', click:'Q_Window.closeWindow(QPDFPrinterPreview)', className:'negative'},
				{icon:'', text:'Export', click:'QPDFPrinter.printFromDialog', className:'positive'}
			]
		});

		this.buildPages(); //sets this.pages, this.pageWidth

		var previewPages = [];
		//we shouldn't shrink anything, or modify anything because we don't want to auto-paginate this baby
		if(QPDFPrinter.options.noAutoPage)
		{
			previewPages = this.pages;
		}
		else
		{
			for(var i=0,ilen = this.pages.length; i<ilen;i++)
			{
				var page = this.pages[i];

				//we only have to worry about the width bc the scale should be the same across the width and the height
				var width = parseInt($(page).getStyle('width'));
				if(width > this.pageWidth)
				{
					page = QBuilder('div',{},[page]);
					//console.log(this.pageWidth, width);
					var wScale = (this.pageWidth)/width;
					$(page).setStyle({
						'zoom':wScale,
						'MozTransform':'scale('+wScale+')',
						'MozTransformOrigin':'left top'
					});
				}

				var prevPage = QBuilder('div',{className:"PDFPreviewPage"},[page]);

				$(prevPage).setStyle({
					"width":(this.pageWidth+2*this.pageMargin)+"px",
					"height":(this.pageHeight+2*this.pageMargin)+"px"
				});

				previewPages.push(prevPage);
			}
		}

		var preview = QBuilder('div',{className:'PDFPreview'},previewPages);
		win.setContent(preview);

		//set the correct zoom. Note: we subtract 20 for the scrollbar and 20 for padding
		var zoom = ($('QPDFPrinterPreview').offsetWidth - 40) / (this.pageWidth + 2*this.pageMargin);
		if(zoom < 1)
		{
			var style = {
				'zoom':zoom,
				'MozTransform':'scale('+zoom+')',
				'MozTransformOrigin':'left top'
			};
			$(preview).setStyle(style);
		}
	},
	generateNodeInfo:function()
	{
		if (!(QPDFPrinter.nodeList instanceof Array))
		{
			QPDFPrinter.nodeList = new Array(QPDFPrinter.nodeList);
		}
		var nodeList = QPDFPrinter.nodeList;
		var nodeInfo = [];
		var max = {};
		var min = {};
		for (var i=0,ilen=nodeList.length;i<ilen;i++)
		{
			var node = nodeList[i];
			if (!node)
				continue;
			//console.log("node"+i,node);
			var dims = {'width':node.offsetWidth,'height':node.offsetHeight};
            if(dims.height == 0 || dims.width == 0)
            {
                QualtricsTools.addToHiddenHelper(node);
                dims = $(node).getDimensions();
                // remove the node so it doesn't have a parent
                node.parentNode.removeChild(node);
            }
			var count = 1;
		    var child = node.firstChild;
            var childWidth = $(child).getWidth();
			while(count < 3 && typeof child != 'undefined' && dims.width < childWidth)
			{
				dims.width = childWidth;
				count++;
				child = child.firstChild;
                childWidth = $(child).getWidth();
			}
			if (!max.width || max.width < dims.width)
			{
				max.width = dims.width;
			}
			if (!max.height || max.height < dims.height)
			{
				max.height = dims.height;
			}

			if (!min.width || min.width > dims.width)
			{
				min.width = dims.width;
			}
			if (!min.height || min.height > dims.height)
			{
				min.height = dims.height;
			}
			nodeInfo.push({size:dims, index:i});
		}
		this.nodeInfo = {
			max:max,
			min:min,
			info:nodeInfo
		};
		return this.nodeInfo.info;
	},
	buildPages:function()
	{
		this.pages = [];
		var options = QPDFPrinter.options;

		//This option tells us that we don't want to make default pages to display because it is already being done (like reports made in the RLE)
		if(options.noAutoPage)
		{
			this.pages = this.nodeList;
			return;
		}

		this.generateNodeInfo();

		//set the page sizes for all nodes here
		var pageSize = $('pdfPageSize').value || "Letter";
		var orientation = ($('pdforientationLandscape') && $('pdforientationLandscape').checked)?"Landscape":"Portrait";
		pageSize = this.pageSizes[pageSize];
		var pageMargin = this.pageMargin;

		this.pageWidth = ((orientation == "Landscape")?pageSize.height:pageSize.width)-2*pageMargin;
		this.pageHeight = ((orientation == "Landscape")?pageSize.width:pageSize.height)-2*pageMargin;

		var pageHeightDif = 0;

		var pageArray = [];//header];
		//Only scale whole pages, not elements
		var scale = 1;
        for (var i=0,ilen=this.nodeInfo.info.length;i<ilen;i++)
		{
            var newScale = scale;

			var nodeInfo = this.nodeInfo.info[i];
			var node = this.nodeList[nodeInfo.index];

			// let's clone the heck out of it so we don't attach it to a different dom
			if (node.parentNode)
			{
				node = node.cloneNode(true);
			}

			//get a new scale if the node is bigger than the current page with the current scale
			if(nodeInfo.size.width > this.pageWidth*scale || nodeInfo.size.height > this.pageHeight*scale)
			{
				newScale = this.getPageScale(this.pageWidth, this.pageHeight, nodeInfo.size.width, nodeInfo.size.height);
                //always take the larger of the two
                if(newScale < scale)
                    newScale = scale;
			}

			//if height is greater than the space we have left in a page, add the current page to the pages array, instantiate a new one, then add the item to that new page
			if(nodeInfo.size.height > this.pageHeight*newScale-pageHeightDif)
			{
				//add page to pages
				this.addPage(pageArray, scale);

				//set pageHeightDiff to pageHeigt
				pageHeightDif = 0;
				pageArray = [];//[header];

                //get the correct page scale again
                newScale = Math.max(this.getPageScale(this.pageWidth, this.pageHeight, nodeInfo.size.width, nodeInfo.size.height),1);
			}
			scale = newScale;
			//	add node to the current page
			pageArray.push(node);
			pageHeightDif += nodeInfo.size.height;
		}

		//add last current page to pages;
		this.addPage(pageArray, scale);

		QPDFPrinter.options.margin = 0;
		QPDFPrinter.options.baseCSS = "";
	},
	//given a page array, adds the new page to this.pages
	addPage:function(pageArray, scale)
	{
        var pageClass = QPDFPrinter.options.pageClass || "";
		var page = QBuilder('div',{className:'PDFPage '+pageClass},pageArray);
		$(page).setStyle({
			"width":(this.pageWidth*scale)+"px",
			"height":(this.pageHeight*scale)+"px",
			"margin":(this.pageMargin*scale)+"px "
				+(this.pageMargin*scale)+"px 0"
		});
		this.pages.push(page);
	},
	//Scales the page up to accomodate the node
	getPageScale:function(pageWidth, pageHeight, itemWidth, itemHeight)
	{
		//we should bump the width of the node up by 20 to fix scrollbar issues
		var widthScale = (itemWidth)/pageWidth;
		var heightScale = itemHeight/pageHeight;

		//we want the larger scale between width and height
		var scale = widthScale>heightScale?widthScale:heightScale;

		return scale;
	},
	printFromDialog:function()
	{
        var nodeList = this.nodeList;
        var options = QPDFPrinter.options;
        //if no auto size

		if (!options.noResizeOption)
		{
			if(options.noAutoSize)
			{
				//add the node info to the pdf options
				this.generateNodeInfo();
				options.nodeInfo = this.nodeInfo.info;
			}
			else
			{
				this.buildPages();
				nodeList = QPDFPrinter.pages;
			}
		}

		if ($('pdffilename') && $('pdffilename').value)
		{
			var filename = $('pdffilename').value;
			if (filename.indexOf('.pdf') == -1)
			{
				filename += '.pdf';
			}
			options.filename = filename;
		}
		if ($('pdforientationLandscape') && $('pdforientationLandscape').checked)
		{
			options.orientation = 'landscape';
		}
		if ($('pdforientationPortrait') && $('pdforientationPortrait').checked)
		{
			options.orientation = 'portrait';
		}
		if ($('pdfPageSize'))
		{
			options.size = $('pdfPageSize').value;
		}
		if (!options.ajaxAction && !options.skipAlert)
		{
			QualtricsCPTools.showTip('GenericDownload',{onComplete:function(){QPDFPrinter.print(nodeList,options);}});
		}
		else
		{
			QPDFPrinter.print(nodeList, options);
		}

		QPDFPrinter.close();
	},
	close:function()
	{
		Q_Window.closeWindow('QPDFPrinterPreview');
		Q_Window.closeWindow('QPDFPrinter');
	},
	getJSONHTML:function(nodeList, options)
	{
		options = options || {};

		var htmlArray = [];
		var css = '';
		var baseCSS = options.baseCSS || "overflow:hidden; float:left;";

		var path = window.location.href;
		path = path.substr(0,path.lastIndexOf('/'));
		path = path.substr(0,path.lastIndexOf('/')) + '/';

		if (typeof(options.includeCSS) != 'undefined' && options.includeCSS)
		{
			var altWindow = null;
			if(options.iframe)
			{
				altWindow = options.iframe.contentWindow;
			}
			css = this.getStylesheetLinks(altWindow);
		}

		if (options.customCSS)
		{
			css += '<style>'+options.customCSS+'</style>';
		}

		if (!(nodeList instanceof Array))
		{
			nodeList = new Array(nodeList);
		}

		for (var i=0,ilen=nodeList.length;i<ilen;i++)
		{
			var node = nodeList[i];

			// we can't just insert this node willy nilly! we need to clone it or we could be ruining a nice UI
			if (node.parentNode)
			{
				node = node.cloneNode(true);
			}

			var outer = QBuilder('div',{},[
				node
			]);

			var baseHTML = outer.innerHTML;
			if (baseHTML.indexOf('../') != -1)
			{
				baseHTML = baseHTML.replace(/\.\.\//g,path);
			}

			var html = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8" />' + css + '</head><body style="min-width:0; background:#fff;">';

			//I am giving a new ToPDF class so you can use it to manipulate styles when printing to css
			html += '<div style="'+baseCSS+'" class="ToPDF">'+baseHTML+'</div></body></html>';
			//This is a hack for now cause our pdf printer can't handle moz styles for some reason...
			html = html.replace(/-moz-use-text-color/g, '');

			htmlArray.push(html);
		}
		return Object.toJSON(htmlArray);
	},
	print:function(nodeList,options)
	{
		options = options || {};

		options.paginate = true; //always paginate now

		var jsonHTML = this.getJSONHTML(nodeList, options);

		var external = false;
		if (typeof(options.external) != 'undefined')
		{
			external = options.external;
		}


		if (this.canExportPDF(jsonHTML))
		{
			if (options.ajaxAction)
			{
				var ajaxUrl = (window.URLTools) ? URLTools.getAjaxURL(options.ajaxAction, null, options.queryParams) : '/Q/EditSection/Ajax/' + options.ajaxAction;
				new Ajax.Request(ajaxUrl, {
					parameters:{
						HTML:jsonHTML,
						Options:Object.toJSON(options)
					},
					onComplete:options.ajaxOnComplete
				});
			}
			else if(window.URLTools || window.PageAction)
			{
				delete options.iframe;
				// Default to generic 'GeneratePDF' if action is not passed in options
				var clientAction = options.clientAction || 'GeneratePDF';

				options.baseURL = document.baseURI;
				options = Object.toJSON(options);
				//CP

				if (window.URLTools)
				{
					URLTools.post(clientAction, jsonHTML, options, null, true, external, undefined, undefined, options.queryParams);
				}
				else
				{
					PageAction(clientAction,jsonHTML,options,null,true,external);
				}
			}
			else
			{
				//SE
				QPDFPrinter.postWith('PDF.php', {Section:jsonHTML, SubSection:Object.toJSON(options)});
			}
		}
		else
		{
			QualtricsCPTools.showAlertDialog({
				title: getMessage('ErrorCodes', 'ESRE01'),
				message: getMessage('ErrorCodes', 'ESRE04')
			});
		}
	},
	canExportPDF:function(jsonHTML)
	{
		return jsonHTML.length < 16000000;
	},
	/**
	 * post print will call a function on the backend that returns html that is turned to a pdf and returned
	 * @param action String the function called (should be in page section)
	 * @param parameters Object parameters passed to the server side function
	 * @param options Object the usual pdf options
	 */
	postPrintPDF:function(action, parameters, options)
	{
		QPDFPrinter.postAction = action;
		QPDFPrinter.postParameters = parameters;
		var buttonText = options.exportButtonText ? options.exportButtonText : 'Export';
		var buttons = [
				{icon:'cancel', text:'Close', click:'QPDFPrinter.close', className:'negative'},
				{icon:'', text:buttonText, click:'QPDFPrinter.postPrintFromDialog', className:'positive'},
				{icon:'', text:'Preview',id:'PDFPreviewButton', click:'QPDFPrinter.postPrintPreview', className:'positive', align:"left"}

			];
		this.showDialog(buttons, options);
	},
	postPrintPreview:function()
	{
		//This is not as smart as the other printPreview. Server side rendering means this will have a hard time determining heights on the nodes so the preview will probably be wrong.

		var action = QPDFPrinter.postAction;
		var parameters = QPDFPrinter.postParameters;

		var win = new Q_Window({
			id:'QPDFPrinterPreview',
			width:'90%',
			height:'90%',
			title:'PDF Export',
			buttons:[
				{icon:'cancel', text:'Close', click:'Q_Window.closeWindow(QPDFPrinterPreview)', className:'negative'},
				{icon:'', text:'Export', click:'QPDFPrinter.postPrintFromDialog', className:'positive'}
			]
		});

		var waiter = QBuilder('div',{},[QAjaxWaiter.showMediumRing()]);
		var panel = QBuilder('div',{}, [waiter]);
		$(panel).setStyle({zoom:1});
		$(waiter).setStyle({width:'800px'});
		var that = this;
		var ajaxUrl = (window.URLTools) ? URLTools.getAjaxURL(action) : '/Q/EditSection/Ajax/' + action;
		new Ajax.Request(ajaxUrl,
			{
				parameters:parameters,
				evalScripts:true,
				onComplete:function(transport)
				{
					try {
						var html = transport.responseText;
						that.nodeList = [];
						var htmlList = html.split("<!-- ~BREAK~ -->");
						for (var i=0;i<htmlList.length;i++)
						{
							if (!htmlList[i])
								continue;
							var node = QBuilder('div');
							node.innerHTML = htmlList[i];
							that.nodeList.push(node);
						}
						that.buildPages();
						QPDFPrinter.options.margin = 25;
						var previewPages = [];
						//we shouldn't shrink anything, or modify anything because we don't want to auto-paginate this baby
						if(QPDFPrinter.options.noAutoPage)
						{
							previewPages = that.pages;
						}
						else
						{
							for(var i=0,ilen = that.pages.length; i<ilen;i++)
							{
								var page = that.pages[i];

								//we only have to worry about the width bc the scale should be the same across the width and the height
								var width = parseInt($(page).getStyle('width'));
								if(width > that.pageWidth)
								{
									page = QBuilder('div',{},[page]);
									var wScale = (that.pageWidth)/width;
									$(page).setStyle({
										'zoom':wScale,
										'MozTransform':'scale('+wScale+')',
										'MozTransformOrigin':'left top'
									});
								}

								var prevPage = QBuilder('div',{className:"PDFPreviewPage"},[page]);

								$(prevPage).setStyle({
									"width":(that.pageWidth+2*that.pageMargin)+"px",
									"height":(that.pageHeight+2*that.pageMargin)+"px"
								});

								previewPages.push(prevPage);
							}
						}

						var preview = QBuilder('div',{className:'PDFPreview'},previewPages);
						win.setContent(preview);


					}
					catch(e){console.error(e);}
				}
			}
		);
		win.setContent(panel);

	},
	postPrintFromDialog:function()
	{
		var action = QPDFPrinter.postAction;
		var parameters = QPDFPrinter.postParameters;
        var options = QPDFPrinter.options;

		if ($('pdffilename') && $('pdffilename').value)
		{
			var filename = $('pdffilename').value;
			if (filename.indexOf('.pdf') == -1)
				filename += '.pdf';
			options.filename = filename;
		}
		if ($('pdforientationLandscape') && $('pdforientationLandscape').checked)
		{
			options.orientation = 'landscape';
		}
		if ($('pdforientationPortrait') && $('pdforientationPortrait').checked)
		{
			options.orientation = 'portrait';
		}
		if ($('pdfPageSize'))
		{
			options.size = $('pdfPageSize').value;
		}
		QPDFPrinter.postPrint(action, parameters, options);

		QPDFPrinter.close();
	},
	/**
	* This is so we can post data from the SurveyEngine
	*/
	postWith:function(to, p)
	{
		var myForm = document.createElement("form");
		myForm.method="post" ;
		myForm.action = to ;
		for (var k in p)
		{
			var myInput = document.createElement("textarea") ;
			myInput.setAttribute("name", k) ;
			myInput.value = p[k];
			myForm.appendChild(myInput) ;
		}
		document.body.appendChild(myForm) ;
		myForm.submit() ;
		document.body.removeChild(myForm) ;
	},
	postPrint:function(action, parameters, options)
	{
		var p = {};
		p.Parameters = Object.toJSON(parameters);
		p.Options = Object.toJSON(options);
		p.PostAction = action;
		this.postWith('?ClientAction=PrintPDF',p);
	}
};


var QXLSPrinter = {
	printXLS:function(html,options)
	{
		// Default to generic 'GenerateXLS' if action is not passed in options
		var clientAction = options.clientAction || 'GenerateXLS',
			jsonHTML = Object.toJSON(html);

		URLTools.post(clientAction,html,Object.toJSON(options),null,true,null,null,true,options.queryParams);
	},
	// doesn't json encode the html string
	printXLSFromHTML: function (html, options) {
		URLTools.post('GenerateXLSFromHTML',html,Object.toJSON(options),null,true,null,null,true,options.queryParams);
	}
};


QComboBox = {
	reg:{},
	cachedLists:{},
	destroyAll:function()
	{
		for (var id in QComboBox.reg)
		{
			QComboBox.destroy(id);
		}
	},
	destroy:function(id)
	{
		if(QComboBox.reg[id].inputObserver)
			QComboBox.reg[id].inputObserver.stop();
	},
	/**
	 * @param options Object
	 * list of parameters:
	 * inputId - the id of the resulting combobox input
	 * inputName - the name attribute of the resulting combobox input
	 * autoSearch - bool when set to true will search the list by typing in it
	 * cacheAjaxResults - bool when set to true ajaxed results are cached
	 * defaultValue - the default value in the combobox
	 * prompt - a default prompt automatically removed on entry
	 * selectedField - Can be set to an existing input that holds the selected value,
	 * 		if not specified, it will generate a hidden input to use
	 * inputBoxParameterName - for an ajax call, this is the parameter name of the input box in the Ajax callback
	 * onSelectCallBack - a callback that is run when a list item is selected
	 * precachedList - Obj a list to be used for the combobox dropdown,
	 * 		the key is the value that is assigned to the input on select and the value will be the value in the select box
	 */
	buildComboBoxButton:function(options)
	{
		options.p1 = '$options';
		options.direction = 'left';
		var p3 = '';
		if(options)
		{
			//we need to makes sure its a string
			if(typeof options != 'string')
			{
				p3 = Object.toJSON(options);
			}
		}
		var buttonId = (options && options.buttonId) || QualtricsCPTools.createNewId('BTN');
		//all these b tags have special borders that give the button little rounded edges.
		var button = QBuilder('button',{type:'button',id:buttonId, className:'ComboBoxButton',downcallback:'QMenu.showMenu',p1:'QComboBox.buildComboBoxList',p2:'$el', p3:p3},'V');
		return button;
	},
	replaceSelect:function(select,options)
	{
		select = $(select);
		var opts = select.options;
		var name = select.getAttribute('name');
		var id = select.getAttribute('id');
		var precache = {};
		var defaultValue = opts[0].value;
		var defaultText = opts[0].text;
		var autoComplete = true;
		if (options.autoComplete === false)
			autoComplete = false;
		for(var i=0,ilen=opts.length;i<ilen;i++)
		{
			var opt = opts[i];
			var value = opt.value; //opt.text || opt.value;//opt.getAttribute('value');
			var text = opt.text;
			precache[value] = text;
			if (opt.selected || (opt.hasAttribute && opt.hasAttribute('selected')))
			{
				defaultText = text;
				defaultValue = value;
			}
		}

		if (!this.list)
			this.list = {};
		this.list[name] = precache;
		var comboBoxOpts = {
				inputId:id+'Text',
				inputName:name+'Text',
				inputValueID:id,
				autoSearch:false,
				inputBoxParameterName:name,
				defaultValue:defaultValue,
				defaultText:defaultText,
				selectedField:'',
				onSelectCallBack:'',
				cacheAjaxResults:false,
				precachedList:precache,
				replaceSelect:true,
				autoComplete:autoComplete
			};
		if (typeof options == 'object')
			Object.extend(comboBoxOpts,options);
		var comboBox = QComboBox.buildComboBox(comboBoxOpts);
		var parent = select.parentNode;
		if (parent)
		{
			parent.appendChild(comboBox);
			//assume you want to remove the old select box
			Element.remove($(select));
		}
		return comboBox;
	},
	buildComboBox:function(options)
	{
		if (!options)
			options = {};
		var inputId = '';
		if (options.inputId)
			inputId = options.inputId;
		else
		{
			inputId = QualtricsCPTools.createNewId('CMB');
			options.inputId = inputId;
		}
		var inputName = '';
		if (options.inputName)
			inputName = options.inputName;
		else
			inputName = inputId;
		if (options.filterOnClick === null)
			options.filterOnClick = false;
		if (options.showButton == undefined)
			options.showButton = true;
		options.type = 'ComboBox';
		var autoclearClass = '';
		var inputClass = '';
		if (options.inputClass !== null)
			inputClass = ' ' + options.inputClass;
		var defaultValue = '';
		var defaultText = '';
		if (options.defaultValue)
			defaultValue = options.defaultValue;
		if (options.defaultText)
			defaultText = options.defaultText;
		if(options.prompt)
		{
			autoclearClass = ' AutoClearMessage';
			defaultText = options.prompt;
		}


		var inputField = QBuilder('input',{
			autocomplete:'off',
			className:'TextBox'+autoclearClass + inputClass,
			type:'text',
			id:inputId,
			name:inputName,
			value:defaultText
		});

		if(options.prompt)
		{
			inputField.setAttribute('autoclear', options.prompt);
		}
		var button = '';
		if(options.showButton)
			button = QComboBox.buildComboBoxButton(options);

		var comboBox = QBuilder('div',{className:'QComboBox'},[
			inputField,
			button
		]);
		QComboBox.reg[inputId] = {};
		if (options.autoSearch)
			QComboBox.reg[inputId].inputObserver = new Form.Element.Observer(inputField,1,QComboBox.showComboBoxList);
		if (options.autoComplete && options.precachedList)
		{
			inputField.setAttribute('qautocomplete','QComboBox.getCachedList('+options.inputBoxParameterName+')');
			QModules.loadModule('QAutoComplete.js');
			//new QAutoComplete(inputField,{list:options.precachedList});
		}

		QComboBox.reg[inputId].options = options;
		QComboBox.reg[inputId].button = button;
		QComboBox.reg[inputId].input = inputField;
		QComboBox.reg[inputId].showComboBox = true;

		if (options.selectedField)
		{
			if( !$(options.selectedField))
			{

				var input = QBuilder('input',{type:'hidden', id:options.selectedField, name:options.selectedField});
				if (defaultValue)
					input.value = defaultValue;
				comboBox.appendChild(input);
				QComboBox.reg[inputId].hiddenInput = input;
			}
			else
			{
				QComboBox.reg[inputId].hiddenInput = $(options.selectedField);
			}
		}
		if (options.replaceSelect)
		{
			var input = QBuilder('input',{type:'hidden', id:options.inputValueID, name:options.inputBoxParameterName});
			if (defaultValue)
				input.value = defaultValue;
			comboBox.appendChild(input);
			QComboBox.reg[inputId].hiddenInput = input;
			//Event.observe(inputField,'change',function(e){input.value = inputField.value});
		}
		if (options.emulateSelect)
		{
			Event.observe(inputField,'keypress',function(e){Event.stop(e)});
			inputField.addClassName('readonly');
			if (options.precachedList)
			{

				var firstID;
				var firstValue;
				for (var id in options.precachedList)
				{
					firstID = id;
					firstValue = options.precachedList[id];
					break;
				}
				QComboBox.reg[inputId].hiddenInput.value = firstID;
				inputField.value = firstValue;
			}
			inputField.setAttribute('clickcallback','QComboBox.showComboBoxListOnClick($evt)');

			//Event.observe(inputField,'click',this.showComboBoxListOnClick.bind(this))
		}
		else if (options.replaceSelect)
		{
			//Do not add this observer to emulateSelect
			new Form.Element.Observer(inputField,.2,function(el,value){input.value = value;});
		}

		if (options.onEnter)
		{
			Event.observe(inputField,'keypress',options.onEnter);
		}
		return comboBox;
	},
	clearCache:function()
	{
		this.cachedLists = {};
	},
	getCachedList:function(name)
	{
		return this.list[name];
	},
	getInstance:function(id)
	{
		if (QComboBox.reg[id])
			return QComboBox.reg[id];
		else
			return false;
	},
	insertSelectedValue:function(id,key,value)
	{
		var comboBox = QComboBox.getInstance(id);
		if (comboBox)
		{
			comboBox.showComboBox = false;
			if (comboBox.hiddenInput)
				comboBox.hiddenInput.value = key;
			if (comboBox.input)
			{
				$(comboBox.input).removeClassName('AutoClearMessage');
				comboBox.input.value = value;
				$(comboBox.input).addClassName('validated');
			}

			if (comboBox.options.onSelectCallBack)
			{
				var callback = comboBox.options.onSelectCallBack;
				callback();
			}
			setTimeout(function(){comboBox.showComboBox = true},1000);
		}
	},
	disable:function(id)
	{
		var comboBox = QComboBox.getInstance(id);
		comboBox.showComboBox = false;
	},
	enable:function(id)
	{
		var comboBox = QComboBox.getInstance(id);
		comboBox.showComboBox = true;
	},
	remove:function(id)
	{
		if ($('QMenu'))
			$('QMenu').remove();
	},
	showComboBoxListOnClick:function(e)
	{

		var el = Event.element(e);
		var val = '';
		if (el.tagName == 'INPUT')
			val = el.value;
		this.showComboBoxList(el,val);
	},
	showComboBoxList:function(el,value)
	{
		var comboBox = QComboBox.getInstance(el.id);
		if (comboBox)
		{
			if (comboBox.showComboBox)
			{
				var options = comboBox.options;
				var button = comboBox.button;

				/*
				if (comboBox.hiddenInput)
					comboBox.hiddenInput.value = '';
					* */
				if (comboBox.input)
				{
					comboBox.input.value = value;
					$(comboBox.input).removeClassName('validated');
				}
				options.filterOnClick = true;
				if (value != '')
					QMenu.showMenu('QComboBox.buildComboBoxList',button,Object.toJSON(options));
				else
				{
					QComboBox.remove(el.id);
				}
			}
		}

	},
	buildComboBoxList:function(options)
	{
		options = this.processOptions(options);
		var url = '';
		if (options.url)
			url = options.url;
		var params = {};
		if (options.params)
			params = options.params;
		var searchVal = '';
		if (options.autoSearch && options.filterOnClick && options.inputBoxParameterName)
		{
			searchVal = $F(options.inputId);
			params[options.inputBoxParameterName] = searchVal;
		}
		var menu = QBuilder('ul',{className:'ComboBox', id:options.inputId+'_menu'});
		//menu.appendChild(QBuilder('li',{className:'Loading'},getMessage('SiteWide','Loading')))
		menu.appendChild(QBuilder('li',{className:'Loading'},[
		]));
		var cacheAjaxResults = true;
		var useAjax = true;
		if (options.cacheAjaxResults !== undefined)
		{
			cacheAjaxResults = options.cacheAjaxResults;
		}
		if (searchVal != '')
		{
			cacheAjaxResults = false;
		}
		if (cacheAjaxResults && QComboBox.cachedLists[options.inputId])
		{
			useAjax = false;
		}
		if (options.precachedList)
		{
			useAjax = false;
			QComboBox.cachedLists[options.inputId] = options.precachedList;
		}
		var ajaxIndex = 'List';
		if (options.AjaxResultIndex)
			ajaxIndex = options.AjaxResultIndex;
		var noResults = true;
		if (useAjax)
		{

			new Ajax.Request(URLTools.getAjaxURL(options.ajaxAction, null, options.queryParams), {
				parameters:params,
				onComplete:function(transport)
				{

					deleteChildren(menu);
					try{
						var items = transport.responseText.evalJSON();
					}catch(e){

					}
					console.log('items', items);
					var list = items[ajaxIndex];
					if (cacheAjaxResults)
					{
						QComboBox.cachedLists[options.inputId] = list;
					}
					console.log('list', list);
					if(list && Object.values(list).length && !(list instanceof Array))
					{
						for(var id in list)
						{
							var listEntry = String(list[id]); // Cast to string to prevent error
							var regEx = new RegExp(searchVal, 'i');
							var match = listEntry.match(regEx);
							if (match)
							{
								noResults = false;
								var innerText =  listEntry.replace(regEx, "<span class='match'>"+match+"</span>");
								var inner = QBuilder('a',{className:'MenuItemLink',href:'javascript:void(0)',clickcallback:'QComboBox.insertSelectedValue',p1:options.inputId,p2:id,p3:list[id]});
								inner.innerHTML = innerText;
								menu.appendChild(QBuilder('li',{},[inner]));
							}
						}
					}
					if (noResults)
					{
						menu.appendChild(QBuilder('li',{className:'NoResults'},getMessage('SiteWide','NoResults')));//there is nothing so show an nbsp with 100px width
					}
					//since the ajax call might make the menu too big, we should resize to prevent clipping on the bottom
					QComboBox.resizeOnChange(menu);
				}
			});
		}
		else
		{
			deleteChildren(menu);

			var list = QComboBox.cachedLists[options.inputId];
			if(list && Object.values(list).length && !(list instanceof Array))
			{
				for(var id in list)
				{
					var listEntry = String(list[id]); // Cast to string to prevent error
					var regEx = new RegExp(searchVal, 'i');
					var match = listEntry.match(regEx);
					if (match)
					{
						noResults = false;
						var innerText =  listEntry.replace(regEx, "<span class='match'>"+match+"</span>");
						var inner = QBuilder('a',{className:'MenuItemLink',href:'javascript:void(0)',clickcallback:'QComboBox.insertSelectedValue',p1:options.inputId,p2:id,p3:list[id]});
						inner.innerHTML = innerText;
						menu.appendChild(QBuilder('li',{},[inner]));
					}
				}
			}
			if (noResults)
			{
				menu.appendChild(QBuilder('li',{className:'Loading'},getMessage('SiteWide','NoResults')));//there is nothing so show an nbsp with 100px width
			}
		}

		return QBuilder('div',{className:'OverflowWrapper'},[menu]);
	},
	resizeOnChange:function(menuDiv)
	{
		var viewHeight = getPageSize()[3];
		var viewBottom = scrollInfo[1]+viewHeight;
		var menuHeight = menuDiv.offsetHeight;
		var topPos = $(menuDiv).cumulativeOffset().top;
		var clippedY = topPos+menuHeight - (viewBottom-10);
		if(clippedY > 0) //Sub menus dont work when we clip the menu, rather than figure out why I will just disable clipping with submenus for now.
		{
			$(menuDiv).setStyle({height:menuHeight-clippedY+'px', overflowY:'scroll', width:(menuDiv.offsetWidth+20)+'px'});
		}
	},
	processOptions:function(options)
	{
		if (typeof options == 'string')
		{
			options = options.evalJSON();
		}
		return options;
	}
};







/* this is a new rewrite of the combobox to make them instantiated objects. not yet finished. */
/**
 *
 * @param {Object} options
 * 		inputId (optional) string
 * 		hiddenInputId (optional) string
 * 		inputName (optional) string
 * 		hiddenInputName (optional) string
 * 		buttonId (optional) string
 * 		defaultValue (optional) string
 * 		defaultText (optional) string
 * 		prompt (optional) string
 * 		onChange (optional) function
 * 		onHiddenInputChange (optional) function
 * 		onInputChange (optional) function
 * 		autoComplete (optional) bool
 * 		autoSearch (optional) bool
 * 		disableInput (optional) bool
 * 		className (optional) string
 * 		list
 * 			type
 * 				ajax
 * 				static
 * 			values (required for type static)
 * 			ajaxParameters (required for type ajax)
 * 			ajaxAction (required for type ajax)
 */
Qualtrics.ComboBox = Class.create({
	initialize:function(options)
	{
		this.id = QualtricsCPTools.createNewId('CMB');
		Qualtrics.ComboBox.reg[this.id] = this;

		options = options||{};

		//set the input id if not set
		if (!options.inputId)
			options.inputId = QualtricsCPTools.createNewId('CMB');
		//set the hidden input id if not set
		if (!options.hiddenInputId)
			options.hiddenInputId = QualtricsCPTools.createNewId('CMBHI');
		//set the input name if not set
		if (!options.inputName)
			options.inputName = QualtricsCPTools.createNewId('CMB');
		//set the hidden input name if not set
		if (!options.hiddenInputName)
			options.hiddenInputName = QualtricsCPTools.createNewId('CMB');
		//set the buttonId if not set
		if (!options.buttonId)
			options.buttonId = QualtricsCPTools.createNewId('CMB');

		this.options = options;
		var listOptions = {
			combobox:this,
			listType:'qAutoComplete'
		};
		if(options.filtered)
		{
			listOptions.filtered = options.filtered;
		}
		Object.extend(listOptions,this.options.list);
		if (options.list.type == 'static')
		{
			this.activelist = new Qualtrics.ComboBoxStaticList(listOptions);
		}
		else if (options.list.type == 'ajax')
		{
			this.activelist = new Qualtrics.ComboBoxAjaxList(listOptions);
		}
		else if(options.list.type == 'dynamicSectioned')
		{
			this.activelist = new Qualtrics.ComboBoxDynamicListSectioned(listOptions);
		}
		//gets its list from a callback function
		else if (options.list.type == 'dynamic')
		{
			this.activelist = new Qualtrics.ComboBoxDynamicList(listOptions);
		}
	},
	build:function()
	{
		this.input = this.buildInput();
		this.hiddenInput = this.buildHiddenInput();
		this.button = this.buildButton();
		if (this.options.disableInput)
		{
			//make a cover for the disabled input
			this.cover = QBuilder('div',{className:'cover',downcallback:'Qualtrics.ComboBox.showListOnButtonClick',instanceid:this.id});
			var that = this;
			(function(){Element.clonePosition(that.cover,that.input);}).defer();
		}
		else
		{
			this.cover = '';
		}

		var className = 'QComboBox';
		if (this.options.className)
			className += (' ' + this.options.className);
		var comboBox = QBuilder('div',{className:className},[
			this.input,
			this.button,
			this.hiddenInput,
			this.cover
		]);
		return comboBox;
	},
	buildInput:function()
	{
		var attrs = {
			autocomplete:'off',
			className:'TextBox',
			type:'text',
			id:this.options.inputId,
			name:this.options.inputName,
			instanceid:this.id,
			comboboxhiddeninput:this.options.hiddenInputId,
			keyupcallback:'Qualtrics.ComboBox.keyUpCallback:' + this.id + '($evt, $el, $val)'
		};
		
		if (this.options.autoComplete)
			attrs.qautocomplete = 'Qualtrics.ComboBox.getActiveList';
		if (this.options.inputClass)
			attrs.className += ' ' + this.options.inputClass;
		if(this.options.validation)
			attrs.validation = this.options.validation;
		if(this.options.charSet)
			attrs.charSet = this.options.charSet;

		if (this.options.keyentercallback)
			attrs.keyentercallback = this.options.keyentercallback;

		if (this.options.keydowncallback)
			attrs.keydowncallback = this.options.keydowncallback;

		var inputField = QBuilder('input',attrs);
		var text = '';

		if (this.options.defaultValue !== undefined)
		{
			if (this.options.skipValueLookup)
				text = this.options.defaultValue; //skipValueLookup implies name == value for every item
			else
				text = this.activelist.getValue(this.options.defaultValue);

			if (text === false)
			{
				var list = this.activelist;
				if(!this.options.skipValueLookup)
				{
					//if you do skipValueLookup then we are assuming that the key and the value are always the same
					//so we dont need to do an ajax request to look them up
					list.updateValue.bind(list).defer(this.options.defaultValue);
				}

				text = this.options.defaultValue;
			}
		}
		if (this.options.defaultText || this.options.defaultText == '')
		{
			//assume that if default Text was specified we want to use it no matter what
			text = this.options.defaultText;
		}
		//we will only show the prompt if there is no default or selected text
		if (text == '' && this.options.prompt)
		{
			$(inputField).addClassName('AutoClearMessage');
			inputField.setAttribute('autoclear', this.options.prompt);
			text = this.options.prompt;
		}
		inputField.value = text;
		if (this.options.disableInput)
		{
			Event.observe(inputField,'keypress',function(e){Event.stop(e)});
			Event.observe(inputField,'focus',function(e){
				//this might be bad, but won't select the text on a disabled input when tabbed to
				inputField.blur();
				Event.stop(e);
			});
		}

		return inputField;
	},
	buildHiddenInput:function()
	{
		var defaultValue = '';
		if (this.options.defaultValue)
			defaultValue = this.options.defaultValue;

		var input = QBuilder('input',{
			type:'hidden',
			id:this.options.hiddenInputId,
			name:this.options.hiddenInputName,
			value:defaultValue,
			comboboxinput:this.options.inputId
		});
		return input;
	},
	buildButton:function()
	{
		if (this.options.hasOwnProperty('showButton') && !this.options.showButton)
			return '';

		var button = QBuilder('button',{tabindex:'-1',type:'button',id:this.options.buttonId, className:'ComboBoxButton',preventdragscroll:true, downcallback:'Qualtrics.ComboBox.showListOnButtonClick:'+this.id+'($evt)'},[
			QBuilder('span')
		]);

		return button;
	},
	showListOnButtonClick:function(evt)
	{
		evt = evt || window.evt;
		Event.stop(evt);
		if (this.menupane && this.menupane.menuDom)
		{
			//menu pane is visible, hide it
			this.hideList();
		}
		else
		{
			this.showList();
		}
	},
	hideList:function()
	{
		if (this.menupane && this.menupane.menuDom)
			this.menupane.destroy();
	},
	showList:function()
	{
		var params = this.activelist.getMenuParameters();

		var options =
		{
			className: 'ComboBoxMenuPane',
			input: this.input,
			escapeCallback:'Qualtrics.ComboBox.focusInput:' + this.id
		};
		this.menupane = new Qualtrics.ComboBoxMenuPane(params, this.button, null, options);
	},
	focusInput:function()
	{
		this.input && this.input.focus();
	},
	searchList:function()
	{

	},
	getActiveList:function()
	{
		return this.activelist.getList();
	},
	getText:function()
	{
		var v = this.input.value;
		if(v == this.input.getAttribute('autoclear'))
			return '';
		return this.input.value;
	},
	getValue:function()
	{
		return this.hiddenInput.value;
	},
	keyUpCallback:function(evt, el, val)
	{
		this.inputChange(el, val);
		
		if (this.options.keyupcallback)
			Qualtrics.Event.execute(this.options.keyupcallback,[evt, el, val]);
	},
	inputChange:function(el, value)
	{
		var key = this.activelist.getKey(value);
		if (key === false)
		{
			var list = this.activelist;
			list.updateValue.bind(list).defer(key);
			key = value;
		}
		//if updateKeyOnSelect is enabled, it allows changing the name, but not updating the ID. So if you select something
		//From the list, it will change the item you are editing, but if you change the text, it will overwrite only the name
		if (!this.options.updateKeyOnSelect)
		{
			this.setHiddenInput(key);
		}

		if (this.options.onChange)
			Qualtrics.Event.execute(this.options.onChange, [this.hiddenInput.value,this.input.value]);
	},
	setInput:function(val)
	{
		if (this.input.value != val)
		{
			this.input.value = val;
			
			//this was always being called from the observer whenever the input was set, so we will continue to run it now we are using a keyUpHandler for that
			this.inputChange(null, val);
			
			if (this.options.onInputChange)
				this.options.onInputChange(this.input);
		}
	},
	setHiddenInput:function(val)
	{
		if (this.hiddenInput.value != val)
		{
			this.hiddenInput.value = val;
			if (this.options.onHiddenInputChange)
				this.options.onHiddenInputChange(this.hiddenInput);
		}
	},
	selectItem:function(value,text, evt)
	{
		$(this.input).removeClassName('AutoClearMessage');
		this.setInput(text);
		this.setHiddenInput(value);
		if (this.options.onSelect)
		{
			this.options.onSelect(value,text, evt);
		}
	}
});


Qualtrics.ComboBox.reg = {};
Qualtrics.ComboBox.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.ComboBox.reg);

Qualtrics.ComboBox.replaceSelect = function(select,options)
{
	select = $(select);

	var name = select.getAttribute('name');
	var id = select.getAttribute('id');
	var opts = select.options;
	var precache = {};
	if (opts.length)
	{
		var defaultValue = opts[0].value;
		var defaultText = opts[0].text;
		for(var i=0,ilen=opts.length;i<ilen;i++)
		{
			var opt = opts[i];
			var value = opt.value; //opt.text || opt.value;//opt.getAttribute('value');
			var text = opt.text;
			precache[value] = text;
			if (opt.selected || (opt.hasAttribute && opt.hasAttribute('selected')))
			{
				defaultValue = value;
			}
		}
	}
	var defaultOptions = {
		inputId:id,
		hiddenInputName:name,
		defaultValue:defaultValue,
		autoSearch:false,
		autoComplete:false,
		disableInput:true,
		list:{
			type:'static',
			values:precache
		}
	};
	defaultOptions = Object.extend(defaultOptions,options);
	var comboBox = new Qualtrics.ComboBox(defaultOptions);
	var parent = select.parentNode;
	if (parent)
	{
		parent.appendChild(comboBox.build());
		//assume you want to remove the old select box
		Element.remove($(select));
	}
	return comboBox;
};
Qualtrics.DataList = Class.create({
	initialize:function(options)
	{
		this.options = options||{};
		this.list = {};
		this.id = QualtricsCPTools.createNewId('DL');
		Qualtrics.DataList.reg[this.id] = this;
	},
	setList:function(list)
	{
		//make sure we have an object
		if (Object.isArray(list))
		{
			var temp = {};
			for (var i=0,ilen=list.length;i<ilen;i++)
			{
				temp[i]=list[i];
			}
			list = temp;
		}
		this.list = list;

	},
	getKey:function(val)
	{
		var list = this.getList();
		for (var id in list)
		{
			if (list[id] == val)
				return id;
		}
		return false;
	},
	getValue:function(key)
	{
		var list = this.getList();
		if (list[key])
			return list[key];
		else
			return false;
	},
	getList:function()
	{
		return this.list || {};
	}
});
Qualtrics.DataList.reg = {};
Qualtrics.DataList.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.DataList.reg);
Qualtrics.ComboBoxList = Class.create(Qualtrics.DataList,{
	initialize:function($super,options)
	{
		$super(options);
	},
	setList:function(list)
	{
		//make sure we have an object
		if (Object.isArray(list))
		{
			var temp = {};
			for (var i=0,ilen=list.length;i<ilen;i++)
			{
				temp[i]=list[i];
			}
			list = temp;
		}
		this.list = list;
		try
		{
			//if the combobox has autocomplete, set the autocomplete list too.
			if (this.options.combobox.input && this.options.listType && this.options.combobox.input[this.options.listType])
			{
				this.options.combobox.input[this.options.listType].setList(list);
			}
		}
		catch(e)
		{
			console.error('error updating autocomplete list: '+e);
		}
	},
	getMenuParameters:function()
	{
		var params = this.buildParameters();
		return params;
	},
	updateValue:function(key)
	{
		var list = this.getList();
		if (list[key])
		{
			var comboBox = this.options.combobox;
			comboBox.setInput(this.list[key]);
			comboBox.setHiddenInput(key);
		}
	},
	buildParameters:function()
	{
		var params = {};
		var items = [];
		var list = this.getList(true);
		if (list)
		{
			for (var id in list)
			{
				if(list.hasOwnProperty(id))
				{
					items.push(
					{
						display: list[id],
						value: id,
						action: 'Qualtrics.ComboBox.selectItem',
						parameters:
						{
							instanceid: this.options.combobox.id,
							p1: id,
							p2: list[id],
							p3: '$evt'
						},
						icon: false
					});
				}
			}
		}
		params.items = items;
		if(this.options && this.options.combobox && this.options.combobox.options && this.options.combobox.options.search !== undefined)
		{
			params.search = this.options.combobox.options.search;
		}
		return params;
	}
});
Qualtrics.ComboBoxStaticList = Class.create(Qualtrics.ComboBoxList,{
	initialize:function($super,options)
	{
		$super(options);
		if (options.values)
		{
			this.setList(options.values);
		}
		else
		{
			console.warn('No list values were assigned to the combobox.');
		}
	}
});
Qualtrics.ComboBoxDynamicList = Class.create(Qualtrics.ComboBoxList,{
	getList:function()
	{
		var c = this.options.combobox;
		var search = c.options.autoComplete && c.input.realValue || c.inputvalue;
		return this.options.listCallback && Qualtrics.Event.execute(this.options.listCallback, [search]) || {};
	}
});
Qualtrics.ComboBoxDynamicListSectioned = Class.create(Qualtrics.ComboBoxDynamicList,{
	buildParameters:function($super)
	{
		//no parse function no dice
		if(!this.options.parseFunction)
			return $super();
		var params = {};
		var items = [];
		var list = this.getList();
		var subFolders = {};

		if (list)
		{
			for (var id in list)
			{
				var sectionName = this.options.parseFunction(id, list);

				if(!subFolders[sectionName])
				{
					subFolders[sectionName] = {};
				}

				if(list.hasOwnProperty(id))
				{
					subFolders[sectionName][list[id]] = {
						display: list[id],
						value: id,
						action: 'Qualtrics.ComboBox.selectItem',
						parameters:
						{
							instanceid: this.options.combobox.id,
							p1: id,
							p2: list[id],
							p3: '$evt'
						},
						icon: false
					};
				}
			}

			for(var folder in subFolders)
			{
				var folderObj = subFolders[folder];
				//push folder
				items.push({
					display: folder,
					value: 'Folder|' + folder,
					className:'Disabled',
					parameters:
					{
						instanceid: this.options.combobox.id
					},
					icon: false
				});
				//push objs in section
				for(var item in subFolders[folder])
				{
					items.push(subFolders[folder][item]);
				}
			}
		}
		params.items = items;
		return params;
	}
});
Qualtrics.ComboBoxAjaxList = Class.create(Qualtrics.ComboBoxList,{
	initialize:function($super,options)
	{
		$super(options);
		if (options.values)
		{
			this.setList(options.values);
		}
	},
	parseAjaxList:function(transport)
	{
		try
		{
			var list = transport.evalJSON();
			if (list.List && typeof list.List != 'string')
			{
				this.setList(list.List);
			}
			else
			{
				this.setList(list);
			}
		}
		catch(e)
		{
			//something went wrong just assume an empty list
			console.warn("Invalid combobox list results", transport);
			this.setList({});
		}
		var params = this.buildParameters();

		return params;
	},
	updateValue:function(key)
	{
		var that = this;
		this.updateList({
			onAjaxComplete:function()
			{
				if (that.list[key])
				{
					var comboBox = that.options.combobox;
					comboBox.setInput(that.list[key]);
					comboBox.setHiddenInput(key);
				}
				if(that.options.combobox.options.autoSuggest)
				{
					that.options.combobox.showList();
				}
			}
		});
	},
	getList:function(opt_refresh)
	{
		if (!opt_refresh)
			this.updateList();
		return this.list;
	},
	updateList:function(options)
	{
		if(this.ajaxDelay)
		{
			clearTimeout(this.ajaxDelay);
		}
		var that = this;
		var delay = 20;
		if (this.options && this.options.delay)
		{
			delay = this.options.delay;
		}

		this.ajaxDelay = setTimeout(function(){
			options = options || {};
			//the menu hasn't made the ajax call yet, let's do it ourselves
			var ajaxParameters = that.getAjaxParameters();

			new Ajax.CachedRequest(URLTools.getAjaxURL(that.options.ajaxAction, null, that.options.queryParams),{
				parameters:ajaxParameters,
				onComplete:function(transport)
				{
					var response = transport.responseText;
					that.parseAjaxList(response);

					if (options.onAjaxComplete)
						options.onAjaxComplete();
				}
			});
		}, delay);
	},
	getAjaxParameters:function(options)
	{
		options = options || {};
		var comboBox = this.options.combobox;
		var defaultAjaxParameters = {};

		if (this.options.filtered)
			defaultAjaxParameters[comboBox.options.inputName] = comboBox.getText();
		var params = {};
		if (typeof this.options.ajaxParameters == 'function' || typeof this.options.ajaxParameters == 'string')
		{
			params = Qualtrics.Event.execute(this.options.ajaxParameters, [comboBox.getText()]);
		}
		else
		{
			params = this.options.ajaxParameters;
		}
		var ajaxParameters = Object.extend(defaultAjaxParameters,params);
		return ajaxParameters;
	},
	getMenuParameters:function()
	{

		var ajaxParameters = this.getAjaxParameters();
		var params = {};
		params.ajax = {
			action:this.options.ajaxAction,
			parameters:ajaxParameters,
			preparser:QualtricsCPTools.buildDotSyntaxString('Qualtrics.ComboBoxAjaxList.parseAjaxList',null,this.id)
		};

		return params;
	}
});
Qualtrics.ComboBoxAjaxList.getInstance = QualtricsCPTools.getInstanceHelper(Qualtrics.DataList.reg);
Qualtrics.ComboBoxMenuPane = Class.create(Qualtrics.MenuPane,{
	initialize: function($super, menuBuilder, parentButton, opt_parentMenu, options)
	{
		$super(menuBuilder, parentButton, opt_parentMenu, options);
	},
	positionMenu:function()
	{
		var input = this.options.input;
		var inputPos = $(input).cumulativeOffset();
		var inputScrollOffset = $(input).cumulativeScrollOffset();
		var comboboxWidth = input.offsetWidth+this.buttonInfo.width-3;
		if (comboboxWidth > this.menuDom.offsetWidth)
		{
			$(this.menuDom).setStyle({
				width:comboboxWidth+'px'
			});
		}
		//position a root menu
		var menuWidth = this.menuDom.offsetWidth;
		var menuScrollOffset = $(this.menuDom).cumulativeScrollOffset();
		var topPos = inputPos.top+input.offsetHeight-(inputScrollOffset.top - menuScrollOffset.top);

		var leftPos = inputPos.left+1;
		$(this.menuDom).setStyle({top:topPos+'px', left:leftPos+'px'});


		this.adjustMenu({topPos:topPos,leftPos:leftPos});

	},
	adjustMenu:function(options)
	{
		var topPos = options.topPos||0;
		//see if we need scroll bars
		var viewHeight = getPageSize()[3];

		var viewBottom = scrollInfo[1]+viewHeight;
		var menuHeight = this.menuDom.offsetHeight;
		var clippedY = topPos+menuHeight-(viewBottom-10);
		if(clippedY > 0)
		{

			$(this.menuDom).setStyle({height:menuHeight-clippedY+'px', overflowY:'scroll', width:(this.menuDom.offsetWidth)+'px'});
		}
	}
});



/** QualtricsSETools.js
 Contains the javascript specific to the survey engine.
 */

/**
 * Qualtrics.SurveyEngine
 *
 */
Qualtrics.SurveyEngine = {
	/**
	 * @property {Object} registry
	 * @private
	 */
	registry: {},
	/**
	 * @method getInstance
	 * @param {string} id
	 * @private
	 */
	getInstance:function(id)
	{
		return this.registry[id];
	},
	/**
	 * @method addOnload
	 *	@param {function} f - the function to execute on load
	 *
	 */
	addOnload: function(f)
	{
		if ($('body') && $('body').hasClassName('EditSection'))
			return;
		try
		{
			var obj = new Qualtrics.SurveyEngine.QuestionData();
			obj.onload = f;
			Event.observe(window, 'load', obj.onload.bind(obj));
		}
		catch(e)
		{
			console.error('SE API Error: ' + e);
		}
	},
	/**
	 * @method addOnReady
	 *	@param {function} f - the function to execute when page is loaded and ready
	 *
	 */
	addOnReady: function(f)
	{
		if ($('body') && $('body').hasClassName('EditSection'))
			return;
		try
		{
			var obj = new Qualtrics.SurveyEngine.QuestionData();
			obj.onload = f;
			Event.observe(window, 'load',  function() {
				setTimeout(obj.onload.bind(obj), 0);
			});
		}
		catch(e)
		{
			console.error('SE API Error: ' + e);
		}
	},
	/**
	 * @method addOnUnload
	 *	@param {function} f - the function to execute when page is unloaded
	 *
	 */
	addOnUnload: function(f)
	{
		if ($('body') && $('body').hasClassName('EditSection'))
			return;
		try
		{
			var obj = new Qualtrics.SurveyEngine.QuestionData();
			obj.onload = f;
			Event.observe(window, 'unload', obj.onload.bind(obj));
		}
		catch(e)
		{
			console.error('SE API Error: ' + e);
		}
	},
	/**
	 * Changes the Skin of the Survey to one that is Accessible
	 * @method setAccessibleSkin
	 * @private
	 */
	setAccessibleSkin: function()
	{
		this.addEmbeddedData('ED~Q_Skin','Qualtrics|MQ|Accessible');
		window.noSEAutoSave = true;
		submitForm('Page');

	},
	/**
	 * Adds embedded data to the page
	 * @method addEmbeddedData
	 * @param {string} key - the embedded data key
	 * @param {string} value - the value of the embedded data
	 */
	addEmbeddedData: function(key, value)
	{
		$('Page').appendChild(QBuilder('input',{type:'hidden',name:key,value:value}));
	},
	/**
	 * Sets embedded data to the page, or adds it if the ED key is not on the page already
	 * @method setEmbeddedData
	 * @param {string} key - the embedded data key
	 * @param {string} value - the new value of the embedded data
	 */
	setEmbeddedData:function(key, value)
	{
		var fieldName = 'ED~'+key;
		if($(fieldName))
		{
			$(fieldName).value = value;
		}
		else
		{
			$('Header').appendChild(QBuilder('input',{type:'hidden',id:fieldName, name:fieldName, value:value}));
		}
	},
	/**
	 * Gets embedded data from the page
	 * @param {string} key - the embedded data key
	 * @return {string} value - the value of the embedded data or null if not found.
	 */
	getEmbeddedData:function(key)
	{
		var fieldName = 'ED~'+key;
		if($(fieldName))
		{
			return $(fieldName).value;
		}
	},
	/**
	 * The top level keydown event handler
	 * @method globalKeyDownHandler
	 * @private
	 */
	globalKeyDownHandler: function(evt)
	{
		if (document.body.id == 'SurveyEngineBody')
		{
			if(!evt){evt = window.event}
			var el = Event.element(evt);
			if(el && el.getAttribute)
				Qualtrics.alphaNumericValidation(el, evt);

			var isButton = el.tagName == 'BUTTON' || (el.tagName == 'INPUT' && el.type == 'button') || (el.id == 'NextButton' || el.id == 'PreviousButton');
			if (evt.keyCode == Event.KEY_RETURN && el.tagName != 'TEXTAREA' && !isButton)
			{
				//we aren't in a textrea or a button so stop the enter
				Event.stop(evt);
			}
		}
	},
	/**
	 * The top level keyup event handler
	 * @method globalKeyUpHandler
	 * @private
	 */
	globalKeyUpHandler: function(evt)
	{
		if(!evt){evt = window.event}
		var el = Event.element(evt);
		if(el.getAttribute('validation'))
		{
			//make sure nothing snuck in (we allow symbols behind the number keys because of french keyboard layouts)
			Qualtrics.alphaNumbericInputFilter(evt, el);
		}
	},
	/**
	 *	Displays an error message
	 *	@method displayErrorMessage
	 *	@param {string} msg - the message to be displayed
	 */
	displayErrorMessage:function(msg){
		alert(msg);
	},

	/**
	* Qualtrics.SurveyEngine.navEnter
	* This is responsible for submitting the form which advances them through the survey. This only should be called onkeypress for the nav buttons.
	* It simply checks that the key was enter then calls Qualtrics.SurveyEngine.navClick
	* @method navEnter
	* @param {event} e
	* @param {HTMLElement} el
	* @param {string} [opt_buttonName]
	* @param {boolean} [opt_confirmValidation] - this is true if they have seen the validation message and wish to continue without answering
	* @param {integer} [jumpIndex]
  * @private
	*/
	navEnter:function(e, el, opt_buttonName, opt_confirmValidation, jumpIndex)
	{
		e = e || window.event;
		//check for enter or space bar
		if (e.keyCode == Event.KEY_RETURN || e.charCode == 32)
		{
			Qualtrics.SurveyEngine.navClick(el, opt_buttonName, opt_confirmValidation, jumpIndex);
		}

	},
	/**
	* Qualtrics.SurveyEngine.navClick
	* This is responsible for submitting the form which advances them through the survey
	* @method navClick
	* @param {HTMLElement} el
	* @param {string} [opt_buttonName]
	* @param {boolean} [opt_confirmValidation] - this is true if they have seen the validation message and wish to continue without answering
	* @param {integer} [jumpIndex]
  * @private
	*/
	navClick:function(el, opt_buttonName, opt_confirmValidation, jumpIndex)
	{
		var setSubmitting = function (opt_buttonName, value) {
			if (opt_buttonName && $(opt_buttonName)) {
				$(opt_buttonName).setAttribute('submitting', value.toString());
			}
		};

		var event = null;
		if(el && !el.nodeName) //FF may complain about nodeName being deprecated, ignore it please
		{
			//it must be an event
			event = el;
			el = Event.element(el);
		}
		//we need to simulate this third param for when they want to continue through soft validation without answering
		if(el && el.getAttribute && el.getAttribute('confirmed'))
		{
			opt_confirmValidation = true;
		}
		if(opt_buttonName == 'NextButton' || opt_buttonName == 'PreviousButton' || opt_buttonName == 'JumpButton')
		{
			window.noSEAutoSave = true;
		}
		if(opt_buttonName == 'NextButton' && Qualtrics.SurveyPage && Qualtrics.SurveyPage.getInstance())
		{

			var surveyPage = Qualtrics.SurveyPage.getInstance();
			var info = surveyPage.getValidationInfo();
			if (info.frontEndValidation && info.valid == false)
			{
				//we have front end validation so run the validate function which will highlight any invalid questions
				//and pop up a q_window.
				if(!opt_confirmValidation && !Qualtrics.SurveyPage.getInstance().validatePage())
				{
					if(event)
					{
						//we have an event so we can prevent the page from submitting.
						Event.stop(event);
					}
					setSubmitting(opt_buttonName, false);
					return false;
				}
			}
			//Legacy support
			//check for overridden validation
			if (Qualtrics.SurveyPage.getInstance().validate)
			{
				if(!opt_confirmValidation && !Qualtrics.SurveyPage.getInstance().validate())
				{
					if(event)
					{
						//we have an event so we can prevent the page from submitting.
						Event.stop(event);
					}
					setSubmitting(opt_buttonName, false);
					return false;
				}
			}
		}
		// confirms previous navigation in ToC
		if (opt_buttonName == 'PreviousButton' && Qualtrics.ToC && !$$('.END_OF_SURVEY').length)
		{
			// we don't need to confirm again if we've already asked.
			if (window.Q_Window && !Q_Window.getInstance('ConfirmBackButton'))
			{
				Qualtrics.SurveyPage.getInstance().confirmBackButton();
				if(event)
				{
					//we have an event so we can prevent the page from submitting.
					Event.stop(event);
				}
				setSubmitting(opt_buttonName, false);
				return false;
			}
		}
		if(opt_buttonName == 'JumpButton')
		{
			if(jumpIndex)
			{
				$('JumpIndex').value = jumpIndex;
			}
			else if($('JumpIndex').value == '')
				$('JumpIndex').value = -1;
		}
		if(opt_buttonName && $('buttonPressed'))
		{
			//fancy buttons
			$('buttonPressed').name=opt_buttonName;
			$('submitPageFeauBTN').click();
		}
		else if(opt_buttonName && $(opt_buttonName))
		{
			//regular submit buttons
			if ($(opt_buttonName).getAttribute('submitting') != 'true') {
				$(opt_buttonName).setAttribute('confirmed', true);
				setSubmitting(opt_buttonName, true);
				$(opt_buttonName).click();
			}
		}
		try{

			if(el)
			{
				(function(){el.disabled=true;}).defer();
				(function(){
					el.disabled=false;
					setSubmitting(opt_buttonName, false);
				}).delay(10);
			}
		}catch(e)
		{
		}
	},
	restartResponse:function()
	{
		window.noSEAutoSave = true; // Turns off the autoSave
		$('Page').appendChild(QBuilder('input',{hidden:'true', value:'true', name:'RestartResponse'}));
		submitForm('Page');
	}
};


/* Question API (QuestionAPI) Implementation */
/**
 * @class Qualtrics JavaScript Question API
 */
/**
 * An object containing all the questions on the page. Each question is indexd by its questionID
 *
 * @example
 *	{
 *		QuestionID: (string) The question id
 *		QuestionText: (string) The question text
 *		QuestionType: (string) The question type code
 *		Choices: (object) Key is the choice id, value is information about the choice
 *		{
 *			RecodeValue: (string)
 *			VariableName: (string)
 *			Text: (string)
 *			Exclusive: (boolean)
 *		}
 *	}
 * @property {object} Qualtrics.SurveyEngine.QuestionInfo
 */
Qualtrics.SurveyEngine.QuestionInfo = {};

/**
 * The <t>Qualtrics Question API</t> allows users to interact with a question in a survey using JavaScript. Note that
 * interaction with questions is not limited to the functions available in the API. The API simply abstracts the most
 * used functionality to a set of methods called on the question object.
 *
 * All functions using the API <b>must</b> be wrapped in a <code>Qualtrics.SurveyEngine.addOnload</code> function.
 * The <code>addOnload</code> function automatically instantiates the Question Data class and binds the
 * instantiated object to allow its functions and properties to be accessed using the <em>this</em> keyword directly.
 *
 * @class Qualtrics JavaScript Question API
 * @example
 *	<script>
 *	//create Qualtrics.SurveyEngine.QuestionData object
 *	Qualtrics.SurveyEngine.addOnload(function ()
 *	{
 *		//disables the next button on the page
 *		this.disableNextButton();
 *
 *		//question click is a simple onclick handler
 *		//attached to the question's container div
 *		this.questionclick = function(event,element)
 *		{
 *			//by default you get the click event as the first parameter and the clicked element as the second parameter
 *			console.log(event, element);
 *			if (element.type == 'radio')
 *			{
 *				var choiceNum = element.id.split('~')[2];
 *				alert('You clicked on choice '+choiceNum);
 *				if (choiceNum == 2)
 *				{
 *					//enables the next button - Note that the QuestionData object is bound to this to make it easier to use
 *					this.enableNextButton();
 *				}
 *				else
 *				{
 *					//disables the next button
 *					this.disableNextButton();
 *				}
 *			}
 *		}
 *	});
 *	</script>
 *
 * <p>
 * Below is a list of predefined functions and properties that can be used on the <code><b>Qualtrics.SurveyEngine.QuestionData</b></code> class.
 * Note that the <code><b>addOnload</b></code> function on the <code><b>Qualtrics.SurveyEngine</b></code> object automatically instantiates the
 * <code><b>QuestionData</b></code> class and binds the instantiated object to allow these functions to be called using this directly.
 * </p>
 */
Qualtrics.SurveyEngine.QuestionData = Class.create({
	/**
	 * The question ID
	 * @property {string} questionId
	 */
	questionId:this.questionId || null,
	/**
	 * The question container
	 * @property {HTMLElement} questionContainer
	 */
	questionContainer:this.questionContainer || null,
	/**
	 * Can be set to a callback function to perform a custom function when any element of the question is clicked. The
	 * function will be passed the following parameters:
	 * @property {function} questionclick
	 * @param {event} event - The click event
	 * @param {HTMLElement} element - The element that was clicked
	 * @example
	 *	this.questionclick = function(event,element){
	 *		//for a single answer multiple choice question, the element type will be radio
	 *		if (element.type == 'radio')
	 *		{
	 *			var choiceNum = element.id.split('~')[2];
	 *			alert('You clicked on choice '+choiceNum);
	 *		}
	 *	}
	 */
	questionclick:this.questionclick || null,
	/**
	 * @class Qualtrics JavaScript Question API
	 * @constructor
	 * @param {string} [opt_questionId] - the id of the desired question
	 */
	initialize:function(opt_questionId)
	{
		var el = null;
		if(opt_questionId)
		{
			//we have a questionId so this will be easy
			this.questionContainer = $(opt_questionId);
		}
		if(!this.questionContainer)
		{
			//its probably being instaniated from markup inside the question at runtime, we can find the question by being tricky.
			var d=document.getElementsByTagName('script');
			el= d[d.length-1];
			this.questionContainer = $(el).up('.QuestionOuter') || $(el).up('question');
		}
		if(this.questionContainer)
		{
			this.questionId = this.questionContainer.getAttribute('questionid') || this.questionContainer.getAttribute('posttag');
			this.addOnClick();
			Qualtrics.SurveyEngine.registry[this.questionId] = this;
		}

	},
	/**
	 * Adds an observer/listener to the click event on the question.  Rather than calling addOnClick directly,
	 * this method will be called automatically by the addOnLoad method.  You only need to assign a function to the
	 * <a href="#property_questionclick">questionclick</a> property and the Survey Engine will take care of it for you.
	 * @method addOnClick
	 * @example
	 *	Qualtrics.SurveyEngine.addOnload(function ()
	 *	{
	 *		this.questionclick = function(event,element){
	 *			//for a single answer multiple choice question, the element type will be radio
	 *			if (element.type == 'radio')
	 *			{
	 *				var choiceNum = element.id.split('~')[2];
	 *				alert('You clicked on choice '+choiceNum);
	 *			}
	 *		}
	 *	});
	 */
	addOnClick:function()
	{
		this.questionclick = function(){};
		var that = this;
		Event.observe(this.questionContainer,'click',(function(event){that.questionclick(event,Event.element(event));}).bind(this));
	},
	/**
	 * Sets the disabled attribute to true on the Next Button to disable it
	 * @method disableNextButton
	 */
	disableNextButton: function()
	{
		if ($('NextButton'))
			$('NextButton').disabled = true;
	},
	/**
	 * Sets the disabled attribute to false on the Next Button to enable it
	 * @method enableNextButton
	 */
	enableNextButton: function()
	{
		if ($('NextButton'))
			$('NextButton').disabled = false;
	},
	/**
	 * Shows the Next Button
	 * @method showNextButton
	 */
	showNextButton: function()
	{
		if ($('NextButton'))
			$('NextButton').show();
	},
	/**
	 * Hides the Next Button
	 * @method hideNextButton
	 */
	hideNextButton: function()
	{
		if ($('NextButton'))
			$('NextButton').hide();
	},
	/**
	 * Emulates a click on the Next Button to submit the page
	 * @method clickNextButton
	 * @example
	 *	//Hides the next button and displays the question
	 *	//for 5 seconds before moving to the next page
	 *	this.hideNextButton();
	 *	var that = this;
	 *	(function(){that.clickNextButton();}).delay(5);
	 */
	clickNextButton:function()
	{
		var nextButton = $('NextButton');
		if (nextButton && nextButton.click)
			nextButton.click();
		else if(nextButton && nextButton.onclick)
			nextButton.onclick();
	},
	/**
	 * Sets the disabled attribute to true on the Previous Button to disable it
	 * @method disablePreviousButton
	 */
	disablePreviousButton: function()
	{
		if ($('PreviousButton'))
			$('PreviousButton').disabled = true;
	},
	/**
	 * Sets the disabled attribute to false on the Previous Button to enable it.
	 * @method enablePreviousButton
	 */
	enablePreviousButton: function()
	{
		if ($('PreviousButton'))
			$('PreviousButton').disabled = false;
	},
	/**
	 * Shows the Previous Button
	 * @method showPreviousButton
	 */
	showPreviousButton: function()
	{
		if ($('PreviousButton'))
			$('PreviousButton').show();
	},
	/**
	 * Hides the Previous Button
	 * @method hidePreviousButton
	 */
	hidePreviousButton: function()
	{
		if ($('PreviousButton'))
			$('PreviousButton').hide();
	},
	/**
	 * Emulates a click on the Previous Button to submit the page
	 * @method clickPreviousButton
	 */
	clickPreviousButton:function()
	{
		var previousButton = $('PreviousButton');
		if (previousButton && previousButton.click)
			previousButton.click();
		else if(previousButton && previousButton.onclick)
			previousButton.onclick();
	},
	/**
	 * Hides the choice container
	 * @method hideChoices
	 */
	hideChoices: function()
	{
		var choices = this.getChoiceContainer();
		if ($(choices))
			$(choices).hide();
	},
	/**
	 * Returns the div of the question (.QuestionOuter)
	 * @method getQuestionContainer
	 */
	getQuestionContainer:function()
	{
		return this.questionContainer;
	},
	/**
	 * Gets the div of the question text
	 * @method getQuestionTextContainer
	 * @example
	 *	$$('.QuestionText')
	 */
	getQuestionTextContainer:function()
	{
		return $(this.questionContainer).down('.QuestionText');
	},
	/**
	 * Gets the div of the choices
	 * @method getChoiceContainer
	 * @example
	 *	$$('.ChoiceStructure')
	 *
	 */
	getChoiceContainer: function()
	{
		return $(this.questionContainer).down('.ChoiceStructure');
	},
	/**
	 * Gets the input element according to the choiceId and answerId
	 * @method getInput
	 * @param {string} choiceId - the id of the desired input's choice
	 * @param {string} answerId - the id of the desired input's answer
	 * @param {boolean} [opt_returnArray] - set to true if the caller can handle an array return value
	 * @return {InputElement|Array} the Input Element, or if opt_returnArray is true, an array of elements (ie matrix single answer questions)
	 * @private
	 */
	getInput: function(choiceId, answerId, opt_returnArray)
	{
		var postTag = this.getPostTag() || this.questionId;

		var inputName = 'QR~' + postTag + ((!choiceId !== null && choiceId !== undefined)?('~' + choiceId):'');

		// Added because setChoiceValue was not working on drown down lists (or select boxes)
		// The getInput was not working correctly
		// QR~QID1~1 is an example name of the option tag, not the select input
		var questionType = $('QR~' + postTag + '~QuestionType');
		var questionSelector = $('QR~' + postTag + '~Selector');
		if(questionType && questionType.value === 'MC' && questionSelector && (questionSelector.value === 'DL' || questionSelector.value === 'SB'))
		{
			inputName = 'QR~' + postTag;
		}
		var valueName = inputName + ((answerId !== null && answerId !== undefined)?'~'+answerId:'');

		var input = null;
		// Fix for IE6 stupidity. document.getElementById will also look for inputs with a matching 'name' attribute.
		// The second part of this if statement is to make sure we are actually grabbing the id that we want, and not an erroneous form input.
		// Added in revision 15768 by daryl
		if ($(inputName) && $(inputName).id == inputName && ($(inputName).nodeName == 'INPUT' || $(inputName).nodeName == 'TEXTAREA' || $(inputName).nodeName == 'SELECT'))
		{
			input = $(inputName);
		}
		else if ($(valueName) && ($(valueName).nodeName == 'INPUT' || $(valueName).nodeName == 'TEXTAREA' || $(valueName).nodeName == 'SELECT'))
		{
			input = $(valueName);
		}
		else if ($('Select~' + postTag))
		{
			input = $('Select~' + postTag);
		}
		else if ($(valueName+'~TEXT'))	//Is this a text entry field?
		{
			input = $(valueName+'~TEXT');
		}
		else
		{
			//just look in the form
			if ($('Page')[inputName])
			{
				var control = $('Page')[inputName];
				//some controls come back looking like arrays (ie. matrix single answer)
				if (!control.getAttribute)
				{
					for(var i=0,ilen=control.length;i<ilen;i++)
					{
						if (control[i].value == valueName)
						{
							input = control[i];
							return input;

						}
					}
					if(opt_returnArray)
					{
						//if the caller can handle an array then return all of them
						return control;
					}
				}
				else
				{
					input = control;
				}

			}

		}

		return input;
	},

  /**
   * For javascript to get a timing question's time
   * @return {[type]} [description]
   */
  getCurrentVisualTime: function() {
    try {
    	return $('_' + this.questionId + 'Timer').getAttribute('time');
    } catch (e) {}

    return undefined;
  },
	/**
	 * Sets the value of the choice(s) specified by a recode value. Multiple choices in a question may have the same
	 * recode value. An attempt will be made to set each choice that is found. For single answer questions this may result
	 * in only the last matching choice being set.
	 *
	 * @method setChoiceValueByRecodeValue
	 * @param {string} recodeValue - The recode value of the choice(s) being set
	 * @param {string} [subId] - The ID of the Column Answer, etc.
	 * @param {string} value - The value being set
	 */
	setChoiceValueByRecodeValue:function()
	{
		//arguments[0] is variable name
		var choiceIds = this.getChoicesFromRecodeValue(arguments[0]); //this will return an array of matching choiceids
		for (var i=0,ilen=choiceIds.length;i<ilen;i++)
		{
			var cid = choiceIds[i];
			if (arguments.length == 3)
			{
				//arguments[1] is answerId, arguments[2] is value
				this.setChoiceAnswerValue(cid, arguments[1], arguments[2]);
			}
			else
			{
				//arguments[1] is value
				this.setChoiceAnswerValue(cid, null, arguments[1]);
			}
		}
	},
	/**
	 * Sets the value of the choice(s) specified by a variable name. Multiple choices in a question may have the same
	 * variable name. An attempt will be made to set each choice that is found. For single answer questions this may
	 * result in only the last matching choice being set.
	 *
	 * @method setChoiceValueByVariableName
	 * @param {string} variableName - The variable name of the choice(s) being set
	 * @param {string} [subId] - The ID of the Column Answer, etc.
	 * @param {string} value - The value being set
	 */
	setChoiceValueByVariableName:function()
	{
		//arguments[0] is variable name
		var choiceIds = this.getChoicesFromVariableName(arguments[0]); //this will return an array of matching choiceids
		for (var i=0,ilen=choiceIds.length;i<ilen;i++)
		{
			var cid = choiceIds[i];
			if (arguments.length == 3)
			{
				//arguments[1] is answerId, arguments[2] is value
				this.setChoiceAnswerValue(cid, arguments[1], arguments[2]);
			}
			else
			{
				//arguments[1] is value
				this.setChoiceAnswerValue(cid, null, arguments[1]);
			}
		}
	},
	/**
	 * Sets the actual value of a choice in the question. If a matrix-style question, also specify the subId (answerId).
	 *	@method setChoiceValue
	 * @param {string} choiceId - The ID of the choice being set
	 * @param {string} [subId] - The ID of the Column Answer, etc.
	 * @param {string} value - The value being set
	 */
	setChoiceValue: function()
	{
		if (arguments.length == 3)
		{
			//arguments[0] is choiceId, arguments[1] is answerId, arguments[2] is value
			this.setChoiceAnswerValue(arguments[0], arguments[1], arguments[2]);
		}
		else
		{
			//arguments[0] is choiceId, arguments[1] is value
			this.setChoiceAnswerValue(arguments[0], null, arguments[1]);
		}
	},
	/**
	 * Sets the choice answer's value
	 * @method setChoiceAnswerValue
	 * @param {string} choiceId
	 * @param {string} answerId
	 * @param {string} value
	 * @return true if success, false if failure
	 */
	setChoiceAnswerValue: function(choiceId, answerId, value)
	{
		var input = this.getInput(choiceId, answerId);

		if (input && (input.getAttribute('type') || input.tagName))
		{
			//this needs to be more complete
			var inputType = input.getAttribute('type') || input.tagName;
			switch(inputType)
			{
				case 'checkbox':
				case 'radio':
					input.checked = value;
					input.defaultChecked = value;

					var postTag = this.getPostTag() || this.questionId;

					var questionInfo = this.getQuestionInfo();
					if (questionInfo['QuestionType'] == 'Matrix')
					{
						exclusiveAnswerCheck('QR~' + postTag,'QR~' + postTag + '~' + choiceId, answerId);
						exclusiveChoiceCheck('QR~' + postTag,'QR~' + postTag + '~' + choiceId, choiceId, answerId);
					}
					else if (questionInfo['QuestionType'] == 'MC')
					{
						exclusiveAnswerCheck('QR~' + postTag,'QR~' + postTag, choiceId);
						exclusiveChoiceCheck('QR~' + postTag,'QR~' + postTag, choiceId, choiceId);
					}
				break;
				case 'SELECT':
					var postTag = this.getPostTag() || this.questionId;
					var valueName = 'QR~' + postTag + '~' + choiceId + (answerId !== null?'~'+answerId:'');
						for (var i=0,iLen=input.options.length; i < iLen; i++)
						{
							if (input.options[i].value == valueName)
							{
								// Added because setChoiceValue was not working on drown down lists (or select boxes)
								var questionType = $('QR~' + postTag + '~QuestionType');
								var questionSelector = $('QR~' + postTag + '~Selector');
								if(questionType && questionType.value === 'MC' && questionSelector && (questionSelector.value === 'DL' || questionSelector.value === 'SB'))
								{
									input.value = input.options[i].value;
								}
								else
								{
									input.options[i].setAttribute('selected', true);
								}
							}
						}
				break;
				default:

					// If this is a slider, set the actual slider bar
					var postTag = this.getPostTag() || this.questionId;
					var questionType = $('QR~' + postTag + '~QuestionType');
					if(questionType && questionType.value === 'Slider')
					{
						var slider = window['CS_' + postTag];
						var barTag = postTag + '~' + choiceId;
						if(slider && slider.snapToGrid)
						{
							value = (Math.round((value/100)*slider.gridLines)/slider.gridLines)*100;
						}
						slider.sliders[barTag].setValue(value/100);
					}
					input.value = value;
				break;
			}

			return true;
		}
		return false;
	},
	/**
	 * Gets the actual value of a choice in the question. If a matrix-style question, also specify the subId (answerId).
	 * @method getChoiceValue
	 * @example
	 *	this.getChoiceValue(3); //returns the value of choice 3
	 *	this.getChoiceValue(3,2); //returns the value of row choice 3 answer col 2
	 * @param {string} choiceId - The ID of the choice
	 * @param {string} [subId] - The ID of the Column Answer, etc.
	 * @return {string} the value of the choice
	 */
	getChoiceValue:function(choiceId, subId)
	{
		var ret = false;
		var input = this.getInput(choiceId, null, true);
		if (input && input.getAttribute && (input.getAttribute('type') || input.tagName))
		{
			//this needs to be more complete
			var inputType = input.getAttribute('type') || input.tagName;
			switch(inputType)
			{
				case 'checkbox':
				case 'radio':
					ret = input.checked;
				break;
				case 'SELECT':
					var postTag = this.getPostTag() || this.questionId;
					var valueName = 'QR~' + postTag + '~' + choiceId + (subId?'~'+subId:'');
					ret = input.options[input.selectedIndex].value == valueName;
				break;
				default:
					ret = input.value;
				break;
			}
		}
		else if(input && input.length)
		{
			//we have an array, we need to loop through them all and figure out which one is selected
			//this is used for the radio button version of rank order
			for(var i=0,ilen=input.length;i<ilen;i++)
			{
				if(input[i].checked)
				{
					return input[i].value;
				}
			}
		}
		return ret;
	},
	/**
	 * Gets the value of the input text
	 * @method getTextValue
	 * @param {string} [opt_choiceId]
	 * @return value of the current choice's input
	 */
	getTextValue:function(opt_choiceId)
	{
		var input = null;
		if(opt_choiceId)
		{
			input = this.getInput(opt_choiceId+'~TEXT', null);
		}
		else
		{
			input = this.getInput();
		}
		if(input)
		{
			return input.value;
		}
	},
	/**
	 *
	 * @method getChoiceAnswerValue
	 * @param {string} choiceId
	 * @param {string} answerId
	 * @param {string} subId
	 * @return {string} value of the choice answer
	 */
	getChoiceAnswerValue:function(choiceId, answerId, subId)
	{
		var ret = null;
		var input = this.getInput(choiceId, answerId);
		if (input && (input.getAttribute('type') || input.tagName))
		{
			//this needs to be more complete
			var inputType = input.getAttribute('type') || input.tagName;
			switch(inputType)
			{
				case 'checkbox':
				case 'radio':
					ret = input.checked;
				break;
				case 'SELECT':
					var postTag = this.getPostTag() || this.questionId;
					var valueName = 'QR~' + postTag + '~' + choiceId + (subId?'~'+subId:'');
					ret = input.options[input.selectedIndex].value == valueName;
				break;
				default:
					ret = input.value;
				break;
			}
		}
		return ret;
	},
	/**
	 * Determines if the question is displayed or hidden
	 * @method getQuestionDisplayed
	 * @return {boolean} true if displayed
	 */
	getQuestionDisplayed:function()
	{
		var questionIsHidden = this.questionContainer.getAttribute('hiddenbyinpagedisplaylogic')=='true'?true:false;
		return !questionIsHidden;
	},
	/**
	 * Determines if the choice is displayed or hidden
	 * @method getChoiceDisplayed
	 * @return {boolean} true if displayed
	 * @param {string} choiceId
	 * @param {string} answerId
	 * @param {string} subId
	 */
	getChoiceDisplayed:function(choiceId, answerId, subId)
	{
		var questionIsHidden = this.questionContainer.getAttribute('hiddenbyinpagedisplaylogic')=='true'?true:false;
		if(questionIsHidden)
		{
			return false;
		}

		//the question is on the page so lets try to find the choice
		var input = this.getInput(choiceId, answerId);
		if(input)
		{
			if(subId)
			{
				if(input.options[subId])
				{
					//THIS NEEDS TESTING
					return true;
				}
			}
			else
			{
				return true;
			}
		}
		return false;
	},
	/**
	 * Returns an object containing information about the question.
	 * See <a href="#property_Qualtrics.SurveyEngine.QuestionInfo">Qualtrics.SurveyEngine.QuestionInfo</a>
	 *
	 * @method getQuestionInfo
	 * @return {object | null} QuestionInfo
	 */
	getQuestionInfo:function()
	{
		if (Qualtrics.SurveyEngine && Qualtrics.SurveyEngine.QuestionInfo && Qualtrics.SurveyEngine.QuestionInfo[this.questionId])
		{
			return Qualtrics.SurveyEngine.QuestionInfo[this.questionId];
		}
		return null;
	},
	/**
	 * Gets the post tag from the current question's QuestionInfo object
	 * @method getPostTag
	 * @return {string | null}
	 */
	getPostTag:function()
	{
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo.postTag)
		{
			return questionInfo.postTag;
		}
		return null;
	},
	/**
	 * Gets the choice's recode value
	 * @method getChoiceRecodeValue
	 * @param {string} choiceId
	 */
	getChoiceRecodeValue:function(choiceId)
	{
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Choices'][choiceId])
		{
			return questionInfo['Choices'][choiceId]['RecodeValue'];
		}
	},
	getAnswerRecodeValue:function(answerId)
	{
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Answers'] && questionInfo['Answers'][answerId])
		{
			return questionInfo['Answers'][answerId]['RecodeValue'];
		}
	},
	/**
	 * Gets the choice's variable name
	 * @method getChoiceVariableName
	 * @param {string} choiceId
	 */
	getChoiceVariableName:function(choiceId)
	{
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Choices'][choiceId])
		{
			return questionInfo['Choices'][choiceId]['VariableName'];
		}
	},
	/**
	 * Gets the choice ids that have matching variable names
	 * @method getChoicesFromVariableName
	 * @param {string} varName - The variable name to search for
	 * @return {array} choice ids with matching variable name
	 */
	getChoicesFromVariableName:function(varName)
	{
		return this.getChoicesFromQuestionInfo('VariableName',varName);
	},
	/**
	 * Gets the choice ids that have matching recode values
	 * @method getChoicesFromRecodeValue
	 * @param {string} recodeVal
	 * @return {array} choice ids with matching recode value
	 */
	getChoicesFromRecodeValue:function(recodeVal)
	{
		return this.getChoicesFromQuestionInfo('RecodeValue',recodeVal);
	},
	/**
	 * Gets the choices from the question info
	 * @method getChoicesFromQuestionInfo
	 * @param {string} type
	 * @param {string} val
	 * @private
	 */
	getChoicesFromQuestionInfo:function(type,val)
	{
		var choices = [];
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Choices'])
		{
			for (var cid in questionInfo['Choices'])
			{
				if (val == questionInfo['Choices'][cid][type])
				{
					choices.push(cid);
				}
			}
		}
		return choices;
	},
	/**
	 * Gets the choices
	 * @method getChoices
	 * @return {array}
	 */
	getChoices:function()
	{
		var choices = [];
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Choices'])
		{
			for (var cid in questionInfo['Choices'])
			{
				choices.push(cid);
			}
		}
		return choices;
	},
	/**
	 * Gets the answer ids for the question.
	 * @method getAnswers
	 * @return {array}
	 */
	getAnswers:function()
	{
		var answers = [];
		var questionInfo = this.getQuestionInfo();
		if (questionInfo && questionInfo['Answers'])
		{
			for (var aid in questionInfo['Answers'])
			{
				answers.push(aid);
			}
		}
		return answers;
	},
	/**
	 * Gets the selected choices
	 * @method getSelectedChoices
	 */
	getSelectedChoices:function()
	{
		var choices = this.getChoices();
		var selectedChoices = [];
		for(var i=0, len=choices.length; i<len; ++i)
		{
			if(this.getChoiceValue(choices[i]))
			{
				selectedChoices.push(choices[i]);
			}
		}
		return selectedChoices;
	},
	/**
	 * Gets the selected answers
	 * @method getSelectedAnswers
	 */
	getSelectedAnswers:function()
	{
		var choices = this.getChoices();
		var answers = this.getAnswers();
		var selectedAnswers = {};
		for(var i=0, len=choices.length; i<len; ++i)
		{
			for(var a=0, alen=answers.length; a<alen; ++a)
			{
				if(this.getChoiceAnswerValue(choices[i], answers[a]))
				{
					if(!selectedAnswers[answers[a]])
					{
						selectedAnswers[answers[a]] = 0;
					}
					selectedAnswers[answers[a]]++;
				}
			}
		}
		return selectedAnswers;
	},
	/**
	 * Gets the selected answer's value
	 * @method getSelectedAnswerValue
	 * @param choiceId
	 */
	getSelectedAnswerValue:function(choiceId)
	{
		var answers = this.getAnswers();
		var choices = this.getChoices();
		var selectedAnswerValue = null;
		for(var a=0, alen=answers.length; a<alen; ++a)
		{
			if(this.getChoiceAnswerValue(choiceId, answers[a], answers[a]))
			{
				if(selectedAnswerValue == null || selectedAnswerValue > answers[a])
					selectedAnswerValue = answers[a];
			}
		}
		return selectedAnswerValue;
	}
});
/**
 * @class Qualtrics JavaScript Question API
 */

/**
 * Finds the data for the specified question
 *
 * @method getInstance
 * @param {string} questionId - the id of the question whose data is being requested.
 *	If the registry does not contain a question with this id, a new instance of QuestionData will be created.
 * @param {boolean} [opt_createNewInstance] - (currently unused) if true will return a new instance of the class
 * @private
 */
Qualtrics.SurveyEngine.QuestionData.getInstance = function(questionId)
{
	if(Qualtrics.SurveyEngine.registry[questionId])
	{
		return Qualtrics.SurveyEngine.registry[questionId];
	}
	return new Qualtrics.SurveyEngine.QuestionData(questionId);
};

//Keep this @class declaration because it helps the docs to correctly place the methods in the SurveyEngine class
/**
 * @class Qualtrics JavaScript Question API
 */

/**
 * End of Survey Trigger
 * define a qualtricsEndOfSurvey in window.parent, and it will execute on survey complete.
 *
 * @method OnEndOfSurvey
 * @private
 */
Qualtrics.SurveyEngine.OnEndOfSurvey = function()
{
	//if they have an embedded survey they can define a qualtricsEndOfSurvey in the parent that will execute on survey complete.
	// Used for all surveys in the 360 Participant Portal
	try
	{
		if (window.top.postMessage && $('SessionID'))
		{
			var sid = $F('SurveyID');
			var ssid = $F('SessionID');
			window.top.postMessage('closeQSIWindow','*');
			window.top.postMessage('QualtricsEOS|'+sid + '|'+ssid,'*');
		}
		if(window.parent && window.parent.qualtricsEndOfSurvey)
		{
			window.parent.qualtricsEndOfSurvey.call(window.parent);
		}
	}
	catch(e)
	{
		console.log(e);
	}
};
/**
 * Use this if you have an embedded survey.
 * You can define a qualtricsPageLoad in window.parent, and it will execute on page load.
 * @method onPageLoad
 * @private
 */
Qualtrics.SurveyEngine.onPageLoad = function()
{
	try
	{
		if (window.canCheckParent)
		{
	//if they have an embedded survey they can define a qualtricsPageLoad in the parent that will execute on page load.
			if(window.parent)
			{
				if(window.parent.qualtricsPageLoad)
				{
					window.parent.qualtricsPageLoad.call(window.parent);
				}
			}
		}
	}
	catch(e)
	{

	}
};
/**
 * @method savePageBeforeUnload
 * @private
 */
Qualtrics.SurveyEngine.savePageBeforeUnload = function()
{
	if (!window.noSEAutoSave)
	{
		if (!$('submitPageFeauBTN'))
		{
			if ($('PreviousButton'))
				$('PreviousButton').disable();
			if ($('NextButton'))
				$('NextButton').disable();
		}
		if ($F('SessionID') != 'DummySessionID')
			$('Page').request({
				parameters: {
					SavePageButton: true,
					ReturnSessionMeta: true
				},
				asynchronous: false
			});

		//in case it's a captcha reload call in internet explorer, re-enable the buttons after .1 seconds
		if ($('PreviousButton'))
			(function(){$('PreviousButton').disabled=false;}).defer(0.1);
		if ($('NextButton'))
			(function(){$('NextButton').disabled=false;}).defer(0.1);
	}
};
/**
 * changeLanguage // intentionally leaving out the method
 */
Qualtrics.SurveyEngine.changeLanguage = function()
{
	window.noSEAutoSave = true; // Turns off the autoSave
	submitForm('Page');
};
/**
 *
 * @method inputClickHelper
 * @param {event} e
 * @private
 */
Qualtrics.inputClickHelper = function(e)
{
	e = e||window.event;
	var el = Event.element(e);
	var kids = el.childNodes;
	var count = 0;
	var inputNode = null;
	if (kids && kids.length)
	{
		for(i=0;i<kids.length;i++)
		{
			if(kids[i].nodeName == 'INPUT' && (kids[i].type == 'radio' || kids[i].type == 'checkbox'))
			{
				count++;
				inputNode = kids[i];
			}
		}
	}

	//Abort any clicking on these, since they already do their own handling
	if (el.nodeName == 'LABEL' || el.nodeName == 'INPUT')
		return;

	if(count == 1 && inputNode)
	{
		inputNode.click();
	}

	//IE fix to select an input when clicking on an IMG
	if (el.parentNode && el.parentNode.nodeName == 'LABEL' && el.parentNode.click && Qualtrics.Browser.IE && Qualtrics.Browser.Version <= 8)
	{
		el.parentNode.click();
	}
};
/**
 * Print the page in PDF
 * @method openPageInPDF
 * @private
 */
Qualtrics.openPageInPDF = function()
{
	QModules.loadModule('/WRQualtricsShared/JavaScript/Libraries/QPDFPrinter.js');
	var pages = [QBuilder('div', {}, [$('SurveyEngineBody').cloneNode(true)])];
	QPDFPrinter.print(pages,{
		includeCSS:true,
		orientation:'portrait',
		filename:'surveysummary.pdf',
		usePrintMediaType:true,
		paginate:true,
		background:true,
		margin:'0px',
		marginTop:'50px',
		marginBottom:'50px',
		baseCSS: 'width: auto;',
		customCSS:' div.END_OF_SURVEY,div#EndSurveyResponseSummary,.DownloadResponsesPDF { display: none; } .Skin input[type=radio], .Skin input[type=checkbox] { opacity: .3; } .Skin input[type=radio]:checked, .Skin input[type=checkbox]:checked {	opacity: 1;	}	.QuestionOuter { page-break-inside: avoid; page-break-before: auto; }'
	});

};

Qualtrics.syncLabelsAndInputs = function(addEvent) {
  // this is only needed for V4 skins
  if (!$('SurveyEngineBody') || !$('SurveyEngineBody').hasClassName('CSSV4')) {
    return;
  }

	if (addEvent === undefined)
		addEvent = true;

    Qualtrics.cachedInputs = Qualtrics.cachedInputs || $$('#Questions input[type="radio"], #Questions input[type="checkbox"]');
    Qualtrics.cachedInputs.each(function(input) {
        Qualtrics.cachedLabels = Qualtrics.cachedLabels || {};
        Qualtrics.cachedLabels[input.id] = Qualtrics.cachedLabels[input.id] || $$('label[for="' + input.id + '"]');
		Qualtrics.cachedLabels[input.id].each(function(label) {
			if (!label.hasClassName('offScreen'))
			{
				// add the classname to already selected inputs
				if (input.checked)
					label.addClassName('q-checked');
				else
					label.removeClassName('q-checked');

				// set class name to distinguish radio buttons from check boxes
				if (!label.hasClassName('q-radio') && !label.hasClassName('q-checkbox'))
				{
					if (input.type === 'radio')
					{
						label.addClassName('SingleAnswer');
					} else {
						// checkboxes
						label.addClassName('MultipleAnswer');
					}
				}

				if (addEvent)
				{
					input.on('click', function(event, el)
					{
						var questionOuter = $(el).up('.QuestionOuter');
						if (questionOuter)
						{
							var qId = questionOuter.id;
							Qualtrics.cachedQuestionInputs = Qualtrics.cachedQuestionInputs || {};
							Qualtrics.cachedQuestionInputs[qId] = Qualtrics.cachedQuestionInputs[qId] || questionOuter.select('input[type="radio"], input[type="checkbox"]');
							Qualtrics.cachedQuestionInputs[qId].each(function(questionInput) {
								Qualtrics.cachedLabels[questionInput.id] = Qualtrics.cachedLabels[questionInput.id] || $$('label[for="' + questionInput.id + '"]');
								Qualtrics.cachedLabels[questionInput.id].each(function(inputLabel) {
									if (!inputLabel.hasClassName('offScreen'))
									{
										if (questionInput.checked && !inputLabel.hasClassName('q-checked'))
										{
											inputLabel.addClassName('q-checked');
										}
										else if (!questionInput.checked && inputLabel.hasClassName('q-checked'))
										{
											inputLabel.removeClassName('q-checked');
										}
									}
								});
							});
						}
					});

					input.on('focus', function(event, el)
					{
						Qualtrics.cachedLabels[el.id] = Qualtrics.cachedLabels[el.id] || $$('label[for="' + el.id + '"]');
						Qualtrics.cachedLabels[el.id].each(function(inputLabel) {
							if (!inputLabel.hasClassName('offScreen'))
							{
								inputLabel.addClassName('q-focused');
							}
						});
					});
					input.on('blur', function(event, el)
					{
						Qualtrics.cachedLabels[el.id] = Qualtrics.cachedLabels[el.id] || $$('label[for="' + el.id + '"]');
						Qualtrics.cachedLabels[el.id].each(function(inputLabel) {
							inputLabel.removeClassName('q-focused');
						});
					});
				}
			}
		});
	});
};

Qualtrics.uniformLabelHeight = function() {
	var makeUniform = function($question)
	{
		var tallest = 0;
		var labels = $question.select('label.SingleAnswer, label.MultipleAnswer');
		labels.each(function(label) {
			if (label.getHeight() > tallest)
			{
				tallest = label.getHeight();
			}
		});

		labels.each(function(label) {
			var layout = label.getLayout();
			var newHeight = tallest - layout.get('border-box-height');
			newHeight = parseInt(newHeight/2);

			var paddingTop = layout.get('padding-top') + newHeight;
			var paddingBottom = layout.get('padding-bottom') + newHeight;

			label.setStyle({
				paddingTop: paddingTop + 'px',
				paddingBottom: paddingBottom + 'px'
			});
		});
	};

	// MC Horizontal Row, MC Column
	$$('.QuestionOuter.MC .Inner.SAHR, .QuestionOuter.MC .Inner.MAHR, .QuestionOuter.MC .Inner.MACOL, .QuestionOuter.MC .Inner.SACOL').each(function(questionInner) {
		makeUniform(questionInner);
	});

	// Matrix Profile
	$$('.QuestionOuter.Matrix .Inner.Profile').each(function(questionInner) {
		makeUniform(questionInner);
	});

	// GAP
	$$('.QuestionOuter.GAP').each(function(questionInner) {
		makeUniform(questionInner);
	});
};

Event.observe(window,'load',function()
{
	if($('SurveyEngineBody'))
	{
		// put the focus on the first input element if not a preview survey
		/* NO! DONT! THIS BIASES THE RESPONSE!
		if ($('Page') && $('Page').nodeName == "FORM" && $('Page').findFirstElement())
		{
			var first = $('Page').findFirstElement();
			first.focus();
		}
		*/
		Event.observe('SurveyEngineBody', 'mousedown', Qualtrics.inputClickHelper);
	}

	Qualtrics.syncLabelsAndInputs(true);
	// dirty watch to check for javascript changes
	setTimeout(function dirtyWatch() {
        Qualtrics.syncLabelsAndInputs(false);
        setTimeout(dirtyWatch, 200);
    }, 200);
});

Event.observe(document, 'keydown', Qualtrics.SurveyEngine.globalKeyDownHandler);
Event.observe(document, 'keyup', Qualtrics.SurveyEngine.globalKeyUpHandler);
